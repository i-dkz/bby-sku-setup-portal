"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ __webpack_exports__AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ __webpack_exports__AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ __webpack_exports__AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ __webpack_exports__AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ __webpack_exports__AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ __webpack_exports__AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ __webpack_exports__AnnotationMode),\n/* harmony export */   CMapCompressionType: () => (/* binding */ __webpack_exports__CMapCompressionType),\n/* harmony export */   ColorPicker: () => (/* binding */ __webpack_exports__ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ __webpack_exports__DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ __webpack_exports__DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ __webpack_exports__FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ __webpack_exports__GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ __webpack_exports__ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ __webpack_exports__InvalidPDFException),\n/* harmony export */   MissingPDFException: () => (/* binding */ __webpack_exports__MissingPDFException),\n/* harmony export */   OPS: () => (/* binding */ __webpack_exports__OPS),\n/* harmony export */   Outliner: () => (/* binding */ __webpack_exports__Outliner),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ __webpack_exports__PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ __webpack_exports__PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ __webpack_exports__PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ __webpack_exports__PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ __webpack_exports__PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ __webpack_exports__PixelsPerInch),\n/* harmony export */   PromiseCapability: () => (/* binding */ __webpack_exports__PromiseCapability),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ __webpack_exports__RenderingCancelledException),\n/* harmony export */   UnexpectedResponseException: () => (/* binding */ __webpack_exports__UnexpectedResponseException),\n/* harmony export */   Util: () => (/* binding */ __webpack_exports__Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ __webpack_exports__VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ __webpack_exports__XfaLayer),\n/* harmony export */   build: () => (/* binding */ __webpack_exports__build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ __webpack_exports__createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ __webpack_exports__fetchData),\n/* harmony export */   getDocument: () => (/* binding */ __webpack_exports__getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ __webpack_exports__getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ __webpack_exports__getPdfFilenameFromUrl),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ __webpack_exports__getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ __webpack_exports__isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ __webpack_exports__isPdfFile),\n/* harmony export */   noContextMenu: () => (/* binding */ __webpack_exports__noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ __webpack_exports__normalizeUnicode),\n/* harmony export */   renderTextLayer: () => (/* binding */ __webpack_exports__renderTextLayer),\n/* harmony export */   setLayerDimensions: () => (/* binding */ __webpack_exports__setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ __webpack_exports__shadow),\n/* harmony export */   updateTextLayer: () => (/* binding */ __webpack_exports__updateTextLayer),\n/* harmony export */   version: () => (/* binding */ __webpack_exports__version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /******/ var __webpack_modules__ = {\n    /***/ 640: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_912__)=>{\n        // EXPORTS\n        __nested_webpack_require_912__.d(__nested_webpack_exports__, {\n            AnnotationLayer: ()=>/* binding */ AnnotationLayer,\n            FreeTextAnnotationElement: ()=>/* binding */ FreeTextAnnotationElement,\n            InkAnnotationElement: ()=>/* binding */ InkAnnotationElement,\n            StampAnnotationElement: ()=>/* binding */ StampAnnotationElement\n        });\n        // EXTERNAL MODULE: ./src/shared/util.js\n        var util = __nested_webpack_require_912__(266);\n        // EXTERNAL MODULE: ./src/display/display_utils.js\n        var display_utils = __nested_webpack_require_912__(473);\n        // EXTERNAL MODULE: ./src/display/annotation_storage.js\n        var annotation_storage = __nested_webpack_require_912__(780);\n        ; // CONCATENATED MODULE: ./src/shared/scripting_utils.js\n        function makeColorComp(n) {\n            return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n        }\n        function scaleAndClamp(x) {\n            return Math.max(0, Math.min(255, 255 * x));\n        }\n        class ColorConverters {\n            static CMYK_G([c, y, m, k]) {\n                return [\n                    \"G\",\n                    1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n                ];\n            }\n            static G_CMYK([g]) {\n                return [\n                    \"CMYK\",\n                    0,\n                    0,\n                    0,\n                    1 - g\n                ];\n            }\n            static G_RGB([g]) {\n                return [\n                    \"RGB\",\n                    g,\n                    g,\n                    g\n                ];\n            }\n            static G_rgb([g]) {\n                g = scaleAndClamp(g);\n                return [\n                    g,\n                    g,\n                    g\n                ];\n            }\n            static G_HTML([g]) {\n                const G = makeColorComp(g);\n                return `#${G}${G}${G}`;\n            }\n            static RGB_G([r, g, b]) {\n                return [\n                    \"G\",\n                    0.3 * r + 0.59 * g + 0.11 * b\n                ];\n            }\n            static RGB_rgb(color) {\n                return color.map(scaleAndClamp);\n            }\n            static RGB_HTML(color) {\n                return `#${color.map(makeColorComp).join(\"\")}`;\n            }\n            static T_HTML() {\n                return \"#00000000\";\n            }\n            static T_rgb() {\n                return [\n                    null\n                ];\n            }\n            static CMYK_RGB([c, y, m, k]) {\n                return [\n                    \"RGB\",\n                    1 - Math.min(1, c + k),\n                    1 - Math.min(1, m + k),\n                    1 - Math.min(1, y + k)\n                ];\n            }\n            static CMYK_rgb([c, y, m, k]) {\n                return [\n                    scaleAndClamp(1 - Math.min(1, c + k)),\n                    scaleAndClamp(1 - Math.min(1, m + k)),\n                    scaleAndClamp(1 - Math.min(1, y + k))\n                ];\n            }\n            static CMYK_HTML(components) {\n                const rgb = this.CMYK_RGB(components).slice(1);\n                return this.RGB_HTML(rgb);\n            }\n            static RGB_CMYK([r, g, b]) {\n                const c = 1 - r;\n                const m = 1 - g;\n                const y = 1 - b;\n                const k = Math.min(c, m, y);\n                return [\n                    \"CMYK\",\n                    c,\n                    m,\n                    y,\n                    k\n                ];\n            }\n        }\n        // EXTERNAL MODULE: ./src/display/xfa_layer.js\n        var xfa_layer = __nested_webpack_require_912__(160);\n        ; // CONCATENATED MODULE: ./src/display/annotation_layer.js\n        const DEFAULT_TAB_INDEX = 1000;\n        const DEFAULT_FONT_SIZE = 9;\n        const GetElementsByNameSet = new WeakSet();\n        function getRectDims(rect) {\n            return {\n                width: rect[2] - rect[0],\n                height: rect[3] - rect[1]\n            };\n        }\n        class AnnotationElementFactory {\n            static create(parameters) {\n                const subtype = parameters.data.annotationType;\n                switch(subtype){\n                    case util.AnnotationType.LINK:\n                        return new LinkAnnotationElement(parameters);\n                    case util.AnnotationType.TEXT:\n                        return new TextAnnotationElement(parameters);\n                    case util.AnnotationType.WIDGET:\n                        const fieldType = parameters.data.fieldType;\n                        switch(fieldType){\n                            case \"Tx\":\n                                return new TextWidgetAnnotationElement(parameters);\n                            case \"Btn\":\n                                if (parameters.data.radioButton) {\n                                    return new RadioButtonWidgetAnnotationElement(parameters);\n                                } else if (parameters.data.checkBox) {\n                                    return new CheckboxWidgetAnnotationElement(parameters);\n                                }\n                                return new PushButtonWidgetAnnotationElement(parameters);\n                            case \"Ch\":\n                                return new ChoiceWidgetAnnotationElement(parameters);\n                            case \"Sig\":\n                                return new SignatureWidgetAnnotationElement(parameters);\n                        }\n                        return new WidgetAnnotationElement(parameters);\n                    case util.AnnotationType.POPUP:\n                        return new PopupAnnotationElement(parameters);\n                    case util.AnnotationType.FREETEXT:\n                        return new FreeTextAnnotationElement(parameters);\n                    case util.AnnotationType.LINE:\n                        return new LineAnnotationElement(parameters);\n                    case util.AnnotationType.SQUARE:\n                        return new SquareAnnotationElement(parameters);\n                    case util.AnnotationType.CIRCLE:\n                        return new CircleAnnotationElement(parameters);\n                    case util.AnnotationType.POLYLINE:\n                        return new PolylineAnnotationElement(parameters);\n                    case util.AnnotationType.CARET:\n                        return new CaretAnnotationElement(parameters);\n                    case util.AnnotationType.INK:\n                        return new InkAnnotationElement(parameters);\n                    case util.AnnotationType.POLYGON:\n                        return new PolygonAnnotationElement(parameters);\n                    case util.AnnotationType.HIGHLIGHT:\n                        return new HighlightAnnotationElement(parameters);\n                    case util.AnnotationType.UNDERLINE:\n                        return new UnderlineAnnotationElement(parameters);\n                    case util.AnnotationType.SQUIGGLY:\n                        return new SquigglyAnnotationElement(parameters);\n                    case util.AnnotationType.STRIKEOUT:\n                        return new StrikeOutAnnotationElement(parameters);\n                    case util.AnnotationType.STAMP:\n                        return new StampAnnotationElement(parameters);\n                    case util.AnnotationType.FILEATTACHMENT:\n                        return new FileAttachmentAnnotationElement(parameters);\n                    default:\n                        return new AnnotationElement(parameters);\n                }\n            }\n        }\n        class AnnotationElement {\n            #hasBorder;\n            constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n                this.#hasBorder = false;\n                this.isRenderable = isRenderable;\n                this.data = parameters.data;\n                this.layer = parameters.layer;\n                this.linkService = parameters.linkService;\n                this.downloadManager = parameters.downloadManager;\n                this.imageResourcesPath = parameters.imageResourcesPath;\n                this.renderForms = parameters.renderForms;\n                this.svgFactory = parameters.svgFactory;\n                this.annotationStorage = parameters.annotationStorage;\n                this.enableScripting = parameters.enableScripting;\n                this.hasJSActions = parameters.hasJSActions;\n                this._fieldObjects = parameters.fieldObjects;\n                this.parent = parameters.parent;\n                if (isRenderable) {\n                    this.container = this._createContainer(ignoreBorder);\n                }\n                if (createQuadrilaterals) {\n                    this._createQuadrilaterals();\n                }\n            }\n            static _hasPopupData({ titleObj, contentsObj, richText }) {\n                return !!(titleObj?.str || contentsObj?.str || richText?.str);\n            }\n            get hasPopupData() {\n                return AnnotationElement._hasPopupData(this.data);\n            }\n            _createContainer(ignoreBorder) {\n                const { data, parent: { page, viewport } } = this;\n                const container = document.createElement(\"section\");\n                container.setAttribute(\"data-annotation-id\", data.id);\n                if (!(this instanceof WidgetAnnotationElement)) {\n                    container.tabIndex = DEFAULT_TAB_INDEX;\n                }\n                container.style.zIndex = this.parent.zIndex++;\n                if (this.data.popupRef) {\n                    container.setAttribute(\"aria-haspopup\", \"dialog\");\n                }\n                if (data.noRotate) {\n                    container.classList.add(\"norotate\");\n                }\n                const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                if (!data.rect || this instanceof PopupAnnotationElement) {\n                    const { rotation } = data;\n                    if (!data.hasOwnCanvas && rotation !== 0) {\n                        this.setRotation(rotation, container);\n                    }\n                    return container;\n                }\n                const { width, height } = getRectDims(data.rect);\n                const rect = util.Util.normalizeRect([\n                    data.rect[0],\n                    page.view[3] - data.rect[1] + page.view[1],\n                    data.rect[2],\n                    page.view[3] - data.rect[3] + page.view[1]\n                ]);\n                if (!ignoreBorder && data.borderStyle.width > 0) {\n                    container.style.borderWidth = `${data.borderStyle.width}px`;\n                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n                    const verticalRadius = data.borderStyle.verticalCornerRadius;\n                    if (horizontalRadius > 0 || verticalRadius > 0) {\n                        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                        container.style.borderRadius = radius;\n                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                        container.style.borderRadius = radius;\n                    }\n                    switch(data.borderStyle.style){\n                        case util.AnnotationBorderStyleType.SOLID:\n                            container.style.borderStyle = \"solid\";\n                            break;\n                        case util.AnnotationBorderStyleType.DASHED:\n                            container.style.borderStyle = \"dashed\";\n                            break;\n                        case util.AnnotationBorderStyleType.BEVELED:\n                            (0, util.warn)(\"Unimplemented border style: beveled\");\n                            break;\n                        case util.AnnotationBorderStyleType.INSET:\n                            (0, util.warn)(\"Unimplemented border style: inset\");\n                            break;\n                        case util.AnnotationBorderStyleType.UNDERLINE:\n                            container.style.borderBottomStyle = \"solid\";\n                            break;\n                        default:\n                            break;\n                    }\n                    const borderColor = data.borderColor || null;\n                    if (borderColor) {\n                        this.#hasBorder = true;\n                        container.style.borderColor = util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n                    } else {\n                        container.style.borderWidth = 0;\n                    }\n                }\n                container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n                container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n                const { rotation } = data;\n                if (data.hasOwnCanvas || rotation === 0) {\n                    container.style.width = `${100 * width / pageWidth}%`;\n                    container.style.height = `${100 * height / pageHeight}%`;\n                } else {\n                    this.setRotation(rotation, container);\n                }\n                return container;\n            }\n            setRotation(angle, container = this.container) {\n                if (!this.data.rect) {\n                    return;\n                }\n                const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n                const { width, height } = getRectDims(this.data.rect);\n                let elementWidth, elementHeight;\n                if (angle % 180 === 0) {\n                    elementWidth = 100 * width / pageWidth;\n                    elementHeight = 100 * height / pageHeight;\n                } else {\n                    elementWidth = 100 * height / pageWidth;\n                    elementHeight = 100 * width / pageHeight;\n                }\n                container.style.width = `${elementWidth}%`;\n                container.style.height = `${elementHeight}%`;\n                container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n            }\n            get _commonActions() {\n                const setColor = (jsName, styleName, event)=>{\n                    const color = event.detail[jsName];\n                    const colorType = color[0];\n                    const colorArray = color.slice(1);\n                    event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n                    this.annotationStorage.setValue(this.data.id, {\n                        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n                    });\n                };\n                return (0, util.shadow)(this, \"_commonActions\", {\n                    display: (event)=>{\n                        const { display } = event.detail;\n                        const hidden = display % 2 === 1;\n                        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                        this.annotationStorage.setValue(this.data.id, {\n                            noView: hidden,\n                            noPrint: display === 1 || display === 2\n                        });\n                    },\n                    print: (event)=>{\n                        this.annotationStorage.setValue(this.data.id, {\n                            noPrint: !event.detail.print\n                        });\n                    },\n                    hidden: (event)=>{\n                        const { hidden } = event.detail;\n                        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                        this.annotationStorage.setValue(this.data.id, {\n                            noPrint: hidden,\n                            noView: hidden\n                        });\n                    },\n                    focus: (event)=>{\n                        setTimeout(()=>event.target.focus({\n                                preventScroll: false\n                            }), 0);\n                    },\n                    userName: (event)=>{\n                        event.target.title = event.detail.userName;\n                    },\n                    readonly: (event)=>{\n                        event.target.disabled = event.detail.readonly;\n                    },\n                    required: (event)=>{\n                        this._setRequired(event.target, event.detail.required);\n                    },\n                    bgColor: (event)=>{\n                        setColor(\"bgColor\", \"backgroundColor\", event);\n                    },\n                    fillColor: (event)=>{\n                        setColor(\"fillColor\", \"backgroundColor\", event);\n                    },\n                    fgColor: (event)=>{\n                        setColor(\"fgColor\", \"color\", event);\n                    },\n                    textColor: (event)=>{\n                        setColor(\"textColor\", \"color\", event);\n                    },\n                    borderColor: (event)=>{\n                        setColor(\"borderColor\", \"borderColor\", event);\n                    },\n                    strokeColor: (event)=>{\n                        setColor(\"strokeColor\", \"borderColor\", event);\n                    },\n                    rotation: (event)=>{\n                        const angle = event.detail.rotation;\n                        this.setRotation(angle);\n                        this.annotationStorage.setValue(this.data.id, {\n                            rotation: angle\n                        });\n                    }\n                });\n            }\n            _dispatchEventFromSandbox(actions, jsEvent) {\n                const commonActions = this._commonActions;\n                for (const name of Object.keys(jsEvent.detail)){\n                    const action = actions[name] || commonActions[name];\n                    action?.(jsEvent);\n                }\n            }\n            _setDefaultPropertiesFromJS(element) {\n                if (!this.enableScripting) {\n                    return;\n                }\n                const storedData = this.annotationStorage.getRawValue(this.data.id);\n                if (!storedData) {\n                    return;\n                }\n                const commonActions = this._commonActions;\n                for (const [actionName, detail] of Object.entries(storedData)){\n                    const action = commonActions[actionName];\n                    if (action) {\n                        const eventProxy = {\n                            detail: {\n                                [actionName]: detail\n                            },\n                            target: element\n                        };\n                        action(eventProxy);\n                        delete storedData[actionName];\n                    }\n                }\n            }\n            _createQuadrilaterals() {\n                if (!this.container) {\n                    return;\n                }\n                const { quadPoints } = this.data;\n                if (!quadPoints) {\n                    return;\n                }\n                const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;\n                if (quadPoints.length === 1) {\n                    const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];\n                    if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                        return;\n                    }\n                }\n                const { style } = this.container;\n                let svgBuffer;\n                if (this.#hasBorder) {\n                    const { borderColor, borderWidth } = style;\n                    style.borderWidth = 0;\n                    svgBuffer = [\n                        \"url('data:image/svg+xml;utf8,\",\n                        `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                        ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                        `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n                    ];\n                    this.container.classList.add(\"hasBorder\");\n                }\n                const width = rectTrX - rectBlX;\n                const height = rectTrY - rectBlY;\n                const { svgFactory } = this;\n                const svg = svgFactory.createElement(\"svg\");\n                svg.classList.add(\"quadrilateralsContainer\");\n                svg.setAttribute(\"width\", 0);\n                svg.setAttribute(\"height\", 0);\n                const defs = svgFactory.createElement(\"defs\");\n                svg.append(defs);\n                const clipPath = svgFactory.createElement(\"clipPath\");\n                const id = `clippath_${this.data.id}`;\n                clipPath.setAttribute(\"id\", id);\n                clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n                defs.append(clipPath);\n                for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints){\n                    const rect = svgFactory.createElement(\"rect\");\n                    const x = (blX - rectBlX) / width;\n                    const y = (rectTrY - trY) / height;\n                    const rectWidth = (trX - blX) / width;\n                    const rectHeight = (trY - blY) / height;\n                    rect.setAttribute(\"x\", x);\n                    rect.setAttribute(\"y\", y);\n                    rect.setAttribute(\"width\", rectWidth);\n                    rect.setAttribute(\"height\", rectHeight);\n                    clipPath.append(rect);\n                    svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n                }\n                if (this.#hasBorder) {\n                    svgBuffer.push(`</g></svg>')`);\n                    style.backgroundImage = svgBuffer.join(\"\");\n                }\n                this.container.append(svg);\n                this.container.style.clipPath = `url(#${id})`;\n            }\n            _createPopup() {\n                const { container, data } = this;\n                container.setAttribute(\"aria-haspopup\", \"dialog\");\n                const popup = new PopupAnnotationElement({\n                    data: {\n                        color: data.color,\n                        titleObj: data.titleObj,\n                        modificationDate: data.modificationDate,\n                        contentsObj: data.contentsObj,\n                        richText: data.richText,\n                        parentRect: data.rect,\n                        borderStyle: 0,\n                        id: `popup_${data.id}`,\n                        rotation: data.rotation\n                    },\n                    parent: this.parent,\n                    elements: [\n                        this\n                    ]\n                });\n                this.parent.div.append(popup.render());\n            }\n            render() {\n                (0, util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n            }\n            _getElementsByName(name, skipId = null) {\n                const fields = [];\n                if (this._fieldObjects) {\n                    const fieldObj = this._fieldObjects[name];\n                    if (fieldObj) {\n                        for (const { page, id, exportValues } of fieldObj){\n                            if (page === -1) {\n                                continue;\n                            }\n                            if (id === skipId) {\n                                continue;\n                            }\n                            const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                            const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                            if (domElement && !GetElementsByNameSet.has(domElement)) {\n                                (0, util.warn)(`_getElementsByName - element not allowed: ${id}`);\n                                continue;\n                            }\n                            fields.push({\n                                id,\n                                exportValue,\n                                domElement\n                            });\n                        }\n                    }\n                    return fields;\n                }\n                for (const domElement of document.getElementsByName(name)){\n                    const { exportValue } = domElement;\n                    const id = domElement.getAttribute(\"data-element-id\");\n                    if (id === skipId) {\n                        continue;\n                    }\n                    if (!GetElementsByNameSet.has(domElement)) {\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n                return fields;\n            }\n            show() {\n                if (this.container) {\n                    this.container.hidden = false;\n                }\n                this.popup?.maybeShow();\n            }\n            hide() {\n                if (this.container) {\n                    this.container.hidden = true;\n                }\n                this.popup?.forceHide();\n            }\n            getElementsToTriggerPopup() {\n                return this.container;\n            }\n            addHighlightArea() {\n                const triggers = this.getElementsToTriggerPopup();\n                if (Array.isArray(triggers)) {\n                    for (const element of triggers){\n                        element.classList.add(\"highlightArea\");\n                    }\n                } else {\n                    triggers.classList.add(\"highlightArea\");\n                }\n            }\n            get _isEditable() {\n                return false;\n            }\n            _editOnDoubleClick() {\n                if (!this._isEditable) {\n                    return;\n                }\n                const { annotationEditorType: mode, data: { id: editId } } = this;\n                this.container.addEventListener(\"dblclick\", ()=>{\n                    this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                        source: this,\n                        mode,\n                        editId\n                    });\n                });\n            }\n        }\n        class LinkAnnotationElement extends AnnotationElement {\n            constructor(parameters, options = null){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: !!options?.ignoreBorder,\n                    createQuadrilaterals: true\n                });\n                this.isTooltipOnly = parameters.data.isTooltipOnly;\n            }\n            render() {\n                const { data, linkService } = this;\n                const link = document.createElement(\"a\");\n                link.setAttribute(\"data-element-id\", data.id);\n                let isBound = false;\n                if (data.url) {\n                    linkService.addLinkAttributes(link, data.url, data.newWindow);\n                    isBound = true;\n                } else if (data.action) {\n                    this._bindNamedAction(link, data.action);\n                    isBound = true;\n                } else if (data.attachment) {\n                    this.#bindAttachment(link, data.attachment, data.attachmentDest);\n                    isBound = true;\n                } else if (data.setOCGState) {\n                    this.#bindSetOCGState(link, data.setOCGState);\n                    isBound = true;\n                } else if (data.dest) {\n                    this._bindLink(link, data.dest);\n                    isBound = true;\n                } else {\n                    if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                        this._bindJSAction(link, data);\n                        isBound = true;\n                    }\n                    if (data.resetForm) {\n                        this._bindResetFormAction(link, data.resetForm);\n                        isBound = true;\n                    } else if (this.isTooltipOnly && !isBound) {\n                        this._bindLink(link, \"\");\n                        isBound = true;\n                    }\n                }\n                this.container.classList.add(\"linkAnnotation\");\n                if (isBound) {\n                    this.container.append(link);\n                }\n                return this.container;\n            }\n            #setInternalLink() {\n                this.container.setAttribute(\"data-internal-link\", \"\");\n            }\n            _bindLink(link, destination) {\n                link.href = this.linkService.getDestinationHash(destination);\n                link.onclick = ()=>{\n                    if (destination) {\n                        this.linkService.goToDestination(destination);\n                    }\n                    return false;\n                };\n                if (destination || destination === \"\") {\n                    this.#setInternalLink();\n                }\n            }\n            _bindNamedAction(link, action) {\n                link.href = this.linkService.getAnchorUrl(\"\");\n                link.onclick = ()=>{\n                    this.linkService.executeNamedAction(action);\n                    return false;\n                };\n                this.#setInternalLink();\n            }\n            #bindAttachment(link, attachment, dest = null) {\n                link.href = this.linkService.getAnchorUrl(\"\");\n                link.onclick = ()=>{\n                    this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n                    return false;\n                };\n                this.#setInternalLink();\n            }\n            #bindSetOCGState(link, action) {\n                link.href = this.linkService.getAnchorUrl(\"\");\n                link.onclick = ()=>{\n                    this.linkService.executeSetOCGState(action);\n                    return false;\n                };\n                this.#setInternalLink();\n            }\n            _bindJSAction(link, data) {\n                link.href = this.linkService.getAnchorUrl(\"\");\n                const map = new Map([\n                    [\n                        \"Action\",\n                        \"onclick\"\n                    ],\n                    [\n                        \"Mouse Up\",\n                        \"onmouseup\"\n                    ],\n                    [\n                        \"Mouse Down\",\n                        \"onmousedown\"\n                    ]\n                ]);\n                for (const name of Object.keys(data.actions)){\n                    const jsName = map.get(name);\n                    if (!jsName) {\n                        continue;\n                    }\n                    link[jsName] = ()=>{\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id: data.id,\n                                name\n                            }\n                        });\n                        return false;\n                    };\n                }\n                if (!link.onclick) {\n                    link.onclick = ()=>false;\n                }\n                this.#setInternalLink();\n            }\n            _bindResetFormAction(link, resetForm) {\n                const otherClickAction = link.onclick;\n                if (!otherClickAction) {\n                    link.href = this.linkService.getAnchorUrl(\"\");\n                }\n                this.#setInternalLink();\n                if (!this._fieldObjects) {\n                    (0, util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n                    if (!otherClickAction) {\n                        link.onclick = ()=>false;\n                    }\n                    return;\n                }\n                link.onclick = ()=>{\n                    otherClickAction?.();\n                    const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n                    const allFields = [];\n                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                        const fieldIds = new Set(resetFormRefs);\n                        for (const fieldName of resetFormFields){\n                            const fields = this._fieldObjects[fieldName] || [];\n                            for (const { id } of fields){\n                                fieldIds.add(id);\n                            }\n                        }\n                        for (const fields of Object.values(this._fieldObjects)){\n                            for (const field of fields){\n                                if (fieldIds.has(field.id) === include) {\n                                    allFields.push(field);\n                                }\n                            }\n                        }\n                    } else {\n                        for (const fields of Object.values(this._fieldObjects)){\n                            allFields.push(...fields);\n                        }\n                    }\n                    const storage = this.annotationStorage;\n                    const allIds = [];\n                    for (const field of allFields){\n                        const { id } = field;\n                        allIds.push(id);\n                        switch(field.type){\n                            case \"text\":\n                                {\n                                    const value = field.defaultValue || \"\";\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                    break;\n                                }\n                            case \"checkbox\":\n                            case \"radiobutton\":\n                                {\n                                    const value = field.defaultValue === field.exportValues;\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                    break;\n                                }\n                            case \"combobox\":\n                            case \"listbox\":\n                                {\n                                    const value = field.defaultValue || \"\";\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                    break;\n                                }\n                            default:\n                                continue;\n                        }\n                        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                        if (!domElement) {\n                            continue;\n                        } else if (!GetElementsByNameSet.has(domElement)) {\n                            (0, util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n                            continue;\n                        }\n                        domElement.dispatchEvent(new Event(\"resetform\"));\n                    }\n                    if (this.enableScripting) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id: \"app\",\n                                ids: allIds,\n                                name: \"ResetForm\"\n                            }\n                        });\n                    }\n                    return false;\n                };\n            }\n        }\n        class TextAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true\n                });\n            }\n            render() {\n                this.container.classList.add(\"textAnnotation\");\n                const image = document.createElement(\"img\");\n                image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n                image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n                image.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    type: this.data.name\n                }));\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this.container.append(image);\n                return this.container;\n            }\n        }\n        class WidgetAnnotationElement extends AnnotationElement {\n            render() {\n                if (this.data.alternativeText) {\n                    this.container.title = this.data.alternativeText;\n                }\n                return this.container;\n            }\n            showElementAndHideCanvas(element) {\n                if (this.data.hasOwnCanvas) {\n                    if (element.previousSibling?.nodeName === \"CANVAS\") {\n                        element.previousSibling.hidden = true;\n                    }\n                    element.hidden = false;\n                }\n            }\n            _getKeyModifier(event) {\n                return util.FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n            }\n            _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n                if (baseName.includes(\"mouse\")) {\n                    element.addEventListener(baseName, (event)=>{\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id: this.data.id,\n                                name: eventName,\n                                value: valueGetter(event),\n                                shift: event.shiftKey,\n                                modifier: this._getKeyModifier(event)\n                            }\n                        });\n                    });\n                } else {\n                    element.addEventListener(baseName, (event)=>{\n                        if (baseName === \"blur\") {\n                            if (!elementData.focused || !event.relatedTarget) {\n                                return;\n                            }\n                            elementData.focused = false;\n                        } else if (baseName === \"focus\") {\n                            if (elementData.focused) {\n                                return;\n                            }\n                            elementData.focused = true;\n                        }\n                        if (!valueGetter) {\n                            return;\n                        }\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id: this.data.id,\n                                name: eventName,\n                                value: valueGetter(event)\n                            }\n                        });\n                    });\n                }\n            }\n            _setEventListeners(element, elementData, names, getter) {\n                for (const [baseName, eventName] of names){\n                    if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                        if (eventName === \"Focus\" || eventName === \"Blur\") {\n                            elementData ||= {\n                                focused: false\n                            };\n                        }\n                        this._setEventListener(element, elementData, baseName, eventName, getter);\n                        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                            this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                            this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                        }\n                    }\n                }\n            }\n            _setBackgroundColor(element) {\n                const color = this.data.backgroundColor || null;\n                element.style.backgroundColor = color === null ? \"transparent\" : util.Util.makeHexColor(color[0], color[1], color[2]);\n            }\n            _setTextStyle(element) {\n                const TEXT_ALIGNMENT = [\n                    \"left\",\n                    \"center\",\n                    \"right\"\n                ];\n                const { fontColor } = this.data.defaultAppearanceData;\n                const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n                const style = element.style;\n                let computedFontSize;\n                const BORDER_SIZE = 2;\n                const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n                if (this.data.multiLine) {\n                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                    const numberOfLines = Math.round(height / (util.LINE_FACTOR * fontSize)) || 1;\n                    const lineHeight = height / numberOfLines;\n                    computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / util.LINE_FACTOR));\n                } else {\n                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                    computedFontSize = Math.min(fontSize, roundToOneDecimal(height / util.LINE_FACTOR));\n                }\n                style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n                style.color = util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n                if (this.data.textAlignment !== null) {\n                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n                }\n            }\n            _setRequired(element, isRequired) {\n                if (isRequired) {\n                    element.setAttribute(\"required\", true);\n                } else {\n                    element.removeAttribute(\"required\");\n                }\n                element.setAttribute(\"aria-required\", isRequired);\n            }\n        }\n        class TextWidgetAnnotationElement extends WidgetAnnotationElement {\n            constructor(parameters){\n                const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n                super(parameters, {\n                    isRenderable\n                });\n            }\n            setPropertyOnSiblings(base, key, value, keyInStorage) {\n                const storage = this.annotationStorage;\n                for (const element of this._getElementsByName(base.name, base.id)){\n                    if (element.domElement) {\n                        element.domElement[key] = value;\n                    }\n                    storage.setValue(element.id, {\n                        [keyInStorage]: value\n                    });\n                }\n            }\n            render() {\n                const storage = this.annotationStorage;\n                const id = this.data.id;\n                this.container.classList.add(\"textWidgetAnnotation\");\n                let element = null;\n                if (this.renderForms) {\n                    const storedData = storage.getValue(id, {\n                        value: this.data.fieldValue\n                    });\n                    let textContent = storedData.value || \"\";\n                    const maxLen = storage.getValue(id, {\n                        charLimit: this.data.maxLen\n                    }).charLimit;\n                    if (maxLen && textContent.length > maxLen) {\n                        textContent = textContent.slice(0, maxLen);\n                    }\n                    let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n                    if (fieldFormattedValues && this.data.comb) {\n                        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n                    }\n                    const elementData = {\n                        userValue: textContent,\n                        formattedValue: fieldFormattedValues,\n                        lastCommittedValue: null,\n                        commitKey: 1,\n                        focused: false\n                    };\n                    if (this.data.multiLine) {\n                        element = document.createElement(\"textarea\");\n                        element.textContent = fieldFormattedValues ?? textContent;\n                        if (this.data.doNotScroll) {\n                            element.style.overflowY = \"hidden\";\n                        }\n                    } else {\n                        element = document.createElement(\"input\");\n                        element.type = \"text\";\n                        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                        if (this.data.doNotScroll) {\n                            element.style.overflowX = \"hidden\";\n                        }\n                    }\n                    if (this.data.hasOwnCanvas) {\n                        element.hidden = true;\n                    }\n                    GetElementsByNameSet.add(element);\n                    element.setAttribute(\"data-element-id\", id);\n                    element.disabled = this.data.readOnly;\n                    element.name = this.data.fieldName;\n                    element.tabIndex = DEFAULT_TAB_INDEX;\n                    this._setRequired(element, this.data.required);\n                    if (maxLen) {\n                        element.maxLength = maxLen;\n                    }\n                    element.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                        elementData.formattedValue = null;\n                    });\n                    element.addEventListener(\"resetform\", (event)=>{\n                        const defaultValue = this.data.defaultFieldValue ?? \"\";\n                        element.value = elementData.userValue = defaultValue;\n                        elementData.formattedValue = null;\n                    });\n                    let blurListener = (event)=>{\n                        const { formattedValue } = elementData;\n                        if (formattedValue !== null && formattedValue !== undefined) {\n                            event.target.value = formattedValue;\n                        }\n                        event.target.scrollLeft = 0;\n                    };\n                    if (this.enableScripting && this.hasJSActions) {\n                        element.addEventListener(\"focus\", (event)=>{\n                            if (elementData.focused) {\n                                return;\n                            }\n                            const { target } = event;\n                            if (elementData.userValue) {\n                                target.value = elementData.userValue;\n                            }\n                            elementData.lastCommittedValue = target.value;\n                            elementData.commitKey = 1;\n                            if (!this.data.actions?.Focus) {\n                                elementData.focused = true;\n                            }\n                        });\n                        element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                            this.showElementAndHideCanvas(jsEvent.target);\n                            const actions = {\n                                value (event) {\n                                    elementData.userValue = event.detail.value ?? \"\";\n                                    storage.setValue(id, {\n                                        value: elementData.userValue.toString()\n                                    });\n                                    event.target.value = elementData.userValue;\n                                },\n                                formattedValue (event) {\n                                    const { formattedValue } = event.detail;\n                                    elementData.formattedValue = formattedValue;\n                                    if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                        event.target.value = formattedValue;\n                                    }\n                                    storage.setValue(id, {\n                                        formattedValue\n                                    });\n                                },\n                                selRange (event) {\n                                    event.target.setSelectionRange(...event.detail.selRange);\n                                },\n                                charLimit: (event)=>{\n                                    const { charLimit } = event.detail;\n                                    const { target } = event;\n                                    if (charLimit === 0) {\n                                        target.removeAttribute(\"maxLength\");\n                                        return;\n                                    }\n                                    target.setAttribute(\"maxLength\", charLimit);\n                                    let value = elementData.userValue;\n                                    if (!value || value.length <= charLimit) {\n                                        return;\n                                    }\n                                    value = value.slice(0, charLimit);\n                                    target.value = elementData.userValue = value;\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                        source: this,\n                                        detail: {\n                                            id,\n                                            name: \"Keystroke\",\n                                            value,\n                                            willCommit: true,\n                                            commitKey: 1,\n                                            selStart: target.selectionStart,\n                                            selEnd: target.selectionEnd\n                                        }\n                                    });\n                                }\n                            };\n                            this._dispatchEventFromSandbox(actions, jsEvent);\n                        });\n                        element.addEventListener(\"keydown\", (event)=>{\n                            elementData.commitKey = 1;\n                            let commitKey = -1;\n                            if (event.key === \"Escape\") {\n                                commitKey = 0;\n                            } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                                commitKey = 2;\n                            } else if (event.key === \"Tab\") {\n                                elementData.commitKey = 3;\n                            }\n                            if (commitKey === -1) {\n                                return;\n                            }\n                            const { value } = event.target;\n                            if (elementData.lastCommittedValue === value) {\n                                return;\n                            }\n                            elementData.lastCommittedValue = value;\n                            elementData.userValue = value;\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey,\n                                    selStart: event.target.selectionStart,\n                                    selEnd: event.target.selectionEnd\n                                }\n                            });\n                        });\n                        const _blurListener = blurListener;\n                        blurListener = null;\n                        element.addEventListener(\"blur\", (event)=>{\n                            if (!elementData.focused || !event.relatedTarget) {\n                                return;\n                            }\n                            if (!this.data.actions?.Blur) {\n                                elementData.focused = false;\n                            }\n                            const { value } = event.target;\n                            elementData.userValue = value;\n                            if (elementData.lastCommittedValue !== value) {\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id,\n                                        name: \"Keystroke\",\n                                        value,\n                                        willCommit: true,\n                                        commitKey: elementData.commitKey,\n                                        selStart: event.target.selectionStart,\n                                        selEnd: event.target.selectionEnd\n                                    }\n                                });\n                            }\n                            _blurListener(event);\n                        });\n                        if (this.data.actions?.Keystroke) {\n                            element.addEventListener(\"beforeinput\", (event)=>{\n                                elementData.lastCommittedValue = null;\n                                const { data, target } = event;\n                                const { value, selectionStart, selectionEnd } = target;\n                                let selStart = selectionStart, selEnd = selectionEnd;\n                                switch(event.inputType){\n                                    case \"deleteWordBackward\":\n                                        {\n                                            const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                            if (match) {\n                                                selStart -= match[0].length;\n                                            }\n                                            break;\n                                        }\n                                    case \"deleteWordForward\":\n                                        {\n                                            const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                            if (match) {\n                                                selEnd += match[0].length;\n                                            }\n                                            break;\n                                        }\n                                    case \"deleteContentBackward\":\n                                        if (selectionStart === selectionEnd) {\n                                            selStart -= 1;\n                                        }\n                                        break;\n                                    case \"deleteContentForward\":\n                                        if (selectionStart === selectionEnd) {\n                                            selEnd += 1;\n                                        }\n                                        break;\n                                }\n                                event.preventDefault();\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id,\n                                        name: \"Keystroke\",\n                                        value,\n                                        change: data || \"\",\n                                        willCommit: false,\n                                        selStart,\n                                        selEnd\n                                    }\n                                });\n                            });\n                        }\n                        this._setEventListeners(element, elementData, [\n                            [\n                                \"focus\",\n                                \"Focus\"\n                            ],\n                            [\n                                \"blur\",\n                                \"Blur\"\n                            ],\n                            [\n                                \"mousedown\",\n                                \"Mouse Down\"\n                            ],\n                            [\n                                \"mouseenter\",\n                                \"Mouse Enter\"\n                            ],\n                            [\n                                \"mouseleave\",\n                                \"Mouse Exit\"\n                            ],\n                            [\n                                \"mouseup\",\n                                \"Mouse Up\"\n                            ]\n                        ], (event)=>event.target.value);\n                    }\n                    if (blurListener) {\n                        element.addEventListener(\"blur\", blurListener);\n                    }\n                    if (this.data.comb) {\n                        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                        const combWidth = fieldWidth / maxLen;\n                        element.classList.add(\"comb\");\n                        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n                    }\n                } else {\n                    element = document.createElement(\"div\");\n                    element.textContent = this.data.fieldValue;\n                    element.style.verticalAlign = \"middle\";\n                    element.style.display = \"table-cell\";\n                    if (this.data.hasOwnCanvas) {\n                        element.hidden = true;\n                    }\n                }\n                this._setTextStyle(element);\n                this._setBackgroundColor(element);\n                this._setDefaultPropertiesFromJS(element);\n                this.container.append(element);\n                return this.container;\n            }\n        }\n        class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: !!parameters.data.hasOwnCanvas\n                });\n            }\n        }\n        class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: parameters.renderForms\n                });\n            }\n            render() {\n                const storage = this.annotationStorage;\n                const data = this.data;\n                const id = data.id;\n                let value = storage.getValue(id, {\n                    value: data.exportValue === data.fieldValue\n                }).value;\n                if (typeof value === \"string\") {\n                    value = value !== \"Off\";\n                    storage.setValue(id, {\n                        value\n                    });\n                }\n                this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n                const element = document.createElement(\"input\");\n                GetElementsByNameSet.add(element);\n                element.setAttribute(\"data-element-id\", id);\n                element.disabled = data.readOnly;\n                this._setRequired(element, this.data.required);\n                element.type = \"checkbox\";\n                element.name = data.fieldName;\n                if (value) {\n                    element.setAttribute(\"checked\", true);\n                }\n                element.setAttribute(\"exportValue\", data.exportValue);\n                element.tabIndex = DEFAULT_TAB_INDEX;\n                element.addEventListener(\"change\", (event)=>{\n                    const { name, checked } = event.target;\n                    for (const checkbox of this._getElementsByName(name, id)){\n                        const curChecked = checked && checkbox.exportValue === data.exportValue;\n                        if (checkbox.domElement) {\n                            checkbox.domElement.checked = curChecked;\n                        }\n                        storage.setValue(checkbox.id, {\n                            value: curChecked\n                        });\n                    }\n                    storage.setValue(id, {\n                        value: checked\n                    });\n                });\n                element.addEventListener(\"resetform\", (event)=>{\n                    const defaultValue = data.defaultFieldValue || \"Off\";\n                    event.target.checked = defaultValue === data.exportValue;\n                });\n                if (this.enableScripting && this.hasJSActions) {\n                    element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                        const actions = {\n                            value (event) {\n                                event.target.checked = event.detail.value !== \"Off\";\n                                storage.setValue(id, {\n                                    value: event.target.checked\n                                });\n                            }\n                        };\n                        this._dispatchEventFromSandbox(actions, jsEvent);\n                    });\n                    this._setEventListeners(element, null, [\n                        [\n                            \"change\",\n                            \"Validate\"\n                        ],\n                        [\n                            \"change\",\n                            \"Action\"\n                        ],\n                        [\n                            \"focus\",\n                            \"Focus\"\n                        ],\n                        [\n                            \"blur\",\n                            \"Blur\"\n                        ],\n                        [\n                            \"mousedown\",\n                            \"Mouse Down\"\n                        ],\n                        [\n                            \"mouseenter\",\n                            \"Mouse Enter\"\n                        ],\n                        [\n                            \"mouseleave\",\n                            \"Mouse Exit\"\n                        ],\n                        [\n                            \"mouseup\",\n                            \"Mouse Up\"\n                        ]\n                    ], (event)=>event.target.checked);\n                }\n                this._setBackgroundColor(element);\n                this._setDefaultPropertiesFromJS(element);\n                this.container.append(element);\n                return this.container;\n            }\n        }\n        class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: parameters.renderForms\n                });\n            }\n            render() {\n                this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n                const storage = this.annotationStorage;\n                const data = this.data;\n                const id = data.id;\n                let value = storage.getValue(id, {\n                    value: data.fieldValue === data.buttonValue\n                }).value;\n                if (typeof value === \"string\") {\n                    value = value !== data.buttonValue;\n                    storage.setValue(id, {\n                        value\n                    });\n                }\n                if (value) {\n                    for (const radio of this._getElementsByName(data.fieldName, id)){\n                        storage.setValue(radio.id, {\n                            value: false\n                        });\n                    }\n                }\n                const element = document.createElement(\"input\");\n                GetElementsByNameSet.add(element);\n                element.setAttribute(\"data-element-id\", id);\n                element.disabled = data.readOnly;\n                this._setRequired(element, this.data.required);\n                element.type = \"radio\";\n                element.name = data.fieldName;\n                if (value) {\n                    element.setAttribute(\"checked\", true);\n                }\n                element.tabIndex = DEFAULT_TAB_INDEX;\n                element.addEventListener(\"change\", (event)=>{\n                    const { name, checked } = event.target;\n                    for (const radio of this._getElementsByName(name, id)){\n                        storage.setValue(radio.id, {\n                            value: false\n                        });\n                    }\n                    storage.setValue(id, {\n                        value: checked\n                    });\n                });\n                element.addEventListener(\"resetform\", (event)=>{\n                    const defaultValue = data.defaultFieldValue;\n                    event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n                });\n                if (this.enableScripting && this.hasJSActions) {\n                    const pdfButtonValue = data.buttonValue;\n                    element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                        const actions = {\n                            value: (event)=>{\n                                const checked = pdfButtonValue === event.detail.value;\n                                for (const radio of this._getElementsByName(event.target.name)){\n                                    const curChecked = checked && radio.id === id;\n                                    if (radio.domElement) {\n                                        radio.domElement.checked = curChecked;\n                                    }\n                                    storage.setValue(radio.id, {\n                                        value: curChecked\n                                    });\n                                }\n                            }\n                        };\n                        this._dispatchEventFromSandbox(actions, jsEvent);\n                    });\n                    this._setEventListeners(element, null, [\n                        [\n                            \"change\",\n                            \"Validate\"\n                        ],\n                        [\n                            \"change\",\n                            \"Action\"\n                        ],\n                        [\n                            \"focus\",\n                            \"Focus\"\n                        ],\n                        [\n                            \"blur\",\n                            \"Blur\"\n                        ],\n                        [\n                            \"mousedown\",\n                            \"Mouse Down\"\n                        ],\n                        [\n                            \"mouseenter\",\n                            \"Mouse Enter\"\n                        ],\n                        [\n                            \"mouseleave\",\n                            \"Mouse Exit\"\n                        ],\n                        [\n                            \"mouseup\",\n                            \"Mouse Up\"\n                        ]\n                    ], (event)=>event.target.checked);\n                }\n                this._setBackgroundColor(element);\n                this._setDefaultPropertiesFromJS(element);\n                this.container.append(element);\n                return this.container;\n            }\n        }\n        class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    ignoreBorder: parameters.data.hasAppearance\n                });\n            }\n            render() {\n                const container = super.render();\n                container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n                if (this.data.alternativeText) {\n                    container.title = this.data.alternativeText;\n                }\n                const linkElement = container.lastChild;\n                if (this.enableScripting && this.hasJSActions && linkElement) {\n                    this._setDefaultPropertiesFromJS(linkElement);\n                    linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                        this._dispatchEventFromSandbox({}, jsEvent);\n                    });\n                }\n                return container;\n            }\n        }\n        class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: parameters.renderForms\n                });\n            }\n            render() {\n                this.container.classList.add(\"choiceWidgetAnnotation\");\n                const storage = this.annotationStorage;\n                const id = this.data.id;\n                const storedData = storage.getValue(id, {\n                    value: this.data.fieldValue\n                });\n                const selectElement = document.createElement(\"select\");\n                GetElementsByNameSet.add(selectElement);\n                selectElement.setAttribute(\"data-element-id\", id);\n                selectElement.disabled = this.data.readOnly;\n                this._setRequired(selectElement, this.data.required);\n                selectElement.name = this.data.fieldName;\n                selectElement.tabIndex = DEFAULT_TAB_INDEX;\n                let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n                if (!this.data.combo) {\n                    selectElement.size = this.data.options.length;\n                    if (this.data.multiSelect) {\n                        selectElement.multiple = true;\n                    }\n                }\n                selectElement.addEventListener(\"resetform\", (event)=>{\n                    const defaultValue = this.data.defaultFieldValue;\n                    for (const option of selectElement.options){\n                        option.selected = option.value === defaultValue;\n                    }\n                });\n                for (const option of this.data.options){\n                    const optionElement = document.createElement(\"option\");\n                    optionElement.textContent = option.displayValue;\n                    optionElement.value = option.exportValue;\n                    if (storedData.value.includes(option.exportValue)) {\n                        optionElement.setAttribute(\"selected\", true);\n                        addAnEmptyEntry = false;\n                    }\n                    selectElement.append(optionElement);\n                }\n                let removeEmptyEntry = null;\n                if (addAnEmptyEntry) {\n                    const noneOptionElement = document.createElement(\"option\");\n                    noneOptionElement.value = \" \";\n                    noneOptionElement.setAttribute(\"hidden\", true);\n                    noneOptionElement.setAttribute(\"selected\", true);\n                    selectElement.prepend(noneOptionElement);\n                    removeEmptyEntry = ()=>{\n                        noneOptionElement.remove();\n                        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                        removeEmptyEntry = null;\n                    };\n                    selectElement.addEventListener(\"input\", removeEmptyEntry);\n                }\n                const getValue = (isExport)=>{\n                    const name = isExport ? \"value\" : \"textContent\";\n                    const { options, multiple } = selectElement;\n                    if (!multiple) {\n                        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n                    }\n                    return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n                };\n                let selectedValues = getValue(false);\n                const getItems = (event)=>{\n                    const options = event.target.options;\n                    return Array.prototype.map.call(options, (option)=>{\n                        return {\n                            displayValue: option.textContent,\n                            exportValue: option.value\n                        };\n                    });\n                };\n                if (this.enableScripting && this.hasJSActions) {\n                    selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                        const actions = {\n                            value (event) {\n                                removeEmptyEntry?.();\n                                const value = event.detail.value;\n                                const values = new Set(Array.isArray(value) ? value : [\n                                    value\n                                ]);\n                                for (const option of selectElement.options){\n                                    option.selected = values.has(option.value);\n                                }\n                                storage.setValue(id, {\n                                    value: getValue(true)\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            multipleSelection (event) {\n                                selectElement.multiple = true;\n                            },\n                            remove (event) {\n                                const options = selectElement.options;\n                                const index = event.detail.remove;\n                                options[index].selected = false;\n                                selectElement.remove(index);\n                                if (options.length > 0) {\n                                    const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                                    if (i === -1) {\n                                        options[0].selected = true;\n                                    }\n                                }\n                                storage.setValue(id, {\n                                    value: getValue(true),\n                                    items: getItems(event)\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            clear (event) {\n                                while(selectElement.length !== 0){\n                                    selectElement.remove(0);\n                                }\n                                storage.setValue(id, {\n                                    value: null,\n                                    items: []\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            insert (event) {\n                                const { index, displayValue, exportValue } = event.detail.insert;\n                                const selectChild = selectElement.children[index];\n                                const optionElement = document.createElement(\"option\");\n                                optionElement.textContent = displayValue;\n                                optionElement.value = exportValue;\n                                if (selectChild) {\n                                    selectChild.before(optionElement);\n                                } else {\n                                    selectElement.append(optionElement);\n                                }\n                                storage.setValue(id, {\n                                    value: getValue(true),\n                                    items: getItems(event)\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            items (event) {\n                                const { items } = event.detail;\n                                while(selectElement.length !== 0){\n                                    selectElement.remove(0);\n                                }\n                                for (const item of items){\n                                    const { displayValue, exportValue } = item;\n                                    const optionElement = document.createElement(\"option\");\n                                    optionElement.textContent = displayValue;\n                                    optionElement.value = exportValue;\n                                    selectElement.append(optionElement);\n                                }\n                                if (selectElement.options.length > 0) {\n                                    selectElement.options[0].selected = true;\n                                }\n                                storage.setValue(id, {\n                                    value: getValue(true),\n                                    items: getItems(event)\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            indices (event) {\n                                const indices = new Set(event.detail.indices);\n                                for (const option of event.target.options){\n                                    option.selected = indices.has(option.index);\n                                }\n                                storage.setValue(id, {\n                                    value: getValue(true)\n                                });\n                                selectedValues = getValue(false);\n                            },\n                            editable (event) {\n                                event.target.disabled = !event.detail.editable;\n                            }\n                        };\n                        this._dispatchEventFromSandbox(actions, jsEvent);\n                    });\n                    selectElement.addEventListener(\"input\", (event)=>{\n                        const exportValue = getValue(true);\n                        storage.setValue(id, {\n                            value: exportValue\n                        });\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value: selectedValues,\n                                changeEx: exportValue,\n                                willCommit: false,\n                                commitKey: 1,\n                                keyDown: false\n                            }\n                        });\n                    });\n                    this._setEventListeners(selectElement, null, [\n                        [\n                            \"focus\",\n                            \"Focus\"\n                        ],\n                        [\n                            \"blur\",\n                            \"Blur\"\n                        ],\n                        [\n                            \"mousedown\",\n                            \"Mouse Down\"\n                        ],\n                        [\n                            \"mouseenter\",\n                            \"Mouse Enter\"\n                        ],\n                        [\n                            \"mouseleave\",\n                            \"Mouse Exit\"\n                        ],\n                        [\n                            \"mouseup\",\n                            \"Mouse Up\"\n                        ],\n                        [\n                            \"input\",\n                            \"Action\"\n                        ],\n                        [\n                            \"input\",\n                            \"Validate\"\n                        ]\n                    ], (event)=>event.target.value);\n                } else {\n                    selectElement.addEventListener(\"input\", function(event) {\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                    });\n                }\n                if (this.data.combo) {\n                    this._setTextStyle(selectElement);\n                } else {}\n                this._setBackgroundColor(selectElement);\n                this._setDefaultPropertiesFromJS(selectElement);\n                this.container.append(selectElement);\n                return this.container;\n            }\n        }\n        class PopupAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                const { data, elements } = parameters;\n                super(parameters, {\n                    isRenderable: AnnotationElement._hasPopupData(data)\n                });\n                this.elements = elements;\n            }\n            render() {\n                this.container.classList.add(\"popupAnnotation\");\n                const popup = new PopupElement({\n                    container: this.container,\n                    color: this.data.color,\n                    titleObj: this.data.titleObj,\n                    modificationDate: this.data.modificationDate,\n                    contentsObj: this.data.contentsObj,\n                    richText: this.data.richText,\n                    rect: this.data.rect,\n                    parentRect: this.data.parentRect || null,\n                    parent: this.parent,\n                    elements: this.elements,\n                    open: this.data.open\n                });\n                const elementIds = [];\n                for (const element of this.elements){\n                    element.popup = popup;\n                    elementIds.push(element.data.id);\n                    element.addHighlightArea();\n                }\n                this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${util.AnnotationPrefix}${id}`).join(\",\"));\n                return this.container;\n            }\n        }\n        class PopupElement {\n            #boundKeyDown;\n            #boundHide;\n            #boundShow;\n            #boundToggle;\n            #color;\n            #container;\n            #contentsObj;\n            #dateObj;\n            #elements;\n            #parent;\n            #parentRect;\n            #pinned;\n            #popup;\n            #rect;\n            #richText;\n            #titleObj;\n            #wasVisible;\n            constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n                this.#boundKeyDown = this.#keyDown.bind(this);\n                this.#boundHide = this.#hide.bind(this);\n                this.#boundShow = this.#show.bind(this);\n                this.#boundToggle = this.#toggle.bind(this);\n                this.#color = null;\n                this.#container = null;\n                this.#contentsObj = null;\n                this.#dateObj = null;\n                this.#elements = null;\n                this.#parent = null;\n                this.#parentRect = null;\n                this.#pinned = false;\n                this.#popup = null;\n                this.#rect = null;\n                this.#richText = null;\n                this.#titleObj = null;\n                this.#wasVisible = false;\n                this.#container = container;\n                this.#titleObj = titleObj;\n                this.#contentsObj = contentsObj;\n                this.#richText = richText;\n                this.#parent = parent;\n                this.#color = color;\n                this.#rect = rect;\n                this.#parentRect = parentRect;\n                this.#elements = elements;\n                this.#dateObj = display_utils.PDFDateString.toDateObject(modificationDate);\n                this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n                for (const element of this.trigger){\n                    element.addEventListener(\"click\", this.#boundToggle);\n                    element.addEventListener(\"mouseenter\", this.#boundShow);\n                    element.addEventListener(\"mouseleave\", this.#boundHide);\n                    element.classList.add(\"popupTriggerArea\");\n                }\n                for (const element of elements){\n                    element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n                }\n                this.#container.hidden = true;\n                if (open) {\n                    this.#toggle();\n                }\n            }\n            render() {\n                if (this.#popup) {\n                    return;\n                }\n                const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n                const popup = this.#popup = document.createElement(\"div\");\n                popup.className = \"popup\";\n                if (this.#color) {\n                    const baseColor = popup.style.outlineColor = util.Util.makeHexColor(...this.#color);\n                    if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n                    } else {\n                        const BACKGROUND_ENLIGHT = 0.7;\n                        popup.style.backgroundColor = util.Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n                    }\n                }\n                const header = document.createElement(\"span\");\n                header.className = \"header\";\n                const title = document.createElement(\"h1\");\n                header.append(title);\n                ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n                popup.append(header);\n                if (this.#dateObj) {\n                    const modificationDate = document.createElement(\"span\");\n                    modificationDate.classList.add(\"popupDate\");\n                    modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-string\");\n                    modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                        date: this.#dateObj.toLocaleDateString(),\n                        time: this.#dateObj.toLocaleTimeString()\n                    }));\n                    header.append(modificationDate);\n                }\n                const contentsObj = this.#contentsObj;\n                const richText = this.#richText;\n                if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n                    xfa_layer.XfaLayer.render({\n                        xfaHtml: richText.html,\n                        intent: \"richText\",\n                        div: popup\n                    });\n                    popup.lastChild.classList.add(\"richText\", \"popupContent\");\n                } else {\n                    const contents = this._formatContents(contentsObj);\n                    popup.append(contents);\n                }\n                let useParentRect = !!this.#parentRect;\n                let rect = useParentRect ? this.#parentRect : this.#rect;\n                for (const element of this.#elements){\n                    if (!rect || util.Util.intersect(element.data.rect, rect) !== null) {\n                        rect = element.data.rect;\n                        useParentRect = true;\n                        break;\n                    }\n                }\n                const normalizedRect = util.Util.normalizeRect([\n                    rect[0],\n                    view[3] - rect[1] + view[1],\n                    rect[2],\n                    view[3] - rect[3] + view[1]\n                ]);\n                const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n                const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n                const popupLeft = normalizedRect[0] + parentWidth;\n                const popupTop = normalizedRect[1];\n                const { style } = this.#container;\n                style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;\n                style.top = `${100 * (popupTop - pageY) / pageHeight}%`;\n                this.#container.append(popup);\n            }\n            _formatContents({ str, dir }) {\n                const p = document.createElement(\"p\");\n                p.classList.add(\"popupContent\");\n                p.dir = dir;\n                const lines = str.split(/(?:\\r\\n?|\\n)/);\n                for(let i = 0, ii = lines.length; i < ii; ++i){\n                    const line = lines[i];\n                    p.append(document.createTextNode(line));\n                    if (i < ii - 1) {\n                        p.append(document.createElement(\"br\"));\n                    }\n                }\n                return p;\n            }\n            #keyDown(event) {\n                if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n                    return;\n                }\n                if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n                    this.#toggle();\n                }\n            }\n            #toggle() {\n                this.#pinned = !this.#pinned;\n                if (this.#pinned) {\n                    this.#show();\n                    this.#container.addEventListener(\"click\", this.#boundToggle);\n                    this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n                } else {\n                    this.#hide();\n                    this.#container.removeEventListener(\"click\", this.#boundToggle);\n                    this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n                }\n            }\n            #show() {\n                if (!this.#popup) {\n                    this.render();\n                }\n                if (!this.isVisible) {\n                    this.#container.hidden = false;\n                    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n                } else if (this.#pinned) {\n                    this.#container.classList.add(\"focused\");\n                }\n            }\n            #hide() {\n                this.#container.classList.remove(\"focused\");\n                if (this.#pinned || !this.isVisible) {\n                    return;\n                }\n                this.#container.hidden = true;\n                this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n            }\n            forceHide() {\n                this.#wasVisible = this.isVisible;\n                if (!this.#wasVisible) {\n                    return;\n                }\n                this.#container.hidden = true;\n            }\n            maybeShow() {\n                if (!this.#wasVisible) {\n                    return;\n                }\n                this.#wasVisible = false;\n                this.#container.hidden = false;\n            }\n            get isVisible() {\n                return this.#container.hidden === false;\n            }\n        }\n        class FreeTextAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.textContent = parameters.data.textContent;\n                this.textPosition = parameters.data.textPosition;\n                this.annotationEditorType = util.AnnotationEditorType.FREETEXT;\n            }\n            render() {\n                this.container.classList.add(\"freeTextAnnotation\");\n                if (this.textContent) {\n                    const content = document.createElement(\"div\");\n                    content.classList.add(\"annotationTextContent\");\n                    content.setAttribute(\"role\", \"comment\");\n                    for (const line of this.textContent){\n                        const lineSpan = document.createElement(\"span\");\n                        lineSpan.textContent = line;\n                        content.append(lineSpan);\n                    }\n                    this.container.append(content);\n                }\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this._editOnDoubleClick();\n                return this.container;\n            }\n            get _isEditable() {\n                return this.data.hasOwnCanvas;\n            }\n        }\n        class LineAnnotationElement extends AnnotationElement {\n            #line;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.#line = null;\n            }\n            render() {\n                this.container.classList.add(\"lineAnnotation\");\n                const data = this.data;\n                const { width, height } = getRectDims(data.rect);\n                const svg = this.svgFactory.create(width, height, true);\n                const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n                line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n                line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n                line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n                line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n                line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                line.setAttribute(\"stroke\", \"transparent\");\n                line.setAttribute(\"fill\", \"transparent\");\n                svg.append(line);\n                this.container.append(svg);\n                if (!data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#line;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n        }\n        class SquareAnnotationElement extends AnnotationElement {\n            #square;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.#square = null;\n            }\n            render() {\n                this.container.classList.add(\"squareAnnotation\");\n                const data = this.data;\n                const { width, height } = getRectDims(data.rect);\n                const svg = this.svgFactory.create(width, height, true);\n                const borderWidth = data.borderStyle.width;\n                const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n                square.setAttribute(\"x\", borderWidth / 2);\n                square.setAttribute(\"y\", borderWidth / 2);\n                square.setAttribute(\"width\", width - borderWidth);\n                square.setAttribute(\"height\", height - borderWidth);\n                square.setAttribute(\"stroke-width\", borderWidth || 1);\n                square.setAttribute(\"stroke\", \"transparent\");\n                square.setAttribute(\"fill\", \"transparent\");\n                svg.append(square);\n                this.container.append(svg);\n                if (!data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#square;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n        }\n        class CircleAnnotationElement extends AnnotationElement {\n            #circle;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.#circle = null;\n            }\n            render() {\n                this.container.classList.add(\"circleAnnotation\");\n                const data = this.data;\n                const { width, height } = getRectDims(data.rect);\n                const svg = this.svgFactory.create(width, height, true);\n                const borderWidth = data.borderStyle.width;\n                const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n                circle.setAttribute(\"cx\", width / 2);\n                circle.setAttribute(\"cy\", height / 2);\n                circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n                circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n                circle.setAttribute(\"stroke-width\", borderWidth || 1);\n                circle.setAttribute(\"stroke\", \"transparent\");\n                circle.setAttribute(\"fill\", \"transparent\");\n                svg.append(circle);\n                this.container.append(svg);\n                if (!data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#circle;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n        }\n        class PolylineAnnotationElement extends AnnotationElement {\n            #polyline;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.#polyline = null;\n                this.containerClassName = \"polylineAnnotation\";\n                this.svgElementName = \"svg:polyline\";\n            }\n            render() {\n                this.container.classList.add(this.containerClassName);\n                const data = this.data;\n                const { width, height } = getRectDims(data.rect);\n                const svg = this.svgFactory.create(width, height, true);\n                let points = [];\n                for (const coordinate of data.vertices){\n                    const x = coordinate.x - data.rect[0];\n                    const y = data.rect[3] - coordinate.y;\n                    points.push(x + \",\" + y);\n                }\n                points = points.join(\" \");\n                const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n                polyline.setAttribute(\"points\", points);\n                polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                polyline.setAttribute(\"stroke\", \"transparent\");\n                polyline.setAttribute(\"fill\", \"transparent\");\n                svg.append(polyline);\n                this.container.append(svg);\n                if (!data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#polyline;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n        }\n        class PolygonAnnotationElement extends PolylineAnnotationElement {\n            constructor(parameters){\n                super(parameters);\n                this.containerClassName = \"polygonAnnotation\";\n                this.svgElementName = \"svg:polygon\";\n            }\n        }\n        class CaretAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n            }\n            render() {\n                this.container.classList.add(\"caretAnnotation\");\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n        }\n        class InkAnnotationElement extends AnnotationElement {\n            #polylines;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n                this.#polylines = [];\n                this.containerClassName = \"inkAnnotation\";\n                this.svgElementName = \"svg:polyline\";\n                this.annotationEditorType = util.AnnotationEditorType.INK;\n            }\n            render() {\n                this.container.classList.add(this.containerClassName);\n                const data = this.data;\n                const { width, height } = getRectDims(data.rect);\n                const svg = this.svgFactory.create(width, height, true);\n                for (const inkList of data.inkLists){\n                    let points = [];\n                    for (const coordinate of inkList){\n                        const x = coordinate.x - data.rect[0];\n                        const y = data.rect[3] - coordinate.y;\n                        points.push(`${x},${y}`);\n                    }\n                    points = points.join(\" \");\n                    const polyline = this.svgFactory.createElement(this.svgElementName);\n                    this.#polylines.push(polyline);\n                    polyline.setAttribute(\"points\", points);\n                    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                    polyline.setAttribute(\"stroke\", \"transparent\");\n                    polyline.setAttribute(\"fill\", \"transparent\");\n                    if (!data.popupRef && this.hasPopupData) {\n                        this._createPopup();\n                    }\n                    svg.append(polyline);\n                }\n                this.container.append(svg);\n                return this.container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#polylines;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n        }\n        class HighlightAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true,\n                    createQuadrilaterals: true\n                });\n            }\n            render() {\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this.container.classList.add(\"highlightAnnotation\");\n                return this.container;\n            }\n        }\n        class UnderlineAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true,\n                    createQuadrilaterals: true\n                });\n            }\n            render() {\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this.container.classList.add(\"underlineAnnotation\");\n                return this.container;\n            }\n        }\n        class SquigglyAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true,\n                    createQuadrilaterals: true\n                });\n            }\n            render() {\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this.container.classList.add(\"squigglyAnnotation\");\n                return this.container;\n            }\n        }\n        class StrikeOutAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true,\n                    createQuadrilaterals: true\n                });\n            }\n            render() {\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                this.container.classList.add(\"strikeoutAnnotation\");\n                return this.container;\n            }\n        }\n        class StampAnnotationElement extends AnnotationElement {\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true,\n                    ignoreBorder: true\n                });\n            }\n            render() {\n                this.container.classList.add(\"stampAnnotation\");\n                if (!this.data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                }\n                return this.container;\n            }\n        }\n        class FileAttachmentAnnotationElement extends AnnotationElement {\n            #trigger;\n            constructor(parameters){\n                super(parameters, {\n                    isRenderable: true\n                });\n                this.#trigger = null;\n                const { filename, content } = this.data.file;\n                this.filename = (0, display_utils.getFilenameFromUrl)(filename, true);\n                this.content = content;\n                this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n                    source: this,\n                    filename,\n                    content\n                });\n            }\n            render() {\n                this.container.classList.add(\"fileAttachmentAnnotation\");\n                const { container, data } = this;\n                let trigger;\n                if (data.hasAppearance || data.fillAlpha === 0) {\n                    trigger = document.createElement(\"div\");\n                } else {\n                    trigger = document.createElement(\"img\");\n                    trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n                    if (data.fillAlpha && data.fillAlpha < 1) {\n                        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n                    }\n                }\n                trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n                this.#trigger = trigger;\n                const { isMac } = util.FeatureTest.platform;\n                container.addEventListener(\"keydown\", (evt)=>{\n                    if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                        this.#download();\n                    }\n                });\n                if (!data.popupRef && this.hasPopupData) {\n                    this._createPopup();\n                } else {\n                    trigger.classList.add(\"popupTriggerArea\");\n                }\n                container.append(trigger);\n                return container;\n            }\n            getElementsToTriggerPopup() {\n                return this.#trigger;\n            }\n            addHighlightArea() {\n                this.container.classList.add(\"highlightArea\");\n            }\n            #download() {\n                this.downloadManager?.openOrDownloadData(this.content, this.filename);\n            }\n        }\n        class AnnotationLayer {\n            #accessibilityManager;\n            #annotationCanvasMap;\n            #editableAnnotations;\n            constructor({ div, accessibilityManager, annotationCanvasMap, page, viewport }){\n                this.#accessibilityManager = null;\n                this.#annotationCanvasMap = null;\n                this.#editableAnnotations = new Map();\n                this.div = div;\n                this.#accessibilityManager = accessibilityManager;\n                this.#annotationCanvasMap = annotationCanvasMap;\n                this.page = page;\n                this.viewport = viewport;\n                this.zIndex = 0;\n            }\n            #appendElement(element, id) {\n                const contentElement = element.firstChild || element;\n                contentElement.id = `${util.AnnotationPrefix}${id}`;\n                this.div.append(element);\n                this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n            }\n            async render(params) {\n                const { annotations } = params;\n                const layer = this.div;\n                (0, display_utils.setLayerDimensions)(layer, this.viewport);\n                const popupToElements = new Map();\n                const elementParams = {\n                    data: null,\n                    layer,\n                    linkService: params.linkService,\n                    downloadManager: params.downloadManager,\n                    imageResourcesPath: params.imageResourcesPath || \"\",\n                    renderForms: params.renderForms !== false,\n                    svgFactory: new display_utils.DOMSVGFactory(),\n                    annotationStorage: params.annotationStorage || new annotation_storage.AnnotationStorage(),\n                    enableScripting: params.enableScripting === true,\n                    hasJSActions: params.hasJSActions,\n                    fieldObjects: params.fieldObjects,\n                    parent: this,\n                    elements: null\n                };\n                for (const data of annotations){\n                    if (data.noHTML) {\n                        continue;\n                    }\n                    const isPopupAnnotation = data.annotationType === util.AnnotationType.POPUP;\n                    if (!isPopupAnnotation) {\n                        const { width, height } = getRectDims(data.rect);\n                        if (width <= 0 || height <= 0) {\n                            continue;\n                        }\n                    } else {\n                        const elements = popupToElements.get(data.id);\n                        if (!elements) {\n                            continue;\n                        }\n                        elementParams.elements = elements;\n                    }\n                    elementParams.data = data;\n                    const element = AnnotationElementFactory.create(elementParams);\n                    if (!element.isRenderable) {\n                        continue;\n                    }\n                    if (!isPopupAnnotation && data.popupRef) {\n                        const elements = popupToElements.get(data.popupRef);\n                        if (!elements) {\n                            popupToElements.set(data.popupRef, [\n                                element\n                            ]);\n                        } else {\n                            elements.push(element);\n                        }\n                    }\n                    if (element.annotationEditorType > 0) {\n                        this.#editableAnnotations.set(element.data.id, element);\n                    }\n                    const rendered = element.render();\n                    if (data.hidden) {\n                        rendered.style.visibility = \"hidden\";\n                    }\n                    this.#appendElement(rendered, data.id);\n                }\n                this.#setAnnotationCanvasMap();\n            }\n            update({ viewport }) {\n                const layer = this.div;\n                this.viewport = viewport;\n                (0, display_utils.setLayerDimensions)(layer, {\n                    rotation: viewport.rotation\n                });\n                this.#setAnnotationCanvasMap();\n                layer.hidden = false;\n            }\n            #setAnnotationCanvasMap() {\n                if (!this.#annotationCanvasMap) {\n                    return;\n                }\n                const layer = this.div;\n                for (const [id, canvas] of this.#annotationCanvasMap){\n                    const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n                    if (!element) {\n                        continue;\n                    }\n                    const { firstChild } = element;\n                    if (!firstChild) {\n                        element.append(canvas);\n                    } else if (firstChild.nodeName === \"CANVAS\") {\n                        firstChild.replaceWith(canvas);\n                    } else {\n                        firstChild.before(canvas);\n                    }\n                }\n                this.#annotationCanvasMap.clear();\n            }\n            getEditableAnnotations() {\n                return Array.from(this.#editableAnnotations.values());\n            }\n            getEditableAnnotation(id) {\n                return this.#editableAnnotations.get(id);\n            }\n        }\n    /***/ },\n    /***/ 780: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_116517__)=>{\n        /* harmony export */ __nested_webpack_require_116517__.d(__nested_webpack_exports__, {\n            /* harmony export */ AnnotationStorage: ()=>/* binding */ AnnotationStorage,\n            /* harmony export */ PrintAnnotationStorage: ()=>/* binding */ PrintAnnotationStorage,\n            /* harmony export */ SerializableEmpty: ()=>/* binding */ SerializableEmpty\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_116517__(266);\n        /* harmony import */ var _editor_editor_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_116517__(115);\n        /* harmony import */ var _shared_murmurhash3_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_116517__(825);\n        const SerializableEmpty = Object.freeze({\n            map: null,\n            hash: \"\",\n            transfer: undefined\n        });\n        class AnnotationStorage {\n            #modified;\n            #storage;\n            constructor(){\n                this.#modified = false;\n                this.#storage = new Map();\n                this.onSetModified = null;\n                this.onResetModified = null;\n                this.onAnnotationEditor = null;\n            }\n            getValue(key, defaultValue) {\n                const value = this.#storage.get(key);\n                if (value === undefined) {\n                    return defaultValue;\n                }\n                return Object.assign(defaultValue, value);\n            }\n            getRawValue(key) {\n                return this.#storage.get(key);\n            }\n            remove(key) {\n                this.#storage.delete(key);\n                if (this.#storage.size === 0) {\n                    this.resetModified();\n                }\n                if (typeof this.onAnnotationEditor === \"function\") {\n                    for (const value of this.#storage.values()){\n                        if (value instanceof _editor_editor_js__WEBPACK_IMPORTED_MODULE_1__.AnnotationEditor) {\n                            return;\n                        }\n                    }\n                    this.onAnnotationEditor(null);\n                }\n            }\n            setValue(key, value) {\n                const obj = this.#storage.get(key);\n                let modified = false;\n                if (obj !== undefined) {\n                    for (const [entry, val] of Object.entries(value)){\n                        if (obj[entry] !== val) {\n                            modified = true;\n                            obj[entry] = val;\n                        }\n                    }\n                } else {\n                    modified = true;\n                    this.#storage.set(key, value);\n                }\n                if (modified) {\n                    this.#setModified();\n                }\n                if (value instanceof _editor_editor_js__WEBPACK_IMPORTED_MODULE_1__.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n                    this.onAnnotationEditor(value.constructor._type);\n                }\n            }\n            has(key) {\n                return this.#storage.has(key);\n            }\n            getAll() {\n                return this.#storage.size > 0 ? (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.objectFromMap)(this.#storage) : null;\n            }\n            setAll(obj) {\n                for (const [key, val] of Object.entries(obj)){\n                    this.setValue(key, val);\n                }\n            }\n            get size() {\n                return this.#storage.size;\n            }\n            #setModified() {\n                if (!this.#modified) {\n                    this.#modified = true;\n                    if (typeof this.onSetModified === \"function\") {\n                        this.onSetModified();\n                    }\n                }\n            }\n            resetModified() {\n                if (this.#modified) {\n                    this.#modified = false;\n                    if (typeof this.onResetModified === \"function\") {\n                        this.onResetModified();\n                    }\n                }\n            }\n            get print() {\n                return new PrintAnnotationStorage(this);\n            }\n            get serializable() {\n                if (this.#storage.size === 0) {\n                    return SerializableEmpty;\n                }\n                const map = new Map(), hash = new _shared_murmurhash3_js__WEBPACK_IMPORTED_MODULE_2__.MurmurHash3_64(), transfer = [];\n                const context = Object.create(null);\n                let hasBitmap = false;\n                for (const [key, val] of this.#storage){\n                    const serialized = val instanceof _editor_editor_js__WEBPACK_IMPORTED_MODULE_1__.AnnotationEditor ? val.serialize(false, context) : val;\n                    if (serialized) {\n                        map.set(key, serialized);\n                        hash.update(`${key}:${JSON.stringify(serialized)}`);\n                        hasBitmap ||= !!serialized.bitmap;\n                    }\n                }\n                if (hasBitmap) {\n                    for (const value of map.values()){\n                        if (value.bitmap) {\n                            transfer.push(value.bitmap);\n                        }\n                    }\n                }\n                return map.size > 0 ? {\n                    map,\n                    hash: hash.hexdigest(),\n                    transfer\n                } : SerializableEmpty;\n            }\n        }\n        class PrintAnnotationStorage extends AnnotationStorage {\n            #serializable;\n            constructor(parent){\n                super();\n                const { map, hash, transfer } = parent.serializable;\n                const clone = structuredClone(map, transfer ? {\n                    transfer\n                } : null);\n                this.#serializable = {\n                    map: clone,\n                    hash,\n                    transfer\n                };\n            }\n            get print() {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n            }\n            get serializable() {\n                return this.#serializable;\n            }\n        }\n    /***/ },\n    /***/ 406: /***/ (__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_122875__)=>{\n        __nested_webpack_require_122875__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__)=>{\n            try {\n                /* harmony export */ __nested_webpack_require_122875__.d(__nested_webpack_exports__, {\n                    /* harmony export */ PDFDataRangeTransport: ()=>/* binding */ PDFDataRangeTransport,\n                    /* harmony export */ PDFWorker: ()=>/* binding */ PDFWorker,\n                    /* harmony export */ build: ()=>/* binding */ build,\n                    /* harmony export */ getDocument: ()=>/* binding */ getDocument,\n                    /* harmony export */ version: ()=>/* binding */ version\n                });\n                /* unused harmony exports DefaultCanvasFactory, DefaultCMapReaderFactory, DefaultFilterFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorkerUtil, RenderTask */ /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_122875__(266);\n                /* harmony import */ var _annotation_storage_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_122875__(780);\n                /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_122875__(473);\n                /* harmony import */ var _font_loader_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_122875__(742);\n                /* harmony import */ var display_node_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_122875__(738);\n                /* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_122875__(250);\n                /* harmony import */ var _worker_options_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_122875__(368);\n                /* harmony import */ var _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_122875__(694);\n                /* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_122875__(472);\n                /* harmony import */ var _optional_content_config_js__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_122875__(890);\n                /* harmony import */ var _transport_stream_js__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_122875__(92);\n                /* harmony import */ var display_fetch_stream__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_122875__(171);\n                /* harmony import */ var display_network__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_122875__(474);\n                /* harmony import */ var display_node_stream__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_122875__(498);\n                /* harmony import */ var _xfa_text_js__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_122875__(521);\n                var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([\n                    display_node_utils__WEBPACK_IMPORTED_MODULE_4__,\n                    display_node_stream__WEBPACK_IMPORTED_MODULE_13__\n                ]);\n                [display_node_utils__WEBPACK_IMPORTED_MODULE_4__, display_node_stream__WEBPACK_IMPORTED_MODULE_13__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__;\n                const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n                const RENDERING_CANCELLED_TIMEOUT = 100;\n                const DELAYED_CLEANUP_TIMEOUT = 5000;\n                const DefaultCanvasFactory = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS ? display_node_utils__WEBPACK_IMPORTED_MODULE_4__.NodeCanvasFactory : _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMCanvasFactory;\n                const DefaultCMapReaderFactory = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS ? display_node_utils__WEBPACK_IMPORTED_MODULE_4__.NodeCMapReaderFactory : _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMCMapReaderFactory;\n                const DefaultFilterFactory = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS ? display_node_utils__WEBPACK_IMPORTED_MODULE_4__.NodeFilterFactory : _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMFilterFactory;\n                const DefaultStandardFontDataFactory = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS ? display_node_utils__WEBPACK_IMPORTED_MODULE_4__.NodeStandardFontDataFactory : _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMStandardFontDataFactory;\n                function getDocument(src) {\n                    if (typeof src === \"string\" || src instanceof URL) {\n                        src = {\n                            url: src\n                        };\n                    } else if ((0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayBuffer)(src)) {\n                        src = {\n                            data: src\n                        };\n                    }\n                    if (typeof src !== \"object\") {\n                        throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n                    }\n                    if (!src.url && !src.data && !src.range) {\n                        throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n                    }\n                    const task = new PDFDocumentLoadingTask();\n                    const { docId } = task;\n                    const url = src.url ? getUrlProp(src.url) : null;\n                    const data = src.data ? getDataProp(src.data) : null;\n                    const httpHeaders = src.httpHeaders || null;\n                    const withCredentials = src.withCredentials === true;\n                    const password = src.password ?? null;\n                    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n                    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n                    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n                    const verbosity = src.verbosity;\n                    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n                    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n                    const cMapPacked = src.cMapPacked !== false;\n                    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n                    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n                    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n                    const ignoreErrors = src.stopAtErrors !== true;\n                    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n                    const isEvalSupported = src.isEvalSupported !== false;\n                    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS;\n                    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n                    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS;\n                    const fontExtraProperties = src.fontExtraProperties === true;\n                    const enableXfa = src.enableXfa === true;\n                    const ownerDocument = src.ownerDocument || globalThis.document;\n                    const disableRange = src.disableRange === true;\n                    const disableStream = src.disableStream === true;\n                    const disableAutoFetch = src.disableAutoFetch === true;\n                    const pdfBug = src.pdfBug === true;\n                    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n                    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS && !disableFontFace;\n                    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n                    const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n                        ownerDocument\n                    });\n                    const filterFactory = src.filterFactory || new DefaultFilterFactory({\n                        docId,\n                        ownerDocument\n                    });\n                    const styleElement = null;\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.setVerbosityLevel)(verbosity);\n                    const transportFactory = {\n                        canvasFactory,\n                        filterFactory\n                    };\n                    if (!useWorkerFetch) {\n                        transportFactory.cMapReaderFactory = new CMapReaderFactory({\n                            baseUrl: cMapUrl,\n                            isCompressed: cMapPacked\n                        });\n                        transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n                            baseUrl: standardFontDataUrl\n                        });\n                    }\n                    if (!worker) {\n                        const workerParams = {\n                            verbosity,\n                            port: _worker_options_js__WEBPACK_IMPORTED_MODULE_6__.GlobalWorkerOptions.workerPort\n                        };\n                        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n                        task._worker = worker;\n                    }\n                    const fetchDocParams = {\n                        docId,\n                        apiVersion: \"4.0.379\",\n                        data,\n                        password,\n                        disableAutoFetch,\n                        rangeChunkSize,\n                        length,\n                        docBaseUrl,\n                        enableXfa,\n                        evaluatorOptions: {\n                            maxImageSize,\n                            disableFontFace,\n                            ignoreErrors,\n                            isEvalSupported,\n                            isOffscreenCanvasSupported,\n                            canvasMaxAreaInBytes,\n                            fontExtraProperties,\n                            useSystemFonts,\n                            cMapUrl: useWorkerFetch ? cMapUrl : null,\n                            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n                        }\n                    };\n                    const transportParams = {\n                        ignoreErrors,\n                        isEvalSupported,\n                        disableFontFace,\n                        fontExtraProperties,\n                        enableXfa,\n                        ownerDocument,\n                        disableAutoFetch,\n                        pdfBug,\n                        styleElement\n                    };\n                    worker.promise.then(function() {\n                        if (task.destroyed) {\n                            throw new Error(\"Loading aborted\");\n                        }\n                        const workerIdPromise = _fetchDocument(worker, fetchDocParams);\n                        const networkStreamPromise = new Promise(function(resolve) {\n                            let networkStream;\n                            if (rangeTransport) {\n                                networkStream = new _transport_stream_js__WEBPACK_IMPORTED_MODULE_10__.PDFDataTransportStream({\n                                    length,\n                                    initialData: rangeTransport.initialData,\n                                    progressiveDone: rangeTransport.progressiveDone,\n                                    contentDispositionFilename: rangeTransport.contentDispositionFilename,\n                                    disableRange,\n                                    disableStream\n                                }, rangeTransport);\n                            } else if (!data) {\n                                const createPDFNetworkStream = (params)=>{\n                                    if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS) {\n                                        return new display_node_stream__WEBPACK_IMPORTED_MODULE_13__.PDFNodeStream(params);\n                                    }\n                                    return (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isValidFetchUrl)(params.url) ? new display_fetch_stream__WEBPACK_IMPORTED_MODULE_11__.PDFFetchStream(params) : new display_network__WEBPACK_IMPORTED_MODULE_12__.PDFNetworkStream(params);\n                                };\n                                networkStream = createPDFNetworkStream({\n                                    url,\n                                    length,\n                                    httpHeaders,\n                                    withCredentials,\n                                    rangeChunkSize,\n                                    disableRange,\n                                    disableStream\n                                });\n                            }\n                            resolve(networkStream);\n                        });\n                        return Promise.all([\n                            workerIdPromise,\n                            networkStreamPromise\n                        ]).then(function([workerId, networkStream]) {\n                            if (task.destroyed) {\n                                throw new Error(\"Loading aborted\");\n                            }\n                            const messageHandler = new _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__.MessageHandler(docId, workerId, worker.port);\n                            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n                            task._transport = transport;\n                            messageHandler.send(\"Ready\", null);\n                        });\n                    }).catch(task._capability.reject);\n                    return task;\n                }\n                async function _fetchDocument(worker, source) {\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [\n                        source.data.buffer\n                    ] : null);\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    return workerId;\n                }\n                function getUrlProp(val) {\n                    if (val instanceof URL) {\n                        return val.href;\n                    }\n                    try {\n                        return new URL(val, window.location).href;\n                    } catch  {\n                        if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS && typeof val === \"string\") {\n                            return val;\n                        }\n                    }\n                    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n                }\n                function getDataProp(val) {\n                    if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n                        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n                    }\n                    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n                        return val;\n                    }\n                    if (typeof val === \"string\") {\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(val);\n                    }\n                    if (typeof val === \"object\" && !isNaN(val?.length) || (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayBuffer)(val)) {\n                        return new Uint8Array(val);\n                    }\n                    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n                }\n                class PDFDocumentLoadingTask {\n                    static #docId = 0;\n                    constructor(){\n                        this._capability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this._transport = null;\n                        this._worker = null;\n                        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n                        this.destroyed = false;\n                        this.onPassword = null;\n                        this.onProgress = null;\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    async destroy() {\n                        this.destroyed = true;\n                        try {\n                            if (this._worker?.port) {\n                                this._worker._pendingDestroy = true;\n                            }\n                            await this._transport?.destroy();\n                        } catch (ex) {\n                            if (this._worker?.port) {\n                                delete this._worker._pendingDestroy;\n                            }\n                            throw ex;\n                        }\n                        this._transport = null;\n                        if (this._worker) {\n                            this._worker.destroy();\n                            this._worker = null;\n                        }\n                    }\n                }\n                class PDFDataRangeTransport {\n                    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n                        this.length = length;\n                        this.initialData = initialData;\n                        this.progressiveDone = progressiveDone;\n                        this.contentDispositionFilename = contentDispositionFilename;\n                        this._rangeListeners = [];\n                        this._progressListeners = [];\n                        this._progressiveReadListeners = [];\n                        this._progressiveDoneListeners = [];\n                        this._readyCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                    }\n                    addRangeListener(listener) {\n                        this._rangeListeners.push(listener);\n                    }\n                    addProgressListener(listener) {\n                        this._progressListeners.push(listener);\n                    }\n                    addProgressiveReadListener(listener) {\n                        this._progressiveReadListeners.push(listener);\n                    }\n                    addProgressiveDoneListener(listener) {\n                        this._progressiveDoneListeners.push(listener);\n                    }\n                    onDataRange(begin, chunk) {\n                        for (const listener of this._rangeListeners){\n                            listener(begin, chunk);\n                        }\n                    }\n                    onDataProgress(loaded, total) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressListeners){\n                                listener(loaded, total);\n                            }\n                        });\n                    }\n                    onDataProgressiveRead(chunk) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveReadListeners){\n                                listener(chunk);\n                            }\n                        });\n                    }\n                    onDataProgressiveDone() {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveDoneListeners){\n                                listener();\n                            }\n                        });\n                    }\n                    transportReady() {\n                        this._readyCapability.resolve();\n                    }\n                    requestDataRange(begin, end) {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n                    }\n                    abort() {}\n                }\n                class PDFDocumentProxy {\n                    constructor(pdfInfo, transport){\n                        this._pdfInfo = pdfInfo;\n                        this._transport = transport;\n                    }\n                    get annotationStorage() {\n                        return this._transport.annotationStorage;\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get numPages() {\n                        return this._pdfInfo.numPages;\n                    }\n                    get fingerprints() {\n                        return this._pdfInfo.fingerprints;\n                    }\n                    get isPureXfa() {\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    get allXfaHtml() {\n                        return this._transport._htmlForXfa;\n                    }\n                    getPage(pageNumber) {\n                        return this._transport.getPage(pageNumber);\n                    }\n                    getPageIndex(ref) {\n                        return this._transport.getPageIndex(ref);\n                    }\n                    getDestinations() {\n                        return this._transport.getDestinations();\n                    }\n                    getDestination(id) {\n                        return this._transport.getDestination(id);\n                    }\n                    getPageLabels() {\n                        return this._transport.getPageLabels();\n                    }\n                    getPageLayout() {\n                        return this._transport.getPageLayout();\n                    }\n                    getPageMode() {\n                        return this._transport.getPageMode();\n                    }\n                    getViewerPreferences() {\n                        return this._transport.getViewerPreferences();\n                    }\n                    getOpenAction() {\n                        return this._transport.getOpenAction();\n                    }\n                    getAttachments() {\n                        return this._transport.getAttachments();\n                    }\n                    getJSActions() {\n                        return this._transport.getDocJSActions();\n                    }\n                    getOutline() {\n                        return this._transport.getOutline();\n                    }\n                    getOptionalContentConfig() {\n                        return this._transport.getOptionalContentConfig();\n                    }\n                    getPermissions() {\n                        return this._transport.getPermissions();\n                    }\n                    getMetadata() {\n                        return this._transport.getMetadata();\n                    }\n                    getMarkInfo() {\n                        return this._transport.getMarkInfo();\n                    }\n                    getData() {\n                        return this._transport.getData();\n                    }\n                    saveDocument() {\n                        return this._transport.saveDocument();\n                    }\n                    getDownloadInfo() {\n                        return this._transport.downloadInfoCapability.promise;\n                    }\n                    cleanup(keepLoadedFonts = false) {\n                        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n                    }\n                    destroy() {\n                        return this.loadingTask.destroy();\n                    }\n                    get loadingParams() {\n                        return this._transport.loadingParams;\n                    }\n                    get loadingTask() {\n                        return this._transport.loadingTask;\n                    }\n                    getFieldObjects() {\n                        return this._transport.getFieldObjects();\n                    }\n                    hasJSActions() {\n                        return this._transport.hasJSActions();\n                    }\n                    getCalculationOrderIds() {\n                        return this._transport.getCalculationOrderIds();\n                    }\n                }\n                class PDFPageProxy {\n                    #delayedCleanupTimeout;\n                    #pendingCleanup;\n                    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n                        this.#delayedCleanupTimeout = null;\n                        this.#pendingCleanup = false;\n                        this._pageIndex = pageIndex;\n                        this._pageInfo = pageInfo;\n                        this._transport = transport;\n                        this._stats = pdfBug ? new _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.StatTimer() : null;\n                        this._pdfBug = pdfBug;\n                        this.commonObjs = transport.commonObjs;\n                        this.objs = new PDFObjects();\n                        this._maybeCleanupAfterRender = false;\n                        this._intentStates = new Map();\n                        this.destroyed = false;\n                    }\n                    get pageNumber() {\n                        return this._pageIndex + 1;\n                    }\n                    get rotate() {\n                        return this._pageInfo.rotate;\n                    }\n                    get ref() {\n                        return this._pageInfo.ref;\n                    }\n                    get userUnit() {\n                        return this._pageInfo.userUnit;\n                    }\n                    get view() {\n                        return this._pageInfo.view;\n                    }\n                    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n                        return new _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.PageViewport({\n                            viewBox: this.view,\n                            scale,\n                            rotation,\n                            offsetX,\n                            offsetY,\n                            dontFlip\n                        });\n                    }\n                    getAnnotations({ intent = \"display\" } = {}) {\n                        const intentArgs = this._transport.getRenderingIntent(intent);\n                        return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n                    }\n                    getJSActions() {\n                        return this._transport.getPageJSActions(this._pageIndex);\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get isPureXfa() {\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    async getXfa() {\n                        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n                    }\n                    render({ canvasContext, viewport, intent = \"display\", annotationMode = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null }) {\n                        this._stats?.time(\"Overall\");\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        if (!optionalContentConfigPromise) {\n                            optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n                        }\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        const intentPrint = !!(intentArgs.renderingIntent & _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.PRINT);\n                        if (!intentState.displayReadyCapability) {\n                            intentState.displayReadyCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        const complete = (error)=>{\n                            intentState.renderTasks.delete(internalRenderTask);\n                            if (this._maybeCleanupAfterRender || intentPrint) {\n                                this.#pendingCleanup = true;\n                            }\n                            this.#tryCleanup(!intentPrint);\n                            if (error) {\n                                internalRenderTask.capability.reject(error);\n                                this._abortOperatorList({\n                                    intentState,\n                                    reason: error instanceof Error ? error : new Error(error)\n                                });\n                            } else {\n                                internalRenderTask.capability.resolve();\n                            }\n                            this._stats?.timeEnd(\"Rendering\");\n                            this._stats?.timeEnd(\"Overall\");\n                        };\n                        const internalRenderTask = new InternalRenderTask({\n                            callback: complete,\n                            params: {\n                                canvasContext,\n                                viewport,\n                                transform,\n                                background\n                            },\n                            objs: this.objs,\n                            commonObjs: this.commonObjs,\n                            annotationCanvasMap,\n                            operatorList: intentState.operatorList,\n                            pageIndex: this._pageIndex,\n                            canvasFactory: this._transport.canvasFactory,\n                            filterFactory: this._transport.filterFactory,\n                            useRequestAnimationFrame: !intentPrint,\n                            pdfBug: this._pdfBug,\n                            pageColors\n                        });\n                        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n                        const renderTask = internalRenderTask.task;\n                        Promise.all([\n                            intentState.displayReadyCapability.promise,\n                            optionalContentConfigPromise\n                        ]).then(([transparency, optionalContentConfig])=>{\n                            if (this.destroyed) {\n                                complete();\n                                return;\n                            }\n                            this._stats?.time(\"Rendering\");\n                            internalRenderTask.initializeGraphics({\n                                transparency,\n                                optionalContentConfig\n                            });\n                            internalRenderTask.operatorListChanged();\n                        }).catch(complete);\n                        return renderTask;\n                    }\n                    getOperatorList({ intent = \"display\", annotationMode = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE, printAnnotationStorage = null } = {}) {\n                        function operatorListChanged() {\n                            if (intentState.operatorList.lastChunk) {\n                                intentState.opListReadCapability.resolve(intentState.operatorList);\n                                intentState.renderTasks.delete(opListTask);\n                            }\n                        }\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        let opListTask;\n                        if (!intentState.opListReadCapability) {\n                            opListTask = Object.create(null);\n                            opListTask.operatorListChanged = operatorListChanged;\n                            intentState.opListReadCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            (intentState.renderTasks ||= new Set()).add(opListTask);\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        return intentState.opListReadCapability.promise;\n                    }\n                    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n                        const TEXT_CONTENT_CHUNK_SIZE = 100;\n                        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n                            pageIndex: this._pageIndex,\n                            includeMarkedContent: includeMarkedContent === true,\n                            disableNormalization: disableNormalization === true\n                        }, {\n                            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n                            size (textContent) {\n                                return textContent.items.length;\n                            }\n                        });\n                    }\n                    getTextContent(params = {}) {\n                        if (this._transport._htmlForXfa) {\n                            return this.getXfa().then((xfa)=>{\n                                return _xfa_text_js__WEBPACK_IMPORTED_MODULE_14__.XfaText.textContent(xfa);\n                            });\n                        }\n                        const readableStream = this.streamTextContent(params);\n                        return new Promise(function(resolve, reject) {\n                            function pump() {\n                                reader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        resolve(textContent);\n                                        return;\n                                    }\n                                    Object.assign(textContent.styles, value.styles);\n                                    textContent.items.push(...value.items);\n                                    pump();\n                                }, reject);\n                            }\n                            const reader = readableStream.getReader();\n                            const textContent = {\n                                items: [],\n                                styles: Object.create(null)\n                            };\n                            pump();\n                        });\n                    }\n                    getStructTree() {\n                        return this._transport.getStructTree(this._pageIndex);\n                    }\n                    _destroy() {\n                        this.destroyed = true;\n                        const waitOn = [];\n                        for (const intentState of this._intentStates.values()){\n                            this._abortOperatorList({\n                                intentState,\n                                reason: new Error(\"Page was destroyed.\"),\n                                force: true\n                            });\n                            if (intentState.opListReadCapability) {\n                                continue;\n                            }\n                            for (const internalRenderTask of intentState.renderTasks){\n                                waitOn.push(internalRenderTask.completed);\n                                internalRenderTask.cancel();\n                            }\n                        }\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        return Promise.all(waitOn);\n                    }\n                    cleanup(resetStats = false) {\n                        this.#pendingCleanup = true;\n                        const success = this.#tryCleanup(false);\n                        if (resetStats && success) {\n                            this._stats &&= new _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.StatTimer();\n                        }\n                        return success;\n                    }\n                    #tryCleanup(delayed = false) {\n                        this.#abortDelayedCleanup();\n                        if (!this.#pendingCleanup || this.destroyed) {\n                            return false;\n                        }\n                        if (delayed) {\n                            this.#delayedCleanupTimeout = setTimeout(()=>{\n                                this.#delayedCleanupTimeout = null;\n                                this.#tryCleanup(false);\n                            }, DELAYED_CLEANUP_TIMEOUT);\n                            return false;\n                        }\n                        for (const { renderTasks, operatorList } of this._intentStates.values()){\n                            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                                return false;\n                            }\n                        }\n                        this._intentStates.clear();\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        return true;\n                    }\n                    #abortDelayedCleanup() {\n                        if (this.#delayedCleanupTimeout) {\n                            clearTimeout(this.#delayedCleanupTimeout);\n                            this.#delayedCleanupTimeout = null;\n                        }\n                    }\n                    _startRenderPage(transparency, cacheKey) {\n                        const intentState = this._intentStates.get(cacheKey);\n                        if (!intentState) {\n                            return;\n                        }\n                        this._stats?.timeEnd(\"Page Request\");\n                        intentState.displayReadyCapability?.resolve(transparency);\n                    }\n                    _renderPageChunk(operatorListChunk, intentState) {\n                        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n                            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n                            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n                        }\n                        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n                        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n                        for (const internalRenderTask of intentState.renderTasks){\n                            internalRenderTask.operatorListChanged();\n                        }\n                        if (operatorListChunk.lastChunk) {\n                            this.#tryCleanup(true);\n                        }\n                    }\n                    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable }) {\n                        const { map, transfer } = annotationStorageSerializable;\n                        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n                            pageIndex: this._pageIndex,\n                            intent: renderingIntent,\n                            cacheKey,\n                            annotationStorage: map\n                        }, transfer);\n                        const reader = readableStream.getReader();\n                        const intentState = this._intentStates.get(cacheKey);\n                        intentState.streamReader = reader;\n                        const pump = ()=>{\n                            reader.read().then(({ value, done })=>{\n                                if (done) {\n                                    intentState.streamReader = null;\n                                    return;\n                                }\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                this._renderPageChunk(value, intentState);\n                                pump();\n                            }, (reason)=>{\n                                intentState.streamReader = null;\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                if (intentState.operatorList) {\n                                    intentState.operatorList.lastChunk = true;\n                                    for (const internalRenderTask of intentState.renderTasks){\n                                        internalRenderTask.operatorListChanged();\n                                    }\n                                    this.#tryCleanup(true);\n                                }\n                                if (intentState.displayReadyCapability) {\n                                    intentState.displayReadyCapability.reject(reason);\n                                } else if (intentState.opListReadCapability) {\n                                    intentState.opListReadCapability.reject(reason);\n                                } else {\n                                    throw reason;\n                                }\n                            });\n                        };\n                        pump();\n                    }\n                    _abortOperatorList({ intentState, reason, force = false }) {\n                        if (!intentState.streamReader) {\n                            return;\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        if (!force) {\n                            if (intentState.renderTasks.size > 0) {\n                                return;\n                            }\n                            if (reason instanceof _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.RenderingCancelledException) {\n                                let delay = RENDERING_CANCELLED_TIMEOUT;\n                                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                                    delay += reason.extraDelay;\n                                }\n                                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                                    intentState.streamReaderCancelTimeout = null;\n                                    this._abortOperatorList({\n                                        intentState,\n                                        reason,\n                                        force: true\n                                    });\n                                }, delay);\n                                return;\n                            }\n                        }\n                        intentState.streamReader.cancel(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(reason.message)).catch(()=>{});\n                        intentState.streamReader = null;\n                        if (this._transport.destroyed) {\n                            return;\n                        }\n                        for (const [curCacheKey, curIntentState] of this._intentStates){\n                            if (curIntentState === intentState) {\n                                this._intentStates.delete(curCacheKey);\n                                break;\n                            }\n                        }\n                        this.cleanup();\n                    }\n                    get stats() {\n                        return this._stats;\n                    }\n                }\n                class LoopbackPort {\n                    #listeners;\n                    #deferred;\n                    postMessage(obj, transfer) {\n                        const event = {\n                            data: structuredClone(obj, transfer ? {\n                                transfer\n                            } : null)\n                        };\n                        this.#deferred.then(()=>{\n                            for (const listener of this.#listeners){\n                                listener.call(this, event);\n                            }\n                        });\n                    }\n                    addEventListener(name, listener) {\n                        this.#listeners.add(listener);\n                    }\n                    removeEventListener(name, listener) {\n                        this.#listeners.delete(listener);\n                    }\n                    terminate() {\n                        this.#listeners.clear();\n                    }\n                    constructor(){\n                        this.#listeners = new Set();\n                        this.#deferred = Promise.resolve();\n                    }\n                }\n                const PDFWorkerUtil = {\n                    isWorkerDisabled: false,\n                    fakeWorkerId: 0\n                };\n                {\n                    if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS) {\n                        PDFWorkerUtil.isWorkerDisabled = true;\n                        _worker_options_js__WEBPACK_IMPORTED_MODULE_6__.GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n                    }\n                    PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {\n                        let base;\n                        try {\n                            base = new URL(baseUrl);\n                            if (!base.origin || base.origin === \"null\") {\n                                return false;\n                            }\n                        } catch  {\n                            return false;\n                        }\n                        const other = new URL(otherUrl, base);\n                        return base.origin === other.origin;\n                    };\n                    PDFWorkerUtil.createCDNWrapper = function(url) {\n                        const wrapper = `await import(\"${url}\");`;\n                        return URL.createObjectURL(new Blob([\n                            wrapper\n                        ], {\n                            type: \"text/javascript\"\n                        }));\n                    };\n                }\n                class PDFWorker {\n                    static #workerPorts;\n                    constructor({ name = null, port = null, verbosity = (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.getVerbosityLevel)() } = {}){\n                        this.name = name;\n                        this.destroyed = false;\n                        this.verbosity = verbosity;\n                        this._readyCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this._port = null;\n                        this._webWorker = null;\n                        this._messageHandler = null;\n                        if (port) {\n                            if (PDFWorker.#workerPorts?.has(port)) {\n                                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n                            }\n                            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n                            this._initializeFromPort(port);\n                            return;\n                        }\n                        this._initialize();\n                    }\n                    get promise() {\n                        return this._readyCapability.promise;\n                    }\n                    get port() {\n                        return this._port;\n                    }\n                    get messageHandler() {\n                        return this._messageHandler;\n                    }\n                    _initializeFromPort(port) {\n                        this._port = port;\n                        this._messageHandler = new _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__.MessageHandler(\"main\", \"worker\", port);\n                        this._messageHandler.on(\"ready\", function() {});\n                        this._readyCapability.resolve();\n                        this._messageHandler.send(\"configure\", {\n                            verbosity: this.verbosity\n                        });\n                    }\n                    _initialize() {\n                        if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker.#mainThreadWorkerMessageHandler) {\n                            let { workerSrc } = PDFWorker;\n                            try {\n                                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n                                    workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n                                }\n                                const worker = new Worker(workerSrc, {\n                                    type: \"module\"\n                                });\n                                const messageHandler = new _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__.MessageHandler(\"main\", \"worker\", worker);\n                                const terminateEarly = ()=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    messageHandler.destroy();\n                                    worker.terminate();\n                                    if (this.destroyed) {\n                                        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                    } else {\n                                        this._setupFakeWorker();\n                                    }\n                                };\n                                const onWorkerError = ()=>{\n                                    if (!this._webWorker) {\n                                        terminateEarly();\n                                    }\n                                };\n                                worker.addEventListener(\"error\", onWorkerError);\n                                messageHandler.on(\"test\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    if (data) {\n                                        this._messageHandler = messageHandler;\n                                        this._port = worker;\n                                        this._webWorker = worker;\n                                        this._readyCapability.resolve();\n                                        messageHandler.send(\"configure\", {\n                                            verbosity: this.verbosity\n                                        });\n                                    } else {\n                                        this._setupFakeWorker();\n                                        messageHandler.destroy();\n                                        worker.terminate();\n                                    }\n                                });\n                                messageHandler.on(\"ready\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    try {\n                                        sendTest();\n                                    } catch  {\n                                        this._setupFakeWorker();\n                                    }\n                                });\n                                const sendTest = ()=>{\n                                    const testObj = new Uint8Array();\n                                    messageHandler.send(\"test\", testObj, [\n                                        testObj.buffer\n                                    ]);\n                                };\n                                sendTest();\n                                return;\n                            } catch  {\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.info)(\"The worker has been disabled.\");\n                            }\n                        }\n                        this._setupFakeWorker();\n                    }\n                    _setupFakeWorker() {\n                        if (!PDFWorkerUtil.isWorkerDisabled) {\n                            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(\"Setting up fake worker.\");\n                            PDFWorkerUtil.isWorkerDisabled = true;\n                        }\n                        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n                            if (this.destroyed) {\n                                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                return;\n                            }\n                            const port = new LoopbackPort();\n                            this._port = port;\n                            const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n                            const workerHandler = new _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__.MessageHandler(id + \"_worker\", id, port);\n                            WorkerMessageHandler.setup(workerHandler, port);\n                            const messageHandler = new _shared_message_handler_js__WEBPACK_IMPORTED_MODULE_7__.MessageHandler(id, id + \"_worker\", port);\n                            this._messageHandler = messageHandler;\n                            this._readyCapability.resolve();\n                            messageHandler.send(\"configure\", {\n                                verbosity: this.verbosity\n                            });\n                        }).catch((reason)=>{\n                            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n                        });\n                    }\n                    destroy() {\n                        this.destroyed = true;\n                        if (this._webWorker) {\n                            this._webWorker.terminate();\n                            this._webWorker = null;\n                        }\n                        PDFWorker.#workerPorts?.delete(this._port);\n                        this._port = null;\n                        if (this._messageHandler) {\n                            this._messageHandler.destroy();\n                            this._messageHandler = null;\n                        }\n                    }\n                    static fromPort(params) {\n                        if (!params?.port) {\n                            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n                        }\n                        const cachedPort = this.#workerPorts?.get(params.port);\n                        if (cachedPort) {\n                            if (cachedPort._pendingDestroy) {\n                                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n                            }\n                            return cachedPort;\n                        }\n                        return new PDFWorker(params);\n                    }\n                    static get workerSrc() {\n                        if (_worker_options_js__WEBPACK_IMPORTED_MODULE_6__.GlobalWorkerOptions.workerSrc) {\n                            return _worker_options_js__WEBPACK_IMPORTED_MODULE_6__.GlobalWorkerOptions.workerSrc;\n                        }\n                        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                    }\n                    static get #mainThreadWorkerMessageHandler() {\n                        try {\n                            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n                        } catch  {\n                            return null;\n                        }\n                    }\n                    static get _setupFakeWorkerGlobal() {\n                        const loader = async ()=>{\n                            if (this.#mainThreadWorkerMessageHandler) {\n                                return this.#mainThreadWorkerMessageHandler;\n                            }\n                            const worker = await import(/* webpackIgnore: true */ this.workerSrc);\n                            return worker.WorkerMessageHandler;\n                        };\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n                    }\n                }\n                class WorkerTransport {\n                    #methodPromises;\n                    #pageCache;\n                    #pagePromises;\n                    #passwordCapability;\n                    constructor(messageHandler, loadingTask, networkStream, params, factory){\n                        this.#methodPromises = new Map();\n                        this.#pageCache = new Map();\n                        this.#pagePromises = new Map();\n                        this.#passwordCapability = null;\n                        this.messageHandler = messageHandler;\n                        this.loadingTask = loadingTask;\n                        this.commonObjs = new PDFObjects();\n                        this.fontLoader = new _font_loader_js__WEBPACK_IMPORTED_MODULE_3__.FontLoader({\n                            ownerDocument: params.ownerDocument,\n                            styleElement: params.styleElement\n                        });\n                        this._params = params;\n                        this.canvasFactory = factory.canvasFactory;\n                        this.filterFactory = factory.filterFactory;\n                        this.cMapReaderFactory = factory.cMapReaderFactory;\n                        this.standardFontDataFactory = factory.standardFontDataFactory;\n                        this.destroyed = false;\n                        this.destroyCapability = null;\n                        this._networkStream = networkStream;\n                        this._fullReader = null;\n                        this._lastProgress = null;\n                        this.downloadInfoCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.setupMessageHandler();\n                    }\n                    #cacheSimpleMethod(name, data = null) {\n                        const cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, data);\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    get annotationStorage() {\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"annotationStorage\", new _annotation_storage_js__WEBPACK_IMPORTED_MODULE_1__.AnnotationStorage());\n                    }\n                    getRenderingIntent(intent, annotationMode = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n                        let renderingIntent = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.DISPLAY;\n                        let annotationStorageSerializable = _annotation_storage_js__WEBPACK_IMPORTED_MODULE_1__.SerializableEmpty;\n                        switch(intent){\n                            case \"any\":\n                                renderingIntent = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.ANY;\n                                break;\n                            case \"display\":\n                                break;\n                            case \"print\":\n                                renderingIntent = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.PRINT;\n                                break;\n                            default:\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n                        }\n                        switch(annotationMode){\n                            case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.DISABLE:\n                                renderingIntent += _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                                break;\n                            case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE:\n                                break;\n                            case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE_FORMS:\n                                renderingIntent += _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.ANNOTATIONS_FORMS;\n                                break;\n                            case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode.ENABLE_STORAGE:\n                                renderingIntent += _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                                const annotationStorage = renderingIntent & _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage_js__WEBPACK_IMPORTED_MODULE_1__.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n                                annotationStorageSerializable = annotationStorage.serializable;\n                                break;\n                            default:\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n                        }\n                        if (isOpList) {\n                            renderingIntent += _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.RenderingIntentFlag.OPLIST;\n                        }\n                        return {\n                            renderingIntent,\n                            cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,\n                            annotationStorageSerializable\n                        };\n                    }\n                    destroy() {\n                        if (this.destroyCapability) {\n                            return this.destroyCapability.promise;\n                        }\n                        this.destroyed = true;\n                        this.destroyCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n                        const waitOn = [];\n                        for (const page of this.#pageCache.values()){\n                            waitOn.push(page._destroy());\n                        }\n                        this.#pageCache.clear();\n                        this.#pagePromises.clear();\n                        if (this.hasOwnProperty(\"annotationStorage\")) {\n                            this.annotationStorage.resetModified();\n                        }\n                        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n                        waitOn.push(terminated);\n                        Promise.all(waitOn).then(()=>{\n                            this.commonObjs.clear();\n                            this.fontLoader.clear();\n                            this.#methodPromises.clear();\n                            this.filterFactory.destroy();\n                            this._networkStream?.cancelAllRequests(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(\"Worker was terminated.\"));\n                            if (this.messageHandler) {\n                                this.messageHandler.destroy();\n                                this.messageHandler = null;\n                            }\n                            this.destroyCapability.resolve();\n                        }, this.destroyCapability.reject);\n                        return this.destroyCapability.promise;\n                    }\n                    setupMessageHandler() {\n                        const { messageHandler, loadingTask } = this;\n                        messageHandler.on(\"GetReader\", (data, sink)=>{\n                            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n                            this._fullReader = this._networkStream.getFullReader();\n                            this._fullReader.onProgress = (evt)=>{\n                                this._lastProgress = {\n                                    loaded: evt.loaded,\n                                    total: evt.total\n                                };\n                            };\n                            sink.onPull = ()=>{\n                                this._fullReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                this._fullReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"ReaderHeadersReady\", (data)=>{\n                            const headersCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            const fullReader = this._fullReader;\n                            fullReader.headersReady.then(()=>{\n                                if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n                                    if (this._lastProgress) {\n                                        loadingTask.onProgress?.(this._lastProgress);\n                                    }\n                                    fullReader.onProgress = (evt)=>{\n                                        loadingTask.onProgress?.({\n                                            loaded: evt.loaded,\n                                            total: evt.total\n                                        });\n                                    };\n                                }\n                                headersCapability.resolve({\n                                    isStreamingSupported: fullReader.isStreamingSupported,\n                                    isRangeSupported: fullReader.isRangeSupported,\n                                    contentLength: fullReader.contentLength\n                                });\n                            }, headersCapability.reject);\n                            return headersCapability.promise;\n                        });\n                        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n                            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n                            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n                            if (!rangeReader) {\n                                sink.close();\n                                return;\n                            }\n                            sink.onPull = ()=>{\n                                rangeReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                rangeReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n                            this._numPages = pdfInfo.numPages;\n                            this._htmlForXfa = pdfInfo.htmlForXfa;\n                            delete pdfInfo.htmlForXfa;\n                            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n                        });\n                        messageHandler.on(\"DocException\", function(ex) {\n                            let reason;\n                            switch(ex.name){\n                                case \"PasswordException\":\n                                    reason = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PasswordException(ex.message, ex.code);\n                                    break;\n                                case \"InvalidPDFException\":\n                                    reason = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.InvalidPDFException(ex.message);\n                                    break;\n                                case \"MissingPDFException\":\n                                    reason = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException(ex.message);\n                                    break;\n                                case \"UnexpectedResponseException\":\n                                    reason = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.UnexpectedResponseException(ex.message, ex.status);\n                                    break;\n                                case \"UnknownErrorException\":\n                                    reason = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.UnknownErrorException(ex.message, ex.details);\n                                    break;\n                                default:\n                                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"DocException - expected a valid Error.\");\n                            }\n                            loadingTask._capability.reject(reason);\n                        });\n                        messageHandler.on(\"PasswordRequest\", (exception)=>{\n                            this.#passwordCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            if (loadingTask.onPassword) {\n                                const updatePassword = (password)=>{\n                                    if (password instanceof Error) {\n                                        this.#passwordCapability.reject(password);\n                                    } else {\n                                        this.#passwordCapability.resolve({\n                                            password\n                                        });\n                                    }\n                                };\n                                try {\n                                    loadingTask.onPassword(updatePassword, exception.code);\n                                } catch (ex) {\n                                    this.#passwordCapability.reject(ex);\n                                }\n                            } else {\n                                this.#passwordCapability.reject(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PasswordException(exception.message, exception.code));\n                            }\n                            return this.#passwordCapability.promise;\n                        });\n                        messageHandler.on(\"DataLoaded\", (data)=>{\n                            loadingTask.onProgress?.({\n                                loaded: data.length,\n                                total: data.length\n                            });\n                            this.downloadInfoCapability.resolve(data);\n                        });\n                        messageHandler.on(\"StartRenderPage\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const page = this.#pageCache.get(data.pageIndex);\n                            page._startRenderPage(data.transparency, data.cacheKey);\n                        });\n                        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n                            if (this.destroyed) {\n                                return null;\n                            }\n                            if (this.commonObjs.has(id)) {\n                                return null;\n                            }\n                            switch(type){\n                                case \"Font\":\n                                    const params = this._params;\n                                    if (\"error\" in exportedData) {\n                                        const exportedError = exportedData.error;\n                                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Error during font loading: ${exportedError}`);\n                                        this.commonObjs.resolve(id, exportedError);\n                                        break;\n                                    }\n                                    const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                                    const font = new _font_loader_js__WEBPACK_IMPORTED_MODULE_3__.FontFaceObject(exportedData, {\n                                        isEvalSupported: params.isEvalSupported,\n                                        disableFontFace: params.disableFontFace,\n                                        ignoreErrors: params.ignoreErrors,\n                                        inspectFont\n                                    });\n                                    this.fontLoader.bind(font).catch((reason)=>{\n                                        return messageHandler.sendWithPromise(\"FontFallback\", {\n                                            id\n                                        });\n                                    }).finally(()=>{\n                                        if (!params.fontExtraProperties && font.data) {\n                                            font.data = null;\n                                        }\n                                        this.commonObjs.resolve(id, font);\n                                    });\n                                    break;\n                                case \"CopyLocalImage\":\n                                    const { imageRef } = exportedData;\n                                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(imageRef, \"The imageRef must be defined.\");\n                                    for (const pageProxy of this.#pageCache.values()){\n                                        for (const [, data] of pageProxy.objs){\n                                            if (data.ref !== imageRef) {\n                                                continue;\n                                            }\n                                            if (!data.dataLen) {\n                                                return null;\n                                            }\n                                            this.commonObjs.resolve(id, structuredClone(data));\n                                            return data.dataLen;\n                                        }\n                                    }\n                                    break;\n                                case \"FontPath\":\n                                case \"Image\":\n                                case \"Pattern\":\n                                    this.commonObjs.resolve(id, exportedData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown common object type ${type}`);\n                            }\n                            return null;\n                        });\n                        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const pageProxy = this.#pageCache.get(pageIndex);\n                            if (pageProxy.objs.has(id)) {\n                                return;\n                            }\n                            if (pageProxy._intentStates.size === 0) {\n                                imageData?.bitmap?.close();\n                                return;\n                            }\n                            switch(type){\n                                case \"Image\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    if (imageData?.dataLen > _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MAX_IMAGE_SIZE_TO_CACHE) {\n                                        pageProxy._maybeCleanupAfterRender = true;\n                                    }\n                                    break;\n                                case \"Pattern\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown object type ${type}`);\n                            }\n                        });\n                        messageHandler.on(\"DocProgress\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            loadingTask.onProgress?.({\n                                loaded: data.loaded,\n                                total: data.total\n                            });\n                        });\n                        messageHandler.on(\"FetchBuiltInCMap\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.cMapReaderFactory) {\n                                return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.cMapReaderFactory.fetch(data);\n                        });\n                        messageHandler.on(\"FetchStandardFontData\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.standardFontDataFactory) {\n                                return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.standardFontDataFactory.fetch(data);\n                        });\n                    }\n                    getData() {\n                        return this.messageHandler.sendWithPromise(\"GetData\", null);\n                    }\n                    saveDocument() {\n                        if (this.annotationStorage.size <= 0) {\n                            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n                        }\n                        const { map, transfer } = this.annotationStorage.serializable;\n                        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n                            isPureXfa: !!this._htmlForXfa,\n                            numPages: this._numPages,\n                            annotationStorage: map,\n                            filename: this._fullReader?.filename ?? null\n                        }, transfer).finally(()=>{\n                            this.annotationStorage.resetModified();\n                        });\n                    }\n                    getPage(pageNumber) {\n                        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n                            return Promise.reject(new Error(\"Invalid page request.\"));\n                        }\n                        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n                            pageIndex\n                        }).then((pageInfo)=>{\n                            if (this.destroyed) {\n                                throw new Error(\"Transport destroyed\");\n                            }\n                            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n                            this.#pageCache.set(pageIndex, page);\n                            return page;\n                        });\n                        this.#pagePromises.set(pageIndex, promise);\n                        return promise;\n                    }\n                    getPageIndex(ref) {\n                        if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n                            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n                            num: ref.num,\n                            gen: ref.gen\n                        });\n                    }\n                    getAnnotations(pageIndex, intent) {\n                        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n                            pageIndex,\n                            intent\n                        });\n                    }\n                    getFieldObjects() {\n                        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n                    }\n                    hasJSActions() {\n                        return this.#cacheSimpleMethod(\"HasJSActions\");\n                    }\n                    getCalculationOrderIds() {\n                        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n                    }\n                    getDestinations() {\n                        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n                    }\n                    getDestination(id) {\n                        if (typeof id !== \"string\") {\n                            return Promise.reject(new Error(\"Invalid destination request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n                            id\n                        });\n                    }\n                    getPageLabels() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n                    }\n                    getPageLayout() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n                    }\n                    getPageMode() {\n                        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n                    }\n                    getViewerPreferences() {\n                        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n                    }\n                    getOpenAction() {\n                        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n                    }\n                    getAttachments() {\n                        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n                    }\n                    getDocJSActions() {\n                        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n                    }\n                    getPageJSActions(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n                            pageIndex\n                        });\n                    }\n                    getStructTree(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n                            pageIndex\n                        });\n                    }\n                    getOutline() {\n                        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n                    }\n                    getOptionalContentConfig() {\n                        return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then((results)=>{\n                            return new _optional_content_config_js__WEBPACK_IMPORTED_MODULE_9__.OptionalContentConfig(results);\n                        });\n                    }\n                    getPermissions() {\n                        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n                    }\n                    getMetadata() {\n                        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>{\n                            return {\n                                info: results[0],\n                                metadata: results[1] ? new _metadata_js__WEBPACK_IMPORTED_MODULE_8__.Metadata(results[1]) : null,\n                                contentDispositionFilename: this._fullReader?.filename ?? null,\n                                contentLength: this._fullReader?.contentLength ?? null\n                            };\n                        });\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    getMarkInfo() {\n                        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n                    }\n                    async startCleanup(keepLoadedFonts = false) {\n                        if (this.destroyed) {\n                            return;\n                        }\n                        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n                        for (const page of this.#pageCache.values()){\n                            const cleanupSuccessful = page.cleanup();\n                            if (!cleanupSuccessful) {\n                                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n                            }\n                        }\n                        this.commonObjs.clear();\n                        if (!keepLoadedFonts) {\n                            this.fontLoader.clear();\n                        }\n                        this.#methodPromises.clear();\n                        this.filterFactory.destroy(true);\n                    }\n                    get loadingParams() {\n                        const { disableAutoFetch, enableXfa } = this._params;\n                        return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"loadingParams\", {\n                            disableAutoFetch,\n                            enableXfa\n                        });\n                    }\n                }\n                class PDFObjects {\n                    #objs;\n                    #ensureObj(objId) {\n                        return this.#objs[objId] ||= {\n                            capability: new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability(),\n                            data: null\n                        };\n                    }\n                    get(objId, callback = null) {\n                        if (callback) {\n                            const obj = this.#ensureObj(objId);\n                            obj.capability.promise.then(()=>callback(obj.data));\n                            return null;\n                        }\n                        const obj = this.#objs[objId];\n                        if (!obj?.capability.settled) {\n                            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n                        }\n                        return obj.data;\n                    }\n                    has(objId) {\n                        const obj = this.#objs[objId];\n                        return obj?.capability.settled ?? false;\n                    }\n                    resolve(objId, data = null) {\n                        const obj = this.#ensureObj(objId);\n                        obj.data = data;\n                        obj.capability.resolve();\n                    }\n                    clear() {\n                        for(const objId in this.#objs){\n                            const { data } = this.#objs[objId];\n                            data?.bitmap?.close();\n                        }\n                        this.#objs = Object.create(null);\n                    }\n                    *[Symbol.iterator]() {\n                        for(const objId in this.#objs){\n                            const { capability, data } = this.#objs[objId];\n                            if (!capability.settled) {\n                                continue;\n                            }\n                            yield [\n                                objId,\n                                data\n                            ];\n                        }\n                    }\n                    constructor(){\n                        this.#objs = Object.create(null);\n                    }\n                }\n                class RenderTask {\n                    #internalRenderTask;\n                    constructor(internalRenderTask){\n                        this.#internalRenderTask = null;\n                        this.#internalRenderTask = internalRenderTask;\n                        this.onContinue = null;\n                    }\n                    get promise() {\n                        return this.#internalRenderTask.capability.promise;\n                    }\n                    cancel(extraDelay = 0) {\n                        this.#internalRenderTask.cancel(null, extraDelay);\n                    }\n                    get separateAnnots() {\n                        const { separateAnnots } = this.#internalRenderTask.operatorList;\n                        if (!separateAnnots) {\n                            return false;\n                        }\n                        const { annotationCanvasMap } = this.#internalRenderTask;\n                        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n                    }\n                }\n                class InternalRenderTask {\n                    static #canvasInUse = new WeakSet();\n                    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n                        this.callback = callback;\n                        this.params = params;\n                        this.objs = objs;\n                        this.commonObjs = commonObjs;\n                        this.annotationCanvasMap = annotationCanvasMap;\n                        this.operatorListIdx = null;\n                        this.operatorList = operatorList;\n                        this._pageIndex = pageIndex;\n                        this.canvasFactory = canvasFactory;\n                        this.filterFactory = filterFactory;\n                        this._pdfBug = pdfBug;\n                        this.pageColors = pageColors;\n                        this.running = false;\n                        this.graphicsReadyCallback = null;\n                        this.graphicsReady = false;\n                        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n                        this.cancelled = false;\n                        this.capability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.task = new RenderTask(this);\n                        this._cancelBound = this.cancel.bind(this);\n                        this._continueBound = this._continue.bind(this);\n                        this._scheduleNextBound = this._scheduleNext.bind(this);\n                        this._nextBound = this._next.bind(this);\n                        this._canvas = params.canvasContext.canvas;\n                    }\n                    get completed() {\n                        return this.capability.promise.catch(function() {});\n                    }\n                    initializeGraphics({ transparency = false, optionalContentConfig }) {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this._canvas) {\n                            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n                            }\n                            InternalRenderTask.#canvasInUse.add(this._canvas);\n                        }\n                        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n                            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n                            this.stepper.init(this.operatorList);\n                            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n                        }\n                        const { canvasContext, viewport, transform, background } = this.params;\n                        this.gfx = new _canvas_js__WEBPACK_IMPORTED_MODULE_5__.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                            optionalContentConfig\n                        }, this.annotationCanvasMap, this.pageColors);\n                        this.gfx.beginDrawing({\n                            transform,\n                            viewport,\n                            transparency,\n                            background\n                        });\n                        this.operatorListIdx = 0;\n                        this.graphicsReady = true;\n                        this.graphicsReadyCallback?.();\n                    }\n                    cancel(error = null, extraDelay = 0) {\n                        this.running = false;\n                        this.cancelled = true;\n                        this.gfx?.endDrawing();\n                        InternalRenderTask.#canvasInUse.delete(this._canvas);\n                        this.callback(error || new _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n                    }\n                    operatorListChanged() {\n                        if (!this.graphicsReady) {\n                            this.graphicsReadyCallback ||= this._continueBound;\n                            return;\n                        }\n                        this.stepper?.updateOperatorList(this.operatorList);\n                        if (this.running) {\n                            return;\n                        }\n                        this._continue();\n                    }\n                    _continue() {\n                        this.running = true;\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this.task.onContinue) {\n                            this.task.onContinue(this._scheduleNextBound);\n                        } else {\n                            this._scheduleNext();\n                        }\n                    }\n                    _scheduleNext() {\n                        if (this._useRequestAnimationFrame) {\n                            window.requestAnimationFrame(()=>{\n                                this._nextBound().catch(this._cancelBound);\n                            });\n                        } else {\n                            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n                        }\n                    }\n                    async _next() {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n                        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                            this.running = false;\n                            if (this.operatorList.lastChunk) {\n                                this.gfx.endDrawing();\n                                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                                this.callback();\n                            }\n                        }\n                    }\n                }\n                const version = \"4.0.379\";\n                const build = \"9e14d04fd\";\n                __webpack_async_result__();\n            } catch (e) {\n                __webpack_async_result__(e);\n            }\n        });\n    /***/ },\n    /***/ 822: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_226410__)=>{\n        /* harmony export */ __nested_webpack_require_226410__.d(__nested_webpack_exports__, {\n            /* harmony export */ BaseCMapReaderFactory: ()=>/* binding */ BaseCMapReaderFactory,\n            /* harmony export */ BaseCanvasFactory: ()=>/* binding */ BaseCanvasFactory,\n            /* harmony export */ BaseFilterFactory: ()=>/* binding */ BaseFilterFactory,\n            /* harmony export */ BaseSVGFactory: ()=>/* binding */ BaseSVGFactory,\n            /* harmony export */ BaseStandardFontDataFactory: ()=>/* binding */ BaseStandardFontDataFactory\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_226410__(266);\n        class BaseFilterFactory {\n            constructor(){\n                if (this.constructor === BaseFilterFactory) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n                }\n            }\n            addFilter(maps) {\n                return \"none\";\n            }\n            addHCMFilter(fgColor, bgColor) {\n                return \"none\";\n            }\n            addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                return \"none\";\n            }\n            destroy(keepHCM = false) {}\n        }\n        class BaseCanvasFactory {\n            constructor(){\n                if (this.constructor === BaseCanvasFactory) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n                }\n            }\n            create(width, height) {\n                if (width <= 0 || height <= 0) {\n                    throw new Error(\"Invalid canvas size\");\n                }\n                const canvas = this._createCanvas(width, height);\n                return {\n                    canvas,\n                    context: canvas.getContext(\"2d\")\n                };\n            }\n            reset(canvasAndContext, width, height) {\n                if (!canvasAndContext.canvas) {\n                    throw new Error(\"Canvas is not specified\");\n                }\n                if (width <= 0 || height <= 0) {\n                    throw new Error(\"Invalid canvas size\");\n                }\n                canvasAndContext.canvas.width = width;\n                canvasAndContext.canvas.height = height;\n            }\n            destroy(canvasAndContext) {\n                if (!canvasAndContext.canvas) {\n                    throw new Error(\"Canvas is not specified\");\n                }\n                canvasAndContext.canvas.width = 0;\n                canvasAndContext.canvas.height = 0;\n                canvasAndContext.canvas = null;\n                canvasAndContext.context = null;\n            }\n            _createCanvas(width, height) {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Abstract method `_createCanvas` called.\");\n            }\n        }\n        class BaseCMapReaderFactory {\n            constructor({ baseUrl = null, isCompressed = true }){\n                if (this.constructor === BaseCMapReaderFactory) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n                }\n                this.baseUrl = baseUrl;\n                this.isCompressed = isCompressed;\n            }\n            async fetch({ name }) {\n                if (!this.baseUrl) {\n                    throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n                }\n                if (!name) {\n                    throw new Error(\"CMap name must be specified.\");\n                }\n                const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                const compressionType = this.isCompressed ? _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.CMapCompressionType.BINARY : _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.CMapCompressionType.NONE;\n                return this._fetchData(url, compressionType).catch((reason)=>{\n                    throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n                });\n            }\n            _fetchData(url, compressionType) {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Abstract method `_fetchData` called.\");\n            }\n        }\n        class BaseStandardFontDataFactory {\n            constructor({ baseUrl = null }){\n                if (this.constructor === BaseStandardFontDataFactory) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n                }\n                this.baseUrl = baseUrl;\n            }\n            async fetch({ filename }) {\n                if (!this.baseUrl) {\n                    throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n                }\n                if (!filename) {\n                    throw new Error(\"Font filename must be specified.\");\n                }\n                const url = `${this.baseUrl}${filename}`;\n                return this._fetchData(url).catch((reason)=>{\n                    throw new Error(`Unable to load font data at: ${url}`);\n                });\n            }\n            _fetchData(url) {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Abstract method `_fetchData` called.\");\n            }\n        }\n        class BaseSVGFactory {\n            constructor(){\n                if (this.constructor === BaseSVGFactory) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n                }\n            }\n            create(width, height, skipDimensions = false) {\n                if (width <= 0 || height <= 0) {\n                    throw new Error(\"Invalid SVG dimensions\");\n                }\n                const svg = this._createSVG(\"svg:svg\");\n                svg.setAttribute(\"version\", \"1.1\");\n                if (!skipDimensions) {\n                    svg.setAttribute(\"width\", `${width}px`);\n                    svg.setAttribute(\"height\", `${height}px`);\n                }\n                svg.setAttribute(\"preserveAspectRatio\", \"none\");\n                svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n                return svg;\n            }\n            createElement(type) {\n                if (typeof type !== \"string\") {\n                    throw new Error(\"Invalid SVG element type\");\n                }\n                return this._createSVG(type);\n            }\n            _createSVG(type) {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Abstract method `_createSVG` called.\");\n            }\n        }\n    /***/ },\n    /***/ 250: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_233430__)=>{\n        // EXPORTS\n        __nested_webpack_require_233430__.d(__nested_webpack_exports__, {\n            CanvasGraphics: ()=>/* binding */ CanvasGraphics\n        });\n        // EXTERNAL MODULE: ./src/shared/util.js\n        var util = __nested_webpack_require_233430__(266);\n        // EXTERNAL MODULE: ./src/display/display_utils.js\n        var display_utils = __nested_webpack_require_233430__(473);\n        ; // CONCATENATED MODULE: ./src/display/pattern_helper.js\n        const PathType = {\n            FILL: \"Fill\",\n            STROKE: \"Stroke\",\n            SHADING: \"Shading\"\n        };\n        function applyBoundingBox(ctx, bbox) {\n            if (!bbox) {\n                return;\n            }\n            const width = bbox[2] - bbox[0];\n            const height = bbox[3] - bbox[1];\n            const region = new Path2D();\n            region.rect(bbox[0], bbox[1], width, height);\n            ctx.clip(region);\n        }\n        class BaseShadingPattern {\n            constructor(){\n                if (this.constructor === BaseShadingPattern) {\n                    (0, util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n                }\n            }\n            getPattern() {\n                (0, util.unreachable)(\"Abstract method `getPattern` called.\");\n            }\n        }\n        class RadialAxialShadingPattern extends BaseShadingPattern {\n            constructor(IR){\n                super();\n                this._type = IR[1];\n                this._bbox = IR[2];\n                this._colorStops = IR[3];\n                this._p0 = IR[4];\n                this._p1 = IR[5];\n                this._r0 = IR[6];\n                this._r1 = IR[7];\n                this.matrix = null;\n            }\n            _createGradient(ctx) {\n                let grad;\n                if (this._type === \"axial\") {\n                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n                } else if (this._type === \"radial\") {\n                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n                }\n                for (const colorStop of this._colorStops){\n                    grad.addColorStop(colorStop[0], colorStop[1]);\n                }\n                return grad;\n            }\n            getPattern(ctx, owner, inverse, pathType) {\n                let pattern;\n                if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, display_utils.getCurrentTransform)(ctx)) || [\n                        0,\n                        0,\n                        0,\n                        0\n                    ];\n                    const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n                    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n                    const tmpCtx = tmpCanvas.context;\n                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                    tmpCtx.beginPath();\n                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n                    inverse = util.Util.transform(inverse, [\n                        1,\n                        0,\n                        0,\n                        1,\n                        ownerBBox[0],\n                        ownerBBox[1]\n                    ]);\n                    tmpCtx.transform(...owner.baseTransform);\n                    if (this.matrix) {\n                        tmpCtx.transform(...this.matrix);\n                    }\n                    applyBoundingBox(tmpCtx, this._bbox);\n                    tmpCtx.fillStyle = this._createGradient(tmpCtx);\n                    tmpCtx.fill();\n                    pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n                    const domMatrix = new DOMMatrix(inverse);\n                    pattern.setTransform(domMatrix);\n                } else {\n                    applyBoundingBox(ctx, this._bbox);\n                    pattern = this._createGradient(ctx);\n                }\n                return pattern;\n            }\n        }\n        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n            const coords = context.coords, colors = context.colors;\n            const bytes = data.data, rowSize = data.width * 4;\n            let tmp;\n            if (coords[p1 + 1] > coords[p2 + 1]) {\n                tmp = p1;\n                p1 = p2;\n                p2 = tmp;\n                tmp = c1;\n                c1 = c2;\n                c2 = tmp;\n            }\n            if (coords[p2 + 1] > coords[p3 + 1]) {\n                tmp = p2;\n                p2 = p3;\n                p3 = tmp;\n                tmp = c2;\n                c2 = c3;\n                c3 = tmp;\n            }\n            if (coords[p1 + 1] > coords[p2 + 1]) {\n                tmp = p1;\n                p1 = p2;\n                p2 = tmp;\n                tmp = c1;\n                c1 = c2;\n                c2 = tmp;\n            }\n            const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n            const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n            const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n            const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n            const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n            const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n            if (y1 >= y3) {\n                return;\n            }\n            const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n            const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n            const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n            const minY = Math.round(y1), maxY = Math.round(y3);\n            let xa, car, cag, cab;\n            let xb, cbr, cbg, cbb;\n            for(let y = minY; y <= maxY; y++){\n                if (y < y2) {\n                    const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n                    xa = x1 - (x1 - x2) * k;\n                    car = c1r - (c1r - c2r) * k;\n                    cag = c1g - (c1g - c2g) * k;\n                    cab = c1b - (c1b - c2b) * k;\n                } else {\n                    let k;\n                    if (y > y3) {\n                        k = 1;\n                    } else if (y2 === y3) {\n                        k = 0;\n                    } else {\n                        k = (y2 - y) / (y2 - y3);\n                    }\n                    xa = x2 - (x2 - x3) * k;\n                    car = c2r - (c2r - c3r) * k;\n                    cag = c2g - (c2g - c3g) * k;\n                    cab = c2b - (c2b - c3b) * k;\n                }\n                let k;\n                if (y < y1) {\n                    k = 0;\n                } else if (y > y3) {\n                    k = 1;\n                } else {\n                    k = (y1 - y) / (y1 - y3);\n                }\n                xb = x1 - (x1 - x3) * k;\n                cbr = c1r - (c1r - c3r) * k;\n                cbg = c1g - (c1g - c3g) * k;\n                cbb = c1b - (c1b - c3b) * k;\n                const x1_ = Math.round(Math.min(xa, xb));\n                const x2_ = Math.round(Math.max(xa, xb));\n                let j = rowSize * y + x1_ * 4;\n                for(let x = x1_; x <= x2_; x++){\n                    k = (xa - x) / (xa - xb);\n                    if (k < 0) {\n                        k = 0;\n                    } else if (k > 1) {\n                        k = 1;\n                    }\n                    bytes[j++] = car - (car - cbr) * k | 0;\n                    bytes[j++] = cag - (cag - cbg) * k | 0;\n                    bytes[j++] = cab - (cab - cbb) * k | 0;\n                    bytes[j++] = 255;\n                }\n            }\n        }\n        function drawFigure(data, figure, context) {\n            const ps = figure.coords;\n            const cs = figure.colors;\n            let i, ii;\n            switch(figure.type){\n                case \"lattice\":\n                    const verticesPerRow = figure.verticesPerRow;\n                    const rows = Math.floor(ps.length / verticesPerRow) - 1;\n                    const cols = verticesPerRow - 1;\n                    for(i = 0; i < rows; i++){\n                        let q = i * verticesPerRow;\n                        for(let j = 0; j < cols; j++, q++){\n                            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                        }\n                    }\n                    break;\n                case \"triangles\":\n                    for(i = 0, ii = ps.length; i < ii; i += 3){\n                        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n                    }\n                    break;\n                default:\n                    throw new Error(\"illegal figure\");\n            }\n        }\n        class MeshShadingPattern extends BaseShadingPattern {\n            constructor(IR){\n                super();\n                this._coords = IR[2];\n                this._colors = IR[3];\n                this._figures = IR[4];\n                this._bounds = IR[5];\n                this._bbox = IR[7];\n                this._background = IR[8];\n                this.matrix = null;\n            }\n            _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n                const EXPECTED_SCALE = 1.1;\n                const MAX_PATTERN_SIZE = 3000;\n                const BORDER_SIZE = 2;\n                const offsetX = Math.floor(this._bounds[0]);\n                const offsetY = Math.floor(this._bounds[1]);\n                const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n                const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n                const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                const scaleX = boundsWidth / width;\n                const scaleY = boundsHeight / height;\n                const context = {\n                    coords: this._coords,\n                    colors: this._colors,\n                    offsetX: -offsetX,\n                    offsetY: -offsetY,\n                    scaleX: 1 / scaleX,\n                    scaleY: 1 / scaleY\n                };\n                const paddedWidth = width + BORDER_SIZE * 2;\n                const paddedHeight = height + BORDER_SIZE * 2;\n                const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n                const tmpCtx = tmpCanvas.context;\n                const data = tmpCtx.createImageData(width, height);\n                if (backgroundColor) {\n                    const bytes = data.data;\n                    for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                        bytes[i] = backgroundColor[0];\n                        bytes[i + 1] = backgroundColor[1];\n                        bytes[i + 2] = backgroundColor[2];\n                        bytes[i + 3] = 255;\n                    }\n                }\n                for (const figure of this._figures){\n                    drawFigure(data, figure, context);\n                }\n                tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n                const canvas = tmpCanvas.canvas;\n                return {\n                    canvas,\n                    offsetX: offsetX - BORDER_SIZE * scaleX,\n                    offsetY: offsetY - BORDER_SIZE * scaleY,\n                    scaleX,\n                    scaleY\n                };\n            }\n            getPattern(ctx, owner, inverse, pathType) {\n                applyBoundingBox(ctx, this._bbox);\n                let scale;\n                if (pathType === PathType.SHADING) {\n                    scale = util.Util.singularValueDecompose2dScale((0, display_utils.getCurrentTransform)(ctx));\n                } else {\n                    scale = util.Util.singularValueDecompose2dScale(owner.baseTransform);\n                    if (this.matrix) {\n                        const matrixScale = util.Util.singularValueDecompose2dScale(this.matrix);\n                        scale = [\n                            scale[0] * matrixScale[0],\n                            scale[1] * matrixScale[1]\n                        ];\n                    }\n                }\n                const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n                if (pathType !== PathType.SHADING) {\n                    ctx.setTransform(...owner.baseTransform);\n                    if (this.matrix) {\n                        ctx.transform(...this.matrix);\n                    }\n                }\n                ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n                return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n            }\n        }\n        class DummyShadingPattern extends BaseShadingPattern {\n            getPattern() {\n                return \"hotpink\";\n            }\n        }\n        function getShadingPattern(IR) {\n            switch(IR[0]){\n                case \"RadialAxial\":\n                    return new RadialAxialShadingPattern(IR);\n                case \"Mesh\":\n                    return new MeshShadingPattern(IR);\n                case \"Dummy\":\n                    return new DummyShadingPattern();\n            }\n            throw new Error(`Unknown IR type: ${IR[0]}`);\n        }\n        const PaintType = {\n            COLORED: 1,\n            UNCOLORED: 2\n        };\n        class TilingPattern {\n            static{\n                this.MAX_PATTERN_SIZE = 3000;\n            }\n            constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n                this.operatorList = IR[2];\n                this.matrix = IR[3] || [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n                this.bbox = IR[4];\n                this.xstep = IR[5];\n                this.ystep = IR[6];\n                this.paintType = IR[7];\n                this.tilingType = IR[8];\n                this.color = color;\n                this.ctx = ctx;\n                this.canvasGraphicsFactory = canvasGraphicsFactory;\n                this.baseTransform = baseTransform;\n            }\n            createPatternCanvas(owner) {\n                const operatorList = this.operatorList;\n                const bbox = this.bbox;\n                const xstep = this.xstep;\n                const ystep = this.ystep;\n                const paintType = this.paintType;\n                const tilingType = this.tilingType;\n                const color = this.color;\n                const canvasGraphicsFactory = this.canvasGraphicsFactory;\n                (0, util.info)(\"TilingType: \" + tilingType);\n                const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n                const matrixScale = util.Util.singularValueDecompose2dScale(this.matrix);\n                const curMatrixScale = util.Util.singularValueDecompose2dScale(this.baseTransform);\n                const combinedScale = [\n                    matrixScale[0] * curMatrixScale[0],\n                    matrixScale[1] * curMatrixScale[1]\n                ];\n                const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n                const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n                const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n                const tmpCtx = tmpCanvas.context;\n                const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n                graphics.groupLevel = owner.groupLevel;\n                this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n                let adjustedX0 = x0;\n                let adjustedY0 = y0;\n                let adjustedX1 = x1;\n                let adjustedY1 = y1;\n                if (x0 < 0) {\n                    adjustedX0 = 0;\n                    adjustedX1 += Math.abs(x0);\n                }\n                if (y0 < 0) {\n                    adjustedY0 = 0;\n                    adjustedY1 += Math.abs(y0);\n                }\n                tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n                graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n                tmpCtx.save();\n                this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n                graphics.baseTransform = (0, display_utils.getCurrentTransform)(graphics.ctx);\n                graphics.executeOperatorList(operatorList);\n                graphics.endDrawing();\n                return {\n                    canvas: tmpCanvas.canvas,\n                    scaleX: dimx.scale,\n                    scaleY: dimy.scale,\n                    offsetX: adjustedX0,\n                    offsetY: adjustedY0\n                };\n            }\n            getSizeAndScale(step, realOutputSize, scale) {\n                step = Math.abs(step);\n                const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n                let size = Math.ceil(step * scale);\n                if (size >= maxSize) {\n                    size = maxSize;\n                } else {\n                    scale = size / step;\n                }\n                return {\n                    scale,\n                    size\n                };\n            }\n            clipBbox(graphics, x0, y0, x1, y1) {\n                const bboxWidth = x1 - x0;\n                const bboxHeight = y1 - y0;\n                graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n                graphics.current.updateRectMinMax((0, display_utils.getCurrentTransform)(graphics.ctx), [\n                    x0,\n                    y0,\n                    x1,\n                    y1\n                ]);\n                graphics.clip();\n                graphics.endPath();\n            }\n            setFillAndStrokeStyleToContext(graphics, paintType, color) {\n                const context = graphics.ctx, current = graphics.current;\n                switch(paintType){\n                    case PaintType.COLORED:\n                        const ctx = this.ctx;\n                        context.fillStyle = ctx.fillStyle;\n                        context.strokeStyle = ctx.strokeStyle;\n                        current.fillColor = ctx.fillStyle;\n                        current.strokeColor = ctx.strokeStyle;\n                        break;\n                    case PaintType.UNCOLORED:\n                        const cssColor = util.Util.makeHexColor(color[0], color[1], color[2]);\n                        context.fillStyle = cssColor;\n                        context.strokeStyle = cssColor;\n                        current.fillColor = cssColor;\n                        current.strokeColor = cssColor;\n                        break;\n                    default:\n                        throw new util.FormatError(`Unsupported paint type: ${paintType}`);\n                }\n            }\n            getPattern(ctx, owner, inverse, pathType) {\n                let matrix = inverse;\n                if (pathType !== PathType.SHADING) {\n                    matrix = util.Util.transform(matrix, owner.baseTransform);\n                    if (this.matrix) {\n                        matrix = util.Util.transform(matrix, this.matrix);\n                    }\n                }\n                const temporaryPatternCanvas = this.createPatternCanvas(owner);\n                let domMatrix = new DOMMatrix(matrix);\n                domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n                const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n                pattern.setTransform(domMatrix);\n                return pattern;\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/shared/image_utils.js\n        function convertToRGBA(params) {\n            switch(params.kind){\n                case ImageKind.GRAYSCALE_1BPP:\n                    return convertBlackAndWhiteToRGBA(params);\n                case ImageKind.RGB_24BPP:\n                    return convertRGBToRGBA(params);\n            }\n            return null;\n        }\n        function convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n            const black = util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n            const [zeroMapping, oneMapping] = inverseDecode ? [\n                nonBlackColor,\n                black\n            ] : [\n                black,\n                nonBlackColor\n            ];\n            const widthInSource = width >> 3;\n            const widthRemainder = width & 7;\n            const srcLength = src.length;\n            dest = new Uint32Array(dest.buffer);\n            let destPos = 0;\n            for(let i = 0; i < height; i++){\n                for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n                    const elem = srcPos < srcLength ? src[srcPos] : 255;\n                    dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n                    dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n                }\n                if (widthRemainder === 0) {\n                    continue;\n                }\n                const elem = srcPos < srcLength ? src[srcPos++] : 255;\n                for(let j = 0; j < widthRemainder; j++){\n                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n                }\n            }\n            return {\n                srcPos,\n                destPos\n            };\n        }\n        function convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n            let i = 0;\n            const len32 = src.length >> 2;\n            const src32 = new Uint32Array(src.buffer, srcPos, len32);\n            if (FeatureTest.isLittleEndian) {\n                for(; i < len32 - 2; i += 3, destPos += 4){\n                    const s1 = src32[i];\n                    const s2 = src32[i + 1];\n                    const s3 = src32[i + 2];\n                    dest[destPos] = s1 | 0xff000000;\n                    dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n                    dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n                    dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n                }\n                for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                    dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n                }\n            } else {\n                for(; i < len32 - 2; i += 3, destPos += 4){\n                    const s1 = src32[i];\n                    const s2 = src32[i + 1];\n                    const s3 = src32[i + 2];\n                    dest[destPos] = s1 | 0xff;\n                    dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n                    dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n                    dest[destPos + 3] = s3 << 8 | 0xff;\n                }\n                for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                    dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n                }\n            }\n            return {\n                srcPos,\n                destPos\n            };\n        }\n        function grayToRGBA(src, dest) {\n            if (FeatureTest.isLittleEndian) {\n                for(let i = 0, ii = src.length; i < ii; i++){\n                    dest[i] = src[i] * 0x10101 | 0xff000000;\n                }\n            } else {\n                for(let i = 0, ii = src.length; i < ii; i++){\n                    dest[i] = src[i] * 0x1010100 | 0x000000ff;\n                }\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/display/canvas.js\n        const MIN_FONT_SIZE = 16;\n        const MAX_FONT_SIZE = 100;\n        const MAX_GROUP_SIZE = 4096;\n        const EXECUTION_TIME = 15;\n        const EXECUTION_STEPS = 10;\n        const MAX_SIZE_TO_COMPILE = 1000;\n        const FULL_CHUNK_HEIGHT = 16;\n        function mirrorContextOperations(ctx, destCtx) {\n            if (ctx._removeMirroring) {\n                throw new Error(\"Context is already forwarding operations.\");\n            }\n            ctx.__originalSave = ctx.save;\n            ctx.__originalRestore = ctx.restore;\n            ctx.__originalRotate = ctx.rotate;\n            ctx.__originalScale = ctx.scale;\n            ctx.__originalTranslate = ctx.translate;\n            ctx.__originalTransform = ctx.transform;\n            ctx.__originalSetTransform = ctx.setTransform;\n            ctx.__originalResetTransform = ctx.resetTransform;\n            ctx.__originalClip = ctx.clip;\n            ctx.__originalMoveTo = ctx.moveTo;\n            ctx.__originalLineTo = ctx.lineTo;\n            ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n            ctx.__originalRect = ctx.rect;\n            ctx.__originalClosePath = ctx.closePath;\n            ctx.__originalBeginPath = ctx.beginPath;\n            ctx._removeMirroring = ()=>{\n                ctx.save = ctx.__originalSave;\n                ctx.restore = ctx.__originalRestore;\n                ctx.rotate = ctx.__originalRotate;\n                ctx.scale = ctx.__originalScale;\n                ctx.translate = ctx.__originalTranslate;\n                ctx.transform = ctx.__originalTransform;\n                ctx.setTransform = ctx.__originalSetTransform;\n                ctx.resetTransform = ctx.__originalResetTransform;\n                ctx.clip = ctx.__originalClip;\n                ctx.moveTo = ctx.__originalMoveTo;\n                ctx.lineTo = ctx.__originalLineTo;\n                ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n                ctx.rect = ctx.__originalRect;\n                ctx.closePath = ctx.__originalClosePath;\n                ctx.beginPath = ctx.__originalBeginPath;\n                delete ctx._removeMirroring;\n            };\n            ctx.save = function ctxSave() {\n                destCtx.save();\n                this.__originalSave();\n            };\n            ctx.restore = function ctxRestore() {\n                destCtx.restore();\n                this.__originalRestore();\n            };\n            ctx.translate = function ctxTranslate(x, y) {\n                destCtx.translate(x, y);\n                this.__originalTranslate(x, y);\n            };\n            ctx.scale = function ctxScale(x, y) {\n                destCtx.scale(x, y);\n                this.__originalScale(x, y);\n            };\n            ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n                destCtx.transform(a, b, c, d, e, f);\n                this.__originalTransform(a, b, c, d, e, f);\n            };\n            ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n                destCtx.setTransform(a, b, c, d, e, f);\n                this.__originalSetTransform(a, b, c, d, e, f);\n            };\n            ctx.resetTransform = function ctxResetTransform() {\n                destCtx.resetTransform();\n                this.__originalResetTransform();\n            };\n            ctx.rotate = function ctxRotate(angle) {\n                destCtx.rotate(angle);\n                this.__originalRotate(angle);\n            };\n            ctx.clip = function ctxRotate(rule) {\n                destCtx.clip(rule);\n                this.__originalClip(rule);\n            };\n            ctx.moveTo = function(x, y) {\n                destCtx.moveTo(x, y);\n                this.__originalMoveTo(x, y);\n            };\n            ctx.lineTo = function(x, y) {\n                destCtx.lineTo(x, y);\n                this.__originalLineTo(x, y);\n            };\n            ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n                destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n            };\n            ctx.rect = function(x, y, width, height) {\n                destCtx.rect(x, y, width, height);\n                this.__originalRect(x, y, width, height);\n            };\n            ctx.closePath = function() {\n                destCtx.closePath();\n                this.__originalClosePath();\n            };\n            ctx.beginPath = function() {\n                destCtx.beginPath();\n                this.__originalBeginPath();\n            };\n        }\n        class CachedCanvases {\n            constructor(canvasFactory){\n                this.canvasFactory = canvasFactory;\n                this.cache = Object.create(null);\n            }\n            getCanvas(id, width, height) {\n                let canvasEntry;\n                if (this.cache[id] !== undefined) {\n                    canvasEntry = this.cache[id];\n                    this.canvasFactory.reset(canvasEntry, width, height);\n                } else {\n                    canvasEntry = this.canvasFactory.create(width, height);\n                    this.cache[id] = canvasEntry;\n                }\n                return canvasEntry;\n            }\n            delete(id) {\n                delete this.cache[id];\n            }\n            clear() {\n                for(const id in this.cache){\n                    const canvasEntry = this.cache[id];\n                    this.canvasFactory.destroy(canvasEntry);\n                    delete this.cache[id];\n                }\n            }\n        }\n        function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n            const [a, b, c, d, tx, ty] = (0, display_utils.getCurrentTransform)(ctx);\n            if (b === 0 && c === 0) {\n                const tlX = destX * a + tx;\n                const rTlX = Math.round(tlX);\n                const tlY = destY * d + ty;\n                const rTlY = Math.round(tlY);\n                const brX = (destX + destW) * a + tx;\n                const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                const brY = (destY + destH) * d + ty;\n                const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n                ctx.setTransform(a, b, c, d, tx, ty);\n                return [\n                    rWidth,\n                    rHeight\n                ];\n            }\n            if (a === 0 && d === 0) {\n                const tlX = destY * c + tx;\n                const rTlX = Math.round(tlX);\n                const tlY = destX * b + ty;\n                const rTlY = Math.round(tlY);\n                const brX = (destY + destH) * c + tx;\n                const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                const brY = (destX + destW) * b + ty;\n                const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n                ctx.setTransform(a, b, c, d, tx, ty);\n                return [\n                    rHeight,\n                    rWidth\n                ];\n            }\n            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n            const scaleX = Math.hypot(a, b);\n            const scaleY = Math.hypot(c, d);\n            return [\n                scaleX * destW,\n                scaleY * destH\n            ];\n        }\n        function compileType3Glyph(imgData) {\n            const { width, height } = imgData;\n            if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n                return null;\n            }\n            const POINT_TO_PROCESS_LIMIT = 1000;\n            const POINT_TYPES = new Uint8Array([\n                0,\n                2,\n                4,\n                0,\n                1,\n                0,\n                5,\n                4,\n                8,\n                10,\n                0,\n                8,\n                0,\n                2,\n                1,\n                0\n            ]);\n            const width1 = width + 1;\n            let points = new Uint8Array(width1 * (height + 1));\n            let i, j, j0;\n            const lineSize = width + 7 & ~7;\n            let data = new Uint8Array(lineSize * height), pos = 0;\n            for (const elem of imgData.data){\n                let mask = 128;\n                while(mask > 0){\n                    data[pos++] = elem & mask ? 0 : 255;\n                    mask >>= 1;\n                }\n            }\n            let count = 0;\n            pos = 0;\n            if (data[pos] !== 0) {\n                points[0] = 1;\n                ++count;\n            }\n            for(j = 1; j < width; j++){\n                if (data[pos] !== data[pos + 1]) {\n                    points[j] = data[pos] ? 2 : 1;\n                    ++count;\n                }\n                pos++;\n            }\n            if (data[pos] !== 0) {\n                points[j] = 2;\n                ++count;\n            }\n            for(i = 1; i < height; i++){\n                pos = i * lineSize;\n                j0 = i * width1;\n                if (data[pos - lineSize] !== data[pos]) {\n                    points[j0] = data[pos] ? 1 : 8;\n                    ++count;\n                }\n                let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n                for(j = 1; j < width; j++){\n                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n                    if (POINT_TYPES[sum]) {\n                        points[j0 + j] = POINT_TYPES[sum];\n                        ++count;\n                    }\n                    pos++;\n                }\n                if (data[pos - lineSize] !== data[pos]) {\n                    points[j0 + j] = data[pos] ? 2 : 4;\n                    ++count;\n                }\n                if (count > POINT_TO_PROCESS_LIMIT) {\n                    return null;\n                }\n            }\n            pos = lineSize * (height - 1);\n            j0 = i * width1;\n            if (data[pos] !== 0) {\n                points[j0] = 8;\n                ++count;\n            }\n            for(j = 1; j < width; j++){\n                if (data[pos] !== data[pos + 1]) {\n                    points[j0 + j] = data[pos] ? 4 : 8;\n                    ++count;\n                }\n                pos++;\n            }\n            if (data[pos] !== 0) {\n                points[j0 + j] = 4;\n                ++count;\n            }\n            if (count > POINT_TO_PROCESS_LIMIT) {\n                return null;\n            }\n            const steps = new Int32Array([\n                0,\n                width1,\n                -1,\n                0,\n                -width1,\n                0,\n                0,\n                0,\n                1\n            ]);\n            const path = new Path2D();\n            for(i = 0; count && i <= height; i++){\n                let p = i * width1;\n                const end = p + width;\n                while(p < end && !points[p]){\n                    p++;\n                }\n                if (p === end) {\n                    continue;\n                }\n                path.moveTo(p % width1, i);\n                const p0 = p;\n                let type = points[p];\n                do {\n                    const step = steps[type];\n                    do {\n                        p += step;\n                    }while (!points[p]);\n                    const pp = points[p];\n                    if (pp !== 5 && pp !== 10) {\n                        type = pp;\n                        points[p] = 0;\n                    } else {\n                        type = pp & 0x33 * type >> 4;\n                        points[p] &= type >> 2 | type << 2;\n                    }\n                    path.lineTo(p % width1, p / width1 | 0);\n                    if (!points[p]) {\n                        --count;\n                    }\n                }while (p0 !== p);\n                --i;\n            }\n            data = null;\n            points = null;\n            const drawOutline = function(c) {\n                c.save();\n                c.scale(1 / width, -1 / height);\n                c.translate(0, -height);\n                c.fill(path);\n                c.beginPath();\n                c.restore();\n            };\n            return drawOutline;\n        }\n        class CanvasExtraState {\n            constructor(width, height){\n                this.alphaIsShape = false;\n                this.fontSize = 0;\n                this.fontSizeScale = 1;\n                this.textMatrix = util.IDENTITY_MATRIX;\n                this.textMatrixScale = 1;\n                this.fontMatrix = util.FONT_IDENTITY_MATRIX;\n                this.leading = 0;\n                this.x = 0;\n                this.y = 0;\n                this.lineX = 0;\n                this.lineY = 0;\n                this.charSpacing = 0;\n                this.wordSpacing = 0;\n                this.textHScale = 1;\n                this.textRenderingMode = util.TextRenderingMode.FILL;\n                this.textRise = 0;\n                this.fillColor = \"#000000\";\n                this.strokeColor = \"#000000\";\n                this.patternFill = false;\n                this.fillAlpha = 1;\n                this.strokeAlpha = 1;\n                this.lineWidth = 1;\n                this.activeSMask = null;\n                this.transferMaps = \"none\";\n                this.startNewPathAndClipBox([\n                    0,\n                    0,\n                    width,\n                    height\n                ]);\n            }\n            clone() {\n                const clone = Object.create(this);\n                clone.clipBox = this.clipBox.slice();\n                return clone;\n            }\n            setCurrentPoint(x, y) {\n                this.x = x;\n                this.y = y;\n            }\n            updatePathMinMax(transform, x, y) {\n                [x, y] = util.Util.applyTransform([\n                    x,\n                    y\n                ], transform);\n                this.minX = Math.min(this.minX, x);\n                this.minY = Math.min(this.minY, y);\n                this.maxX = Math.max(this.maxX, x);\n                this.maxY = Math.max(this.maxY, y);\n            }\n            updateRectMinMax(transform, rect) {\n                const p1 = util.Util.applyTransform(rect, transform);\n                const p2 = util.Util.applyTransform(rect.slice(2), transform);\n                const p3 = util.Util.applyTransform([\n                    rect[0],\n                    rect[3]\n                ], transform);\n                const p4 = util.Util.applyTransform([\n                    rect[2],\n                    rect[1]\n                ], transform);\n                this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);\n                this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);\n                this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);\n                this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);\n            }\n            updateScalingPathMinMax(transform, minMax) {\n                util.Util.scaleMinMax(transform, minMax);\n                this.minX = Math.min(this.minX, minMax[0]);\n                this.maxX = Math.max(this.maxX, minMax[1]);\n                this.minY = Math.min(this.minY, minMax[2]);\n                this.maxY = Math.max(this.maxY, minMax[3]);\n            }\n            updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n                const box = util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n                if (minMax) {\n                    minMax[0] = Math.min(minMax[0], box[0], box[2]);\n                    minMax[1] = Math.max(minMax[1], box[0], box[2]);\n                    minMax[2] = Math.min(minMax[2], box[1], box[3]);\n                    minMax[3] = Math.max(minMax[3], box[1], box[3]);\n                    return;\n                }\n                this.updateRectMinMax(transform, box);\n            }\n            getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n                const box = [\n                    this.minX,\n                    this.minY,\n                    this.maxX,\n                    this.maxY\n                ];\n                if (pathType === PathType.STROKE) {\n                    if (!transform) {\n                        (0, util.unreachable)(\"Stroke bounding box must include transform.\");\n                    }\n                    const scale = util.Util.singularValueDecompose2dScale(transform);\n                    const xStrokePad = scale[0] * this.lineWidth / 2;\n                    const yStrokePad = scale[1] * this.lineWidth / 2;\n                    box[0] -= xStrokePad;\n                    box[1] -= yStrokePad;\n                    box[2] += xStrokePad;\n                    box[3] += yStrokePad;\n                }\n                return box;\n            }\n            updateClipFromPath() {\n                const intersect = util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n                this.startNewPathAndClipBox(intersect || [\n                    0,\n                    0,\n                    0,\n                    0\n                ]);\n            }\n            isEmptyClip() {\n                return this.minX === Infinity;\n            }\n            startNewPathAndClipBox(box) {\n                this.clipBox = box;\n                this.minX = Infinity;\n                this.minY = Infinity;\n                this.maxX = 0;\n                this.maxY = 0;\n            }\n            getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n                return util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n            }\n        }\n        function putBinaryImageData(ctx, imgData) {\n            if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n                ctx.putImageData(imgData, 0, 0);\n                return;\n            }\n            const height = imgData.height, width = imgData.width;\n            const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n            const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n            const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n            const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n            let srcPos = 0, destPos;\n            const src = imgData.data;\n            const dest = chunkImgData.data;\n            let i, j, thisChunkHeight, elemsInThisChunk;\n            if (imgData.kind === util.ImageKind.GRAYSCALE_1BPP) {\n                const srcLength = src.byteLength;\n                const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n                const dest32DataLength = dest32.length;\n                const fullSrcDiff = width + 7 >> 3;\n                const white = 0xffffffff;\n                const black = util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                for(i = 0; i < totalChunks; i++){\n                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                    destPos = 0;\n                    for(j = 0; j < thisChunkHeight; j++){\n                        const srcDiff = srcLength - srcPos;\n                        let k = 0;\n                        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                        const kEndUnrolled = kEnd & ~7;\n                        let mask = 0;\n                        let srcByte = 0;\n                        for(; k < kEndUnrolled; k += 8){\n                            srcByte = src[srcPos++];\n                            dest32[destPos++] = srcByte & 128 ? white : black;\n                            dest32[destPos++] = srcByte & 64 ? white : black;\n                            dest32[destPos++] = srcByte & 32 ? white : black;\n                            dest32[destPos++] = srcByte & 16 ? white : black;\n                            dest32[destPos++] = srcByte & 8 ? white : black;\n                            dest32[destPos++] = srcByte & 4 ? white : black;\n                            dest32[destPos++] = srcByte & 2 ? white : black;\n                            dest32[destPos++] = srcByte & 1 ? white : black;\n                        }\n                        for(; k < kEnd; k++){\n                            if (mask === 0) {\n                                srcByte = src[srcPos++];\n                                mask = 128;\n                            }\n                            dest32[destPos++] = srcByte & mask ? white : black;\n                            mask >>= 1;\n                        }\n                    }\n                    while(destPos < dest32DataLength){\n                        dest32[destPos++] = 0;\n                    }\n                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                }\n            } else if (imgData.kind === util.ImageKind.RGBA_32BPP) {\n                j = 0;\n                elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n                for(i = 0; i < fullChunks; i++){\n                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                    srcPos += elemsInThisChunk;\n                    ctx.putImageData(chunkImgData, 0, j);\n                    j += FULL_CHUNK_HEIGHT;\n                }\n                if (i < totalChunks) {\n                    elemsInThisChunk = width * partialChunkHeight * 4;\n                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                    ctx.putImageData(chunkImgData, 0, j);\n                }\n            } else if (imgData.kind === util.ImageKind.RGB_24BPP) {\n                thisChunkHeight = FULL_CHUNK_HEIGHT;\n                elemsInThisChunk = width * thisChunkHeight;\n                for(i = 0; i < totalChunks; i++){\n                    if (i >= fullChunks) {\n                        thisChunkHeight = partialChunkHeight;\n                        elemsInThisChunk = width * thisChunkHeight;\n                    }\n                    destPos = 0;\n                    for(j = elemsInThisChunk; j--;){\n                        dest[destPos++] = src[srcPos++];\n                        dest[destPos++] = src[srcPos++];\n                        dest[destPos++] = src[srcPos++];\n                        dest[destPos++] = 255;\n                    }\n                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                }\n            } else {\n                throw new Error(`bad image kind: ${imgData.kind}`);\n            }\n        }\n        function putBinaryImageMask(ctx, imgData) {\n            if (imgData.bitmap) {\n                ctx.drawImage(imgData.bitmap, 0, 0);\n                return;\n            }\n            const height = imgData.height, width = imgData.width;\n            const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n            const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n            const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n            const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n            let srcPos = 0;\n            const src = imgData.data;\n            const dest = chunkImgData.data;\n            for(let i = 0; i < totalChunks; i++){\n                const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                ({ srcPos } = convertBlackAndWhiteToRGBA({\n                    src,\n                    srcPos,\n                    dest,\n                    width,\n                    height: thisChunkHeight,\n                    nonBlackColor: 0\n                }));\n                ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n            }\n        }\n        function copyCtxState(sourceCtx, destCtx) {\n            const properties = [\n                \"strokeStyle\",\n                \"fillStyle\",\n                \"fillRule\",\n                \"globalAlpha\",\n                \"lineWidth\",\n                \"lineCap\",\n                \"lineJoin\",\n                \"miterLimit\",\n                \"globalCompositeOperation\",\n                \"font\",\n                \"filter\"\n            ];\n            for (const property of properties){\n                if (sourceCtx[property] !== undefined) {\n                    destCtx[property] = sourceCtx[property];\n                }\n            }\n            if (sourceCtx.setLineDash !== undefined) {\n                destCtx.setLineDash(sourceCtx.getLineDash());\n                destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n            }\n        }\n        function resetCtxToDefault(ctx) {\n            ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n            ctx.fillRule = \"nonzero\";\n            ctx.globalAlpha = 1;\n            ctx.lineWidth = 1;\n            ctx.lineCap = \"butt\";\n            ctx.lineJoin = \"miter\";\n            ctx.miterLimit = 10;\n            ctx.globalCompositeOperation = \"source-over\";\n            ctx.font = \"10px sans-serif\";\n            if (ctx.setLineDash !== undefined) {\n                ctx.setLineDash([]);\n                ctx.lineDashOffset = 0;\n            }\n            if (!util.isNodeJS) {\n                const { filter } = ctx;\n                if (filter !== \"none\" && filter !== \"\") {\n                    ctx.filter = \"none\";\n                }\n            }\n        }\n        function composeSMaskBackdrop(bytes, r0, g0, b0) {\n            const length = bytes.length;\n            for(let i = 3; i < length; i += 4){\n                const alpha = bytes[i];\n                if (alpha === 0) {\n                    bytes[i - 3] = r0;\n                    bytes[i - 2] = g0;\n                    bytes[i - 1] = b0;\n                } else if (alpha < 255) {\n                    const alpha_ = 255 - alpha;\n                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n                }\n            }\n        }\n        function composeSMaskAlpha(maskData, layerData, transferMap) {\n            const length = maskData.length;\n            const scale = 1 / 255;\n            for(let i = 3; i < length; i += 4){\n                const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n                layerData[i] = layerData[i] * alpha * scale | 0;\n            }\n        }\n        function composeSMaskLuminosity(maskData, layerData, transferMap) {\n            const length = maskData.length;\n            for(let i = 3; i < length; i += 4){\n                const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n                layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n            }\n        }\n        function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n            const hasBackdrop = !!backdrop;\n            const r0 = hasBackdrop ? backdrop[0] : 0;\n            const g0 = hasBackdrop ? backdrop[1] : 0;\n            const b0 = hasBackdrop ? backdrop[2] : 0;\n            const composeFn = subtype === \"Luminosity\" ? composeSMaskLuminosity : composeSMaskAlpha;\n            const PIXELS_TO_PROCESS = 1048576;\n            const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n            for(let row = 0; row < height; row += chunkSize){\n                const chunkHeight = Math.min(chunkSize, height - row);\n                const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n                const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n                if (hasBackdrop) {\n                    composeSMaskBackdrop(maskData.data, r0, g0, b0);\n                }\n                composeFn(maskData.data, layerData.data, transferMap);\n                layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n            }\n        }\n        function composeSMask(ctx, smask, layerCtx, layerBox) {\n            const layerOffsetX = layerBox[0];\n            const layerOffsetY = layerBox[1];\n            const layerWidth = layerBox[2] - layerOffsetX;\n            const layerHeight = layerBox[3] - layerOffsetY;\n            if (layerWidth === 0 || layerHeight === 0) {\n                return;\n            }\n            genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n            ctx.save();\n            ctx.globalAlpha = 1;\n            ctx.globalCompositeOperation = \"source-over\";\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.drawImage(layerCtx.canvas, 0, 0);\n            ctx.restore();\n        }\n        function getImageSmoothingEnabled(transform, interpolate) {\n            const scale = util.Util.singularValueDecompose2dScale(transform);\n            scale[0] = Math.fround(scale[0]);\n            scale[1] = Math.fround(scale[1]);\n            const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n            if (interpolate !== undefined) {\n                return interpolate;\n            } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n                return true;\n            }\n            return false;\n        }\n        const LINE_CAP_STYLES = [\n            \"butt\",\n            \"round\",\n            \"square\"\n        ];\n        const LINE_JOIN_STYLES = [\n            \"miter\",\n            \"round\",\n            \"bevel\"\n        ];\n        const NORMAL_CLIP = {};\n        const EO_CLIP = {};\n        class CanvasGraphics {\n            constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n                this.ctx = canvasCtx;\n                this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                this.stateStack = [];\n                this.pendingClip = null;\n                this.pendingEOFill = false;\n                this.res = null;\n                this.xobjs = null;\n                this.commonObjs = commonObjs;\n                this.objs = objs;\n                this.canvasFactory = canvasFactory;\n                this.filterFactory = filterFactory;\n                this.groupStack = [];\n                this.processingType3 = null;\n                this.baseTransform = null;\n                this.baseTransformStack = [];\n                this.groupLevel = 0;\n                this.smaskStack = [];\n                this.smaskCounter = 0;\n                this.tempSMask = null;\n                this.suspendedCtx = null;\n                this.contentVisible = true;\n                this.markedContentStack = markedContentStack || [];\n                this.optionalContentConfig = optionalContentConfig;\n                this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n                this.cachedPatterns = new Map();\n                this.annotationCanvasMap = annotationCanvasMap;\n                this.viewportScale = 1;\n                this.outputScaleX = 1;\n                this.outputScaleY = 1;\n                this.pageColors = pageColors;\n                this._cachedScaleForStroking = [\n                    -1,\n                    0\n                ];\n                this._cachedGetSinglePixelWidth = null;\n                this._cachedBitmapsMap = new Map();\n            }\n            getObject(data, fallback = null) {\n                if (typeof data === \"string\") {\n                    return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                }\n                return fallback;\n            }\n            beginDrawing({ transform, viewport, transparency = false, background = null }) {\n                const width = this.ctx.canvas.width;\n                const height = this.ctx.canvas.height;\n                const savedFillStyle = this.ctx.fillStyle;\n                this.ctx.fillStyle = background || \"#ffffff\";\n                this.ctx.fillRect(0, 0, width, height);\n                this.ctx.fillStyle = savedFillStyle;\n                if (transparency) {\n                    const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n                    this.compositeCtx = this.ctx;\n                    this.transparentCanvas = transparentCanvas.canvas;\n                    this.ctx = transparentCanvas.context;\n                    this.ctx.save();\n                    this.ctx.transform(...(0, display_utils.getCurrentTransform)(this.compositeCtx));\n                }\n                this.ctx.save();\n                resetCtxToDefault(this.ctx);\n                if (transform) {\n                    this.ctx.transform(...transform);\n                    this.outputScaleX = transform[0];\n                    this.outputScaleY = transform[0];\n                }\n                this.ctx.transform(...viewport.transform);\n                this.viewportScale = viewport.scale;\n                this.baseTransform = (0, display_utils.getCurrentTransform)(this.ctx);\n            }\n            executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n                const argsArray = operatorList.argsArray;\n                const fnArray = operatorList.fnArray;\n                let i = executionStartIdx || 0;\n                const argsArrayLen = argsArray.length;\n                if (argsArrayLen === i) {\n                    return i;\n                }\n                const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n                const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n                let steps = 0;\n                const commonObjs = this.commonObjs;\n                const objs = this.objs;\n                let fnId;\n                while(true){\n                    if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                        stepper.breakIt(i, continueCallback);\n                        return i;\n                    }\n                    fnId = fnArray[i];\n                    if (fnId !== util.OPS.dependency) {\n                        this[fnId].apply(this, argsArray[i]);\n                    } else {\n                        for (const depObjId of argsArray[i]){\n                            const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                            if (!objsPool.has(depObjId)) {\n                                objsPool.get(depObjId, continueCallback);\n                                return i;\n                            }\n                        }\n                    }\n                    i++;\n                    if (i === argsArrayLen) {\n                        return i;\n                    }\n                    if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                        if (Date.now() > endTime) {\n                            continueCallback();\n                            return i;\n                        }\n                        steps = 0;\n                    }\n                }\n            }\n            #restoreInitialState() {\n                while(this.stateStack.length || this.inSMaskMode){\n                    this.restore();\n                }\n                this.ctx.restore();\n                if (this.transparentCanvas) {\n                    this.ctx = this.compositeCtx;\n                    this.ctx.save();\n                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                    this.ctx.drawImage(this.transparentCanvas, 0, 0);\n                    this.ctx.restore();\n                    this.transparentCanvas = null;\n                }\n            }\n            endDrawing() {\n                this.#restoreInitialState();\n                this.cachedCanvases.clear();\n                this.cachedPatterns.clear();\n                for (const cache of this._cachedBitmapsMap.values()){\n                    for (const canvas of cache.values()){\n                        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                            canvas.width = canvas.height = 0;\n                        }\n                    }\n                    cache.clear();\n                }\n                this._cachedBitmapsMap.clear();\n                this.#drawFilter();\n            }\n            #drawFilter() {\n                if (this.pageColors) {\n                    const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n                    if (hcmFilterId !== \"none\") {\n                        const savedFilter = this.ctx.filter;\n                        this.ctx.filter = hcmFilterId;\n                        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                        this.ctx.filter = savedFilter;\n                    }\n                }\n            }\n            _scaleImage(img, inverseTransform) {\n                const width = img.width;\n                const height = img.height;\n                let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n                let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n                let paintWidth = width, paintHeight = height;\n                let tmpCanvasId = \"prescale1\";\n                let tmpCanvas, tmpCtx;\n                while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n                    let newWidth = paintWidth, newHeight = paintHeight;\n                    if (widthScale > 2 && paintWidth > 1) {\n                        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                        widthScale /= paintWidth / newWidth;\n                    }\n                    if (heightScale > 2 && paintHeight > 1) {\n                        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                        heightScale /= paintHeight / newHeight;\n                    }\n                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n                    tmpCtx = tmpCanvas.context;\n                    tmpCtx.clearRect(0, 0, newWidth, newHeight);\n                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n                    img = tmpCanvas.canvas;\n                    paintWidth = newWidth;\n                    paintHeight = newHeight;\n                    tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n                }\n                return {\n                    img,\n                    paintWidth,\n                    paintHeight\n                };\n            }\n            _createMaskCanvas(img) {\n                const ctx = this.ctx;\n                const { width, height } = img;\n                const fillColor = this.current.fillColor;\n                const isPatternFill = this.current.patternFill;\n                const currentTransform = (0, display_utils.getCurrentTransform)(ctx);\n                let cache, cacheKey, scaled, maskCanvas;\n                if ((img.bitmap || img.data) && img.count > 1) {\n                    const mainKey = img.bitmap || img.data.buffer;\n                    cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                        currentTransform.slice(0, 4),\n                        fillColor\n                    ]);\n                    cache = this._cachedBitmapsMap.get(mainKey);\n                    if (!cache) {\n                        cache = new Map();\n                        this._cachedBitmapsMap.set(mainKey, cache);\n                    }\n                    const cachedImage = cache.get(cacheKey);\n                    if (cachedImage && !isPatternFill) {\n                        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                        return {\n                            canvas: cachedImage,\n                            offsetX,\n                            offsetY\n                        };\n                    }\n                    scaled = cachedImage;\n                }\n                if (!scaled) {\n                    maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                    putBinaryImageMask(maskCanvas.context, img);\n                }\n                let maskToCanvas = util.Util.transform(currentTransform, [\n                    1 / width,\n                    0,\n                    0,\n                    -1 / height,\n                    0,\n                    0\n                ]);\n                maskToCanvas = util.Util.transform(maskToCanvas, [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    -height\n                ]);\n                const [minX, minY, maxX, maxY] = util.Util.getAxialAlignedBoundingBox([\n                    0,\n                    0,\n                    width,\n                    height\n                ], maskToCanvas);\n                const drawnWidth = Math.round(maxX - minX) || 1;\n                const drawnHeight = Math.round(maxY - minY) || 1;\n                const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n                const fillCtx = fillCanvas.context;\n                const offsetX = minX;\n                const offsetY = minY;\n                fillCtx.translate(-offsetX, -offsetY);\n                fillCtx.transform(...maskToCanvas);\n                if (!scaled) {\n                    scaled = this._scaleImage(maskCanvas.canvas, (0, display_utils.getCurrentTransformInverse)(fillCtx));\n                    scaled = scaled.img;\n                    if (cache && isPatternFill) {\n                        cache.set(cacheKey, scaled);\n                    }\n                }\n                fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n                drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n                fillCtx.globalCompositeOperation = \"source-in\";\n                const inverse = util.Util.transform((0, display_utils.getCurrentTransformInverse)(fillCtx), [\n                    1,\n                    0,\n                    0,\n                    1,\n                    -offsetX,\n                    -offsetY\n                ]);\n                fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n                fillCtx.fillRect(0, 0, width, height);\n                if (cache && !isPatternFill) {\n                    this.cachedCanvases.delete(\"fillCanvas\");\n                    cache.set(cacheKey, fillCanvas.canvas);\n                }\n                return {\n                    canvas: fillCanvas.canvas,\n                    offsetX: Math.round(offsetX),\n                    offsetY: Math.round(offsetY)\n                };\n            }\n            setLineWidth(width) {\n                if (width !== this.current.lineWidth) {\n                    this._cachedScaleForStroking[0] = -1;\n                }\n                this.current.lineWidth = width;\n                this.ctx.lineWidth = width;\n            }\n            setLineCap(style) {\n                this.ctx.lineCap = LINE_CAP_STYLES[style];\n            }\n            setLineJoin(style) {\n                this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n            }\n            setMiterLimit(limit) {\n                this.ctx.miterLimit = limit;\n            }\n            setDash(dashArray, dashPhase) {\n                const ctx = this.ctx;\n                if (ctx.setLineDash !== undefined) {\n                    ctx.setLineDash(dashArray);\n                    ctx.lineDashOffset = dashPhase;\n                }\n            }\n            setRenderingIntent(intent) {}\n            setFlatness(flatness) {}\n            setGState(states) {\n                for (const [key, value] of states){\n                    switch(key){\n                        case \"LW\":\n                            this.setLineWidth(value);\n                            break;\n                        case \"LC\":\n                            this.setLineCap(value);\n                            break;\n                        case \"LJ\":\n                            this.setLineJoin(value);\n                            break;\n                        case \"ML\":\n                            this.setMiterLimit(value);\n                            break;\n                        case \"D\":\n                            this.setDash(value[0], value[1]);\n                            break;\n                        case \"RI\":\n                            this.setRenderingIntent(value);\n                            break;\n                        case \"FL\":\n                            this.setFlatness(value);\n                            break;\n                        case \"Font\":\n                            this.setFont(value[0], value[1]);\n                            break;\n                        case \"CA\":\n                            this.current.strokeAlpha = value;\n                            break;\n                        case \"ca\":\n                            this.current.fillAlpha = value;\n                            this.ctx.globalAlpha = value;\n                            break;\n                        case \"BM\":\n                            this.ctx.globalCompositeOperation = value;\n                            break;\n                        case \"SMask\":\n                            this.current.activeSMask = value ? this.tempSMask : null;\n                            this.tempSMask = null;\n                            this.checkSMaskState();\n                            break;\n                        case \"TR\":\n                            this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                            break;\n                    }\n                }\n            }\n            get inSMaskMode() {\n                return !!this.suspendedCtx;\n            }\n            checkSMaskState() {\n                const inSMaskMode = this.inSMaskMode;\n                if (this.current.activeSMask && !inSMaskMode) {\n                    this.beginSMaskMode();\n                } else if (!this.current.activeSMask && inSMaskMode) {\n                    this.endSMaskMode();\n                }\n            }\n            beginSMaskMode() {\n                if (this.inSMaskMode) {\n                    throw new Error(\"beginSMaskMode called while already in smask mode\");\n                }\n                const drawnWidth = this.ctx.canvas.width;\n                const drawnHeight = this.ctx.canvas.height;\n                const cacheId = \"smaskGroupAt\" + this.groupLevel;\n                const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                this.suspendedCtx = this.ctx;\n                this.ctx = scratchCanvas.context;\n                const ctx = this.ctx;\n                ctx.setTransform(...(0, display_utils.getCurrentTransform)(this.suspendedCtx));\n                copyCtxState(this.suspendedCtx, ctx);\n                mirrorContextOperations(ctx, this.suspendedCtx);\n                this.setGState([\n                    [\n                        \"BM\",\n                        \"source-over\"\n                    ],\n                    [\n                        \"ca\",\n                        1\n                    ],\n                    [\n                        \"CA\",\n                        1\n                    ]\n                ]);\n            }\n            endSMaskMode() {\n                if (!this.inSMaskMode) {\n                    throw new Error(\"endSMaskMode called while not in smask mode\");\n                }\n                this.ctx._removeMirroring();\n                copyCtxState(this.ctx, this.suspendedCtx);\n                this.ctx = this.suspendedCtx;\n                this.suspendedCtx = null;\n            }\n            compose(dirtyBox) {\n                if (!this.current.activeSMask) {\n                    return;\n                }\n                if (!dirtyBox) {\n                    dirtyBox = [\n                        0,\n                        0,\n                        this.ctx.canvas.width,\n                        this.ctx.canvas.height\n                    ];\n                } else {\n                    dirtyBox[0] = Math.floor(dirtyBox[0]);\n                    dirtyBox[1] = Math.floor(dirtyBox[1]);\n                    dirtyBox[2] = Math.ceil(dirtyBox[2]);\n                    dirtyBox[3] = Math.ceil(dirtyBox[3]);\n                }\n                const smask = this.current.activeSMask;\n                const suspendedCtx = this.suspendedCtx;\n                composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n                this.ctx.save();\n                this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n                this.ctx.restore();\n            }\n            save() {\n                if (this.inSMaskMode) {\n                    copyCtxState(this.ctx, this.suspendedCtx);\n                    this.suspendedCtx.save();\n                } else {\n                    this.ctx.save();\n                }\n                const old = this.current;\n                this.stateStack.push(old);\n                this.current = old.clone();\n            }\n            restore() {\n                if (this.stateStack.length === 0 && this.inSMaskMode) {\n                    this.endSMaskMode();\n                }\n                if (this.stateStack.length !== 0) {\n                    this.current = this.stateStack.pop();\n                    if (this.inSMaskMode) {\n                        this.suspendedCtx.restore();\n                        copyCtxState(this.suspendedCtx, this.ctx);\n                    } else {\n                        this.ctx.restore();\n                    }\n                    this.checkSMaskState();\n                    this.pendingClip = null;\n                    this._cachedScaleForStroking[0] = -1;\n                    this._cachedGetSinglePixelWidth = null;\n                }\n            }\n            transform(a, b, c, d, e, f) {\n                this.ctx.transform(a, b, c, d, e, f);\n                this._cachedScaleForStroking[0] = -1;\n                this._cachedGetSinglePixelWidth = null;\n            }\n            constructPath(ops, args, minMax) {\n                const ctx = this.ctx;\n                const current = this.current;\n                let x = current.x, y = current.y;\n                let startX, startY;\n                const currentTransform = (0, display_utils.getCurrentTransform)(ctx);\n                const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n                const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n                for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n                    switch(ops[i] | 0){\n                        case util.OPS.rectangle:\n                            x = args[j++];\n                            y = args[j++];\n                            const width = args[j++];\n                            const height = args[j++];\n                            const xw = x + width;\n                            const yh = y + height;\n                            ctx.moveTo(x, y);\n                            if (width === 0 || height === 0) {\n                                ctx.lineTo(xw, yh);\n                            } else {\n                                ctx.lineTo(xw, y);\n                                ctx.lineTo(xw, yh);\n                                ctx.lineTo(x, yh);\n                            }\n                            if (!isScalingMatrix) {\n                                current.updateRectMinMax(currentTransform, [\n                                    x,\n                                    y,\n                                    xw,\n                                    yh\n                                ]);\n                            }\n                            ctx.closePath();\n                            break;\n                        case util.OPS.moveTo:\n                            x = args[j++];\n                            y = args[j++];\n                            ctx.moveTo(x, y);\n                            if (!isScalingMatrix) {\n                                current.updatePathMinMax(currentTransform, x, y);\n                            }\n                            break;\n                        case util.OPS.lineTo:\n                            x = args[j++];\n                            y = args[j++];\n                            ctx.lineTo(x, y);\n                            if (!isScalingMatrix) {\n                                current.updatePathMinMax(currentTransform, x, y);\n                            }\n                            break;\n                        case util.OPS.curveTo:\n                            startX = x;\n                            startY = y;\n                            x = args[j + 4];\n                            y = args[j + 5];\n                            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                            current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                            j += 6;\n                            break;\n                        case util.OPS.curveTo2:\n                            startX = x;\n                            startY = y;\n                            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                            current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                            x = args[j + 2];\n                            y = args[j + 3];\n                            j += 4;\n                            break;\n                        case util.OPS.curveTo3:\n                            startX = x;\n                            startY = y;\n                            x = args[j + 2];\n                            y = args[j + 3];\n                            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                            current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                            j += 4;\n                            break;\n                        case util.OPS.closePath:\n                            ctx.closePath();\n                            break;\n                    }\n                }\n                if (isScalingMatrix) {\n                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n                }\n                current.setCurrentPoint(x, y);\n            }\n            closePath() {\n                this.ctx.closePath();\n            }\n            stroke(consumePath = true) {\n                const ctx = this.ctx;\n                const strokeColor = this.current.strokeColor;\n                ctx.globalAlpha = this.current.strokeAlpha;\n                if (this.contentVisible) {\n                    if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                        ctx.save();\n                        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, display_utils.getCurrentTransformInverse)(ctx), PathType.STROKE);\n                        this.rescaleAndStroke(false);\n                        ctx.restore();\n                    } else {\n                        this.rescaleAndStroke(true);\n                    }\n                }\n                if (consumePath) {\n                    this.consumePath(this.current.getClippedPathBoundingBox());\n                }\n                ctx.globalAlpha = this.current.fillAlpha;\n            }\n            closeStroke() {\n                this.closePath();\n                this.stroke();\n            }\n            fill(consumePath = true) {\n                const ctx = this.ctx;\n                const fillColor = this.current.fillColor;\n                const isPatternFill = this.current.patternFill;\n                let needRestore = false;\n                if (isPatternFill) {\n                    ctx.save();\n                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, display_utils.getCurrentTransformInverse)(ctx), PathType.FILL);\n                    needRestore = true;\n                }\n                const intersect = this.current.getClippedPathBoundingBox();\n                if (this.contentVisible && intersect !== null) {\n                    if (this.pendingEOFill) {\n                        ctx.fill(\"evenodd\");\n                        this.pendingEOFill = false;\n                    } else {\n                        ctx.fill();\n                    }\n                }\n                if (needRestore) {\n                    ctx.restore();\n                }\n                if (consumePath) {\n                    this.consumePath(intersect);\n                }\n            }\n            eoFill() {\n                this.pendingEOFill = true;\n                this.fill();\n            }\n            fillStroke() {\n                this.fill(false);\n                this.stroke(false);\n                this.consumePath();\n            }\n            eoFillStroke() {\n                this.pendingEOFill = true;\n                this.fillStroke();\n            }\n            closeFillStroke() {\n                this.closePath();\n                this.fillStroke();\n            }\n            closeEOFillStroke() {\n                this.pendingEOFill = true;\n                this.closePath();\n                this.fillStroke();\n            }\n            endPath() {\n                this.consumePath();\n            }\n            clip() {\n                this.pendingClip = NORMAL_CLIP;\n            }\n            eoClip() {\n                this.pendingClip = EO_CLIP;\n            }\n            beginText() {\n                this.current.textMatrix = util.IDENTITY_MATRIX;\n                this.current.textMatrixScale = 1;\n                this.current.x = this.current.lineX = 0;\n                this.current.y = this.current.lineY = 0;\n            }\n            endText() {\n                const paths = this.pendingTextPaths;\n                const ctx = this.ctx;\n                if (paths === undefined) {\n                    ctx.beginPath();\n                    return;\n                }\n                ctx.save();\n                ctx.beginPath();\n                for (const path of paths){\n                    ctx.setTransform(...path.transform);\n                    ctx.translate(path.x, path.y);\n                    path.addToPath(ctx, path.fontSize);\n                }\n                ctx.restore();\n                ctx.clip();\n                ctx.beginPath();\n                delete this.pendingTextPaths;\n            }\n            setCharSpacing(spacing) {\n                this.current.charSpacing = spacing;\n            }\n            setWordSpacing(spacing) {\n                this.current.wordSpacing = spacing;\n            }\n            setHScale(scale) {\n                this.current.textHScale = scale / 100;\n            }\n            setLeading(leading) {\n                this.current.leading = -leading;\n            }\n            setFont(fontRefName, size) {\n                const fontObj = this.commonObjs.get(fontRefName);\n                const current = this.current;\n                if (!fontObj) {\n                    throw new Error(`Can't find font for ${fontRefName}`);\n                }\n                current.fontMatrix = fontObj.fontMatrix || util.FONT_IDENTITY_MATRIX;\n                if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n                    (0, util.warn)(\"Invalid font matrix for font \" + fontRefName);\n                }\n                if (size < 0) {\n                    size = -size;\n                    current.fontDirection = -1;\n                } else {\n                    current.fontDirection = 1;\n                }\n                this.current.font = fontObj;\n                this.current.fontSize = size;\n                if (fontObj.isType3Font) {\n                    return;\n                }\n                const name = fontObj.loadedName || \"sans-serif\";\n                const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n                let bold = \"normal\";\n                if (fontObj.black) {\n                    bold = \"900\";\n                } else if (fontObj.bold) {\n                    bold = \"bold\";\n                }\n                const italic = fontObj.italic ? \"italic\" : \"normal\";\n                let browserFontSize = size;\n                if (size < MIN_FONT_SIZE) {\n                    browserFontSize = MIN_FONT_SIZE;\n                } else if (size > MAX_FONT_SIZE) {\n                    browserFontSize = MAX_FONT_SIZE;\n                }\n                this.current.fontSizeScale = size / browserFontSize;\n                this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n            }\n            setTextRenderingMode(mode) {\n                this.current.textRenderingMode = mode;\n            }\n            setTextRise(rise) {\n                this.current.textRise = rise;\n            }\n            moveText(x, y) {\n                this.current.x = this.current.lineX += x;\n                this.current.y = this.current.lineY += y;\n            }\n            setLeadingMoveText(x, y) {\n                this.setLeading(-y);\n                this.moveText(x, y);\n            }\n            setTextMatrix(a, b, c, d, e, f) {\n                this.current.textMatrix = [\n                    a,\n                    b,\n                    c,\n                    d,\n                    e,\n                    f\n                ];\n                this.current.textMatrixScale = Math.hypot(a, b);\n                this.current.x = this.current.lineX = 0;\n                this.current.y = this.current.lineY = 0;\n            }\n            nextLine() {\n                this.moveText(0, this.current.leading);\n            }\n            paintChar(character, x, y, patternTransform) {\n                const ctx = this.ctx;\n                const current = this.current;\n                const font = current.font;\n                const textRenderingMode = current.textRenderingMode;\n                const fontSize = current.fontSize / current.fontSizeScale;\n                const fillStrokeMode = textRenderingMode & util.TextRenderingMode.FILL_STROKE_MASK;\n                const isAddToPathSet = !!(textRenderingMode & util.TextRenderingMode.ADD_TO_PATH_FLAG);\n                const patternFill = current.patternFill && !font.missingFile;\n                let addToPath;\n                if (font.disableFontFace || isAddToPathSet || patternFill) {\n                    addToPath = font.getPathGenerator(this.commonObjs, character);\n                }\n                if (font.disableFontFace || patternFill) {\n                    ctx.save();\n                    ctx.translate(x, y);\n                    ctx.beginPath();\n                    addToPath(ctx, fontSize);\n                    if (patternTransform) {\n                        ctx.setTransform(...patternTransform);\n                    }\n                    if (fillStrokeMode === util.TextRenderingMode.FILL || fillStrokeMode === util.TextRenderingMode.FILL_STROKE) {\n                        ctx.fill();\n                    }\n                    if (fillStrokeMode === util.TextRenderingMode.STROKE || fillStrokeMode === util.TextRenderingMode.FILL_STROKE) {\n                        ctx.stroke();\n                    }\n                    ctx.restore();\n                } else {\n                    if (fillStrokeMode === util.TextRenderingMode.FILL || fillStrokeMode === util.TextRenderingMode.FILL_STROKE) {\n                        ctx.fillText(character, x, y);\n                    }\n                    if (fillStrokeMode === util.TextRenderingMode.STROKE || fillStrokeMode === util.TextRenderingMode.FILL_STROKE) {\n                        ctx.strokeText(character, x, y);\n                    }\n                }\n                if (isAddToPathSet) {\n                    const paths = this.pendingTextPaths ||= [];\n                    paths.push({\n                        transform: (0, display_utils.getCurrentTransform)(ctx),\n                        x,\n                        y,\n                        fontSize,\n                        addToPath\n                    });\n                }\n            }\n            get isFontSubpixelAAEnabled() {\n                const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n                ctx.scale(1.5, 1);\n                ctx.fillText(\"I\", 0, 10);\n                const data = ctx.getImageData(0, 0, 10, 10).data;\n                let enabled = false;\n                for(let i = 3; i < data.length; i += 4){\n                    if (data[i] > 0 && data[i] < 255) {\n                        enabled = true;\n                        break;\n                    }\n                }\n                return (0, util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n            }\n            showText(glyphs) {\n                const current = this.current;\n                const font = current.font;\n                if (font.isType3Font) {\n                    return this.showType3Text(glyphs);\n                }\n                const fontSize = current.fontSize;\n                if (fontSize === 0) {\n                    return undefined;\n                }\n                const ctx = this.ctx;\n                const fontSizeScale = current.fontSizeScale;\n                const charSpacing = current.charSpacing;\n                const wordSpacing = current.wordSpacing;\n                const fontDirection = current.fontDirection;\n                const textHScale = current.textHScale * fontDirection;\n                const glyphsLength = glyphs.length;\n                const vertical = font.vertical;\n                const spacingDir = vertical ? 1 : -1;\n                const defaultVMetrics = font.defaultVMetrics;\n                const widthAdvanceScale = fontSize * current.fontMatrix[0];\n                const simpleFillText = current.textRenderingMode === util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n                ctx.save();\n                ctx.transform(...current.textMatrix);\n                ctx.translate(current.x, current.y + current.textRise);\n                if (fontDirection > 0) {\n                    ctx.scale(textHScale, -1);\n                } else {\n                    ctx.scale(textHScale, 1);\n                }\n                let patternTransform;\n                if (current.patternFill) {\n                    ctx.save();\n                    const pattern = current.fillColor.getPattern(ctx, this, (0, display_utils.getCurrentTransformInverse)(ctx), PathType.FILL);\n                    patternTransform = (0, display_utils.getCurrentTransform)(ctx);\n                    ctx.restore();\n                    ctx.fillStyle = pattern;\n                }\n                let lineWidth = current.lineWidth;\n                const scale = current.textMatrixScale;\n                if (scale === 0 || lineWidth === 0) {\n                    const fillStrokeMode = current.textRenderingMode & util.TextRenderingMode.FILL_STROKE_MASK;\n                    if (fillStrokeMode === util.TextRenderingMode.STROKE || fillStrokeMode === util.TextRenderingMode.FILL_STROKE) {\n                        lineWidth = this.getSinglePixelWidth();\n                    }\n                } else {\n                    lineWidth /= scale;\n                }\n                if (fontSizeScale !== 1.0) {\n                    ctx.scale(fontSizeScale, fontSizeScale);\n                    lineWidth /= fontSizeScale;\n                }\n                ctx.lineWidth = lineWidth;\n                if (font.isInvalidPDFjsFont) {\n                    const chars = [];\n                    let width = 0;\n                    for (const glyph of glyphs){\n                        chars.push(glyph.unicode);\n                        width += glyph.width;\n                    }\n                    ctx.fillText(chars.join(\"\"), 0, 0);\n                    current.x += width * widthAdvanceScale * textHScale;\n                    ctx.restore();\n                    this.compose();\n                    return undefined;\n                }\n                let x = 0, i;\n                for(i = 0; i < glyphsLength; ++i){\n                    const glyph = glyphs[i];\n                    if (typeof glyph === \"number\") {\n                        x += spacingDir * glyph * fontSize / 1000;\n                        continue;\n                    }\n                    let restoreNeeded = false;\n                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                    const character = glyph.fontChar;\n                    const accent = glyph.accent;\n                    let scaledX, scaledY;\n                    let width = glyph.width;\n                    if (vertical) {\n                        const vmetric = glyph.vmetric || defaultVMetrics;\n                        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                        const vy = vmetric[2] * widthAdvanceScale;\n                        width = vmetric ? -vmetric[0] : width;\n                        scaledX = vx / fontSizeScale;\n                        scaledY = (x + vy) / fontSizeScale;\n                    } else {\n                        scaledX = x / fontSizeScale;\n                        scaledY = 0;\n                    }\n                    if (font.remeasure && width > 0) {\n                        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                            const characterScaleX = width / measuredWidth;\n                            restoreNeeded = true;\n                            ctx.save();\n                            ctx.scale(characterScaleX, 1);\n                            scaledX /= characterScaleX;\n                        } else if (width !== measuredWidth) {\n                            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                        }\n                    }\n                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                        if (simpleFillText && !accent) {\n                            ctx.fillText(character, scaledX, scaledY);\n                        } else {\n                            this.paintChar(character, scaledX, scaledY, patternTransform);\n                            if (accent) {\n                                const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                                const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                                this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n                            }\n                        }\n                    }\n                    const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n                    x += charWidth;\n                    if (restoreNeeded) {\n                        ctx.restore();\n                    }\n                }\n                if (vertical) {\n                    current.y -= x;\n                } else {\n                    current.x += x * textHScale;\n                }\n                ctx.restore();\n                this.compose();\n                return undefined;\n            }\n            showType3Text(glyphs) {\n                const ctx = this.ctx;\n                const current = this.current;\n                const font = current.font;\n                const fontSize = current.fontSize;\n                const fontDirection = current.fontDirection;\n                const spacingDir = font.vertical ? 1 : -1;\n                const charSpacing = current.charSpacing;\n                const wordSpacing = current.wordSpacing;\n                const textHScale = current.textHScale * fontDirection;\n                const fontMatrix = current.fontMatrix || util.FONT_IDENTITY_MATRIX;\n                const glyphsLength = glyphs.length;\n                const isTextInvisible = current.textRenderingMode === util.TextRenderingMode.INVISIBLE;\n                let i, glyph, width, spacingLength;\n                if (isTextInvisible || fontSize === 0) {\n                    return;\n                }\n                this._cachedScaleForStroking[0] = -1;\n                this._cachedGetSinglePixelWidth = null;\n                ctx.save();\n                ctx.transform(...current.textMatrix);\n                ctx.translate(current.x, current.y);\n                ctx.scale(textHScale, fontDirection);\n                for(i = 0; i < glyphsLength; ++i){\n                    glyph = glyphs[i];\n                    if (typeof glyph === \"number\") {\n                        spacingLength = spacingDir * glyph * fontSize / 1000;\n                        this.ctx.translate(spacingLength, 0);\n                        current.x += spacingLength * textHScale;\n                        continue;\n                    }\n                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                    const operatorList = font.charProcOperatorList[glyph.operatorListId];\n                    if (!operatorList) {\n                        (0, util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                        continue;\n                    }\n                    if (this.contentVisible) {\n                        this.processingType3 = glyph;\n                        this.save();\n                        ctx.scale(fontSize, fontSize);\n                        ctx.transform(...fontMatrix);\n                        this.executeOperatorList(operatorList);\n                        this.restore();\n                    }\n                    const transformed = util.Util.applyTransform([\n                        glyph.width,\n                        0\n                    ], fontMatrix);\n                    width = transformed[0] * fontSize + spacing;\n                    ctx.translate(width, 0);\n                    current.x += width * textHScale;\n                }\n                ctx.restore();\n                this.processingType3 = null;\n            }\n            setCharWidth(xWidth, yWidth) {}\n            setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n                this.ctx.rect(llx, lly, urx - llx, ury - lly);\n                this.ctx.clip();\n                this.endPath();\n            }\n            getColorN_Pattern(IR) {\n                let pattern;\n                if (IR[0] === \"TilingPattern\") {\n                    const color = IR[1];\n                    const baseTransform = this.baseTransform || (0, display_utils.getCurrentTransform)(this.ctx);\n                    const canvasGraphicsFactory = {\n                        createCanvasGraphics: (ctx)=>{\n                            return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                                optionalContentConfig: this.optionalContentConfig,\n                                markedContentStack: this.markedContentStack\n                            });\n                        }\n                    };\n                    pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n                } else {\n                    pattern = this._getPattern(IR[1], IR[2]);\n                }\n                return pattern;\n            }\n            setStrokeColorN() {\n                this.current.strokeColor = this.getColorN_Pattern(arguments);\n            }\n            setFillColorN() {\n                this.current.fillColor = this.getColorN_Pattern(arguments);\n                this.current.patternFill = true;\n            }\n            setStrokeRGBColor(r, g, b) {\n                const color = util.Util.makeHexColor(r, g, b);\n                this.ctx.strokeStyle = color;\n                this.current.strokeColor = color;\n            }\n            setFillRGBColor(r, g, b) {\n                const color = util.Util.makeHexColor(r, g, b);\n                this.ctx.fillStyle = color;\n                this.current.fillColor = color;\n                this.current.patternFill = false;\n            }\n            _getPattern(objId, matrix = null) {\n                let pattern;\n                if (this.cachedPatterns.has(objId)) {\n                    pattern = this.cachedPatterns.get(objId);\n                } else {\n                    pattern = getShadingPattern(this.getObject(objId));\n                    this.cachedPatterns.set(objId, pattern);\n                }\n                if (matrix) {\n                    pattern.matrix = matrix;\n                }\n                return pattern;\n            }\n            shadingFill(objId) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const ctx = this.ctx;\n                this.save();\n                const pattern = this._getPattern(objId);\n                ctx.fillStyle = pattern.getPattern(ctx, this, (0, display_utils.getCurrentTransformInverse)(ctx), PathType.SHADING);\n                const inv = (0, display_utils.getCurrentTransformInverse)(ctx);\n                if (inv) {\n                    const { width, height } = ctx.canvas;\n                    const [x0, y0, x1, y1] = util.Util.getAxialAlignedBoundingBox([\n                        0,\n                        0,\n                        width,\n                        height\n                    ], inv);\n                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n                } else {\n                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n                }\n                this.compose(this.current.getClippedPathBoundingBox());\n                this.restore();\n            }\n            beginInlineImage() {\n                (0, util.unreachable)(\"Should not call beginInlineImage\");\n            }\n            beginImageData() {\n                (0, util.unreachable)(\"Should not call beginImageData\");\n            }\n            paintFormXObjectBegin(matrix, bbox) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                this.save();\n                this.baseTransformStack.push(this.baseTransform);\n                if (Array.isArray(matrix) && matrix.length === 6) {\n                    this.transform(...matrix);\n                }\n                this.baseTransform = (0, display_utils.getCurrentTransform)(this.ctx);\n                if (bbox) {\n                    const width = bbox[2] - bbox[0];\n                    const height = bbox[3] - bbox[1];\n                    this.ctx.rect(bbox[0], bbox[1], width, height);\n                    this.current.updateRectMinMax((0, display_utils.getCurrentTransform)(this.ctx), bbox);\n                    this.clip();\n                    this.endPath();\n                }\n            }\n            paintFormXObjectEnd() {\n                if (!this.contentVisible) {\n                    return;\n                }\n                this.restore();\n                this.baseTransform = this.baseTransformStack.pop();\n            }\n            beginGroup(group) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                this.save();\n                if (this.inSMaskMode) {\n                    this.endSMaskMode();\n                    this.current.activeSMask = null;\n                }\n                const currentCtx = this.ctx;\n                if (!group.isolated) {\n                    (0, util.info)(\"TODO: Support non-isolated groups.\");\n                }\n                if (group.knockout) {\n                    (0, util.warn)(\"Knockout groups not supported.\");\n                }\n                const currentTransform = (0, display_utils.getCurrentTransform)(currentCtx);\n                if (group.matrix) {\n                    currentCtx.transform(...group.matrix);\n                }\n                if (!group.bbox) {\n                    throw new Error(\"Bounding box is required.\");\n                }\n                let bounds = util.Util.getAxialAlignedBoundingBox(group.bbox, (0, display_utils.getCurrentTransform)(currentCtx));\n                const canvasBounds = [\n                    0,\n                    0,\n                    currentCtx.canvas.width,\n                    currentCtx.canvas.height\n                ];\n                bounds = util.Util.intersect(bounds, canvasBounds) || [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                const offsetX = Math.floor(bounds[0]);\n                const offsetY = Math.floor(bounds[1]);\n                let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n                let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n                let scaleX = 1, scaleY = 1;\n                if (drawnWidth > MAX_GROUP_SIZE) {\n                    scaleX = drawnWidth / MAX_GROUP_SIZE;\n                    drawnWidth = MAX_GROUP_SIZE;\n                }\n                if (drawnHeight > MAX_GROUP_SIZE) {\n                    scaleY = drawnHeight / MAX_GROUP_SIZE;\n                    drawnHeight = MAX_GROUP_SIZE;\n                }\n                this.current.startNewPathAndClipBox([\n                    0,\n                    0,\n                    drawnWidth,\n                    drawnHeight\n                ]);\n                let cacheId = \"groupAt\" + this.groupLevel;\n                if (group.smask) {\n                    cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n                }\n                const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                const groupCtx = scratchCanvas.context;\n                groupCtx.scale(1 / scaleX, 1 / scaleY);\n                groupCtx.translate(-offsetX, -offsetY);\n                groupCtx.transform(...currentTransform);\n                if (group.smask) {\n                    this.smaskStack.push({\n                        canvas: scratchCanvas.canvas,\n                        context: groupCtx,\n                        offsetX,\n                        offsetY,\n                        scaleX,\n                        scaleY,\n                        subtype: group.smask.subtype,\n                        backdrop: group.smask.backdrop,\n                        transferMap: group.smask.transferMap || null,\n                        startTransformInverse: null\n                    });\n                } else {\n                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n                    currentCtx.translate(offsetX, offsetY);\n                    currentCtx.scale(scaleX, scaleY);\n                    currentCtx.save();\n                }\n                copyCtxState(currentCtx, groupCtx);\n                this.ctx = groupCtx;\n                this.setGState([\n                    [\n                        \"BM\",\n                        \"source-over\"\n                    ],\n                    [\n                        \"ca\",\n                        1\n                    ],\n                    [\n                        \"CA\",\n                        1\n                    ]\n                ]);\n                this.groupStack.push(currentCtx);\n                this.groupLevel++;\n            }\n            endGroup(group) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                this.groupLevel--;\n                const groupCtx = this.ctx;\n                const ctx = this.groupStack.pop();\n                this.ctx = ctx;\n                this.ctx.imageSmoothingEnabled = false;\n                if (group.smask) {\n                    this.tempSMask = this.smaskStack.pop();\n                    this.restore();\n                } else {\n                    this.ctx.restore();\n                    const currentMtx = (0, display_utils.getCurrentTransform)(this.ctx);\n                    this.restore();\n                    this.ctx.save();\n                    this.ctx.setTransform(...currentMtx);\n                    const dirtyBox = util.Util.getAxialAlignedBoundingBox([\n                        0,\n                        0,\n                        groupCtx.canvas.width,\n                        groupCtx.canvas.height\n                    ], currentMtx);\n                    this.ctx.drawImage(groupCtx.canvas, 0, 0);\n                    this.ctx.restore();\n                    this.compose(dirtyBox);\n                }\n            }\n            beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n                this.#restoreInitialState();\n                resetCtxToDefault(this.ctx);\n                this.ctx.save();\n                this.save();\n                if (this.baseTransform) {\n                    this.ctx.setTransform(...this.baseTransform);\n                }\n                if (Array.isArray(rect) && rect.length === 4) {\n                    const width = rect[2] - rect[0];\n                    const height = rect[3] - rect[1];\n                    if (hasOwnCanvas && this.annotationCanvasMap) {\n                        transform = transform.slice();\n                        transform[4] -= rect[0];\n                        transform[5] -= rect[1];\n                        rect = rect.slice();\n                        rect[0] = rect[1] = 0;\n                        rect[2] = width;\n                        rect[3] = height;\n                        const [scaleX, scaleY] = util.Util.singularValueDecompose2dScale((0, display_utils.getCurrentTransform)(this.ctx));\n                        const { viewportScale } = this;\n                        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                        const { canvas, context } = this.annotationCanvas;\n                        this.annotationCanvasMap.set(id, canvas);\n                        this.annotationCanvas.savedCtx = this.ctx;\n                        this.ctx = context;\n                        this.ctx.save();\n                        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                        resetCtxToDefault(this.ctx);\n                    } else {\n                        resetCtxToDefault(this.ctx);\n                        this.ctx.rect(rect[0], rect[1], width, height);\n                        this.ctx.clip();\n                        this.endPath();\n                    }\n                }\n                this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                this.transform(...transform);\n                this.transform(...matrix);\n            }\n            endAnnotation() {\n                if (this.annotationCanvas) {\n                    this.ctx.restore();\n                    this.#drawFilter();\n                    this.ctx = this.annotationCanvas.savedCtx;\n                    delete this.annotationCanvas.savedCtx;\n                    delete this.annotationCanvas;\n                }\n            }\n            paintImageMaskXObject(img) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const count = img.count;\n                img = this.getObject(img.data, img);\n                img.count = count;\n                const ctx = this.ctx;\n                const glyph = this.processingType3;\n                if (glyph) {\n                    if (glyph.compiled === undefined) {\n                        glyph.compiled = compileType3Glyph(img);\n                    }\n                    if (glyph.compiled) {\n                        glyph.compiled(ctx);\n                        return;\n                    }\n                }\n                const mask = this._createMaskCanvas(img);\n                const maskCanvas = mask.canvas;\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n                ctx.restore();\n                this.compose();\n            }\n            paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                img = this.getObject(img.data, img);\n                const ctx = this.ctx;\n                ctx.save();\n                const currentTransform = (0, display_utils.getCurrentTransform)(ctx);\n                ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n                const mask = this._createMaskCanvas(img);\n                ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n                for(let i = 0, ii = positions.length; i < ii; i += 2){\n                    const trans = util.Util.transform(currentTransform, [\n                        scaleX,\n                        skewX,\n                        skewY,\n                        scaleY,\n                        positions[i],\n                        positions[i + 1]\n                    ]);\n                    const [x, y] = util.Util.applyTransform([\n                        0,\n                        0\n                    ], trans);\n                    ctx.drawImage(mask.canvas, x, y);\n                }\n                ctx.restore();\n                this.compose();\n            }\n            paintImageMaskXObjectGroup(images) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const ctx = this.ctx;\n                const fillColor = this.current.fillColor;\n                const isPatternFill = this.current.patternFill;\n                for (const image of images){\n                    const { data, width, height, transform } = image;\n                    const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                    const maskCtx = maskCanvas.context;\n                    maskCtx.save();\n                    const img = this.getObject(data, image);\n                    putBinaryImageMask(maskCtx, img);\n                    maskCtx.globalCompositeOperation = \"source-in\";\n                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, display_utils.getCurrentTransformInverse)(ctx), PathType.FILL) : fillColor;\n                    maskCtx.fillRect(0, 0, width, height);\n                    maskCtx.restore();\n                    ctx.save();\n                    ctx.transform(...transform);\n                    ctx.scale(1, -1);\n                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n                    ctx.restore();\n                }\n                this.compose();\n            }\n            paintImageXObject(objId) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const imgData = this.getObject(objId);\n                if (!imgData) {\n                    (0, util.warn)(\"Dependent image isn't ready yet\");\n                    return;\n                }\n                this.paintInlineImageXObject(imgData);\n            }\n            paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const imgData = this.getObject(objId);\n                if (!imgData) {\n                    (0, util.warn)(\"Dependent image isn't ready yet\");\n                    return;\n                }\n                const width = imgData.width;\n                const height = imgData.height;\n                const map = [];\n                for(let i = 0, ii = positions.length; i < ii; i += 2){\n                    map.push({\n                        transform: [\n                            scaleX,\n                            0,\n                            0,\n                            scaleY,\n                            positions[i],\n                            positions[i + 1]\n                        ],\n                        x: 0,\n                        y: 0,\n                        w: width,\n                        h: height\n                    });\n                }\n                this.paintInlineImageXObjectGroup(imgData, map);\n            }\n            applyTransferMapsToCanvas(ctx) {\n                if (this.current.transferMaps !== \"none\") {\n                    ctx.filter = this.current.transferMaps;\n                    ctx.drawImage(ctx.canvas, 0, 0);\n                    ctx.filter = \"none\";\n                }\n                return ctx.canvas;\n            }\n            applyTransferMapsToBitmap(imgData) {\n                if (this.current.transferMaps === \"none\") {\n                    return imgData.bitmap;\n                }\n                const { bitmap, width, height } = imgData;\n                const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                const tmpCtx = tmpCanvas.context;\n                tmpCtx.filter = this.current.transferMaps;\n                tmpCtx.drawImage(bitmap, 0, 0);\n                tmpCtx.filter = \"none\";\n                return tmpCanvas.canvas;\n            }\n            paintInlineImageXObject(imgData) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const width = imgData.width;\n                const height = imgData.height;\n                const ctx = this.ctx;\n                this.save();\n                if (!util.isNodeJS) {\n                    const { filter } = ctx;\n                    if (filter !== \"none\" && filter !== \"\") {\n                        ctx.filter = \"none\";\n                    }\n                }\n                ctx.scale(1 / width, -1 / height);\n                let imgToPaint;\n                if (imgData.bitmap) {\n                    imgToPaint = this.applyTransferMapsToBitmap(imgData);\n                } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n                    imgToPaint = imgData;\n                } else {\n                    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                    const tmpCtx = tmpCanvas.context;\n                    putBinaryImageData(tmpCtx, imgData);\n                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                }\n                const scaled = this._scaleImage(imgToPaint, (0, display_utils.getCurrentTransformInverse)(ctx));\n                ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n                drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n                this.compose();\n                this.restore();\n            }\n            paintInlineImageXObjectGroup(imgData, map) {\n                if (!this.contentVisible) {\n                    return;\n                }\n                const ctx = this.ctx;\n                let imgToPaint;\n                if (imgData.bitmap) {\n                    imgToPaint = imgData.bitmap;\n                } else {\n                    const w = imgData.width;\n                    const h = imgData.height;\n                    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n                    const tmpCtx = tmpCanvas.context;\n                    putBinaryImageData(tmpCtx, imgData);\n                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                }\n                for (const entry of map){\n                    ctx.save();\n                    ctx.transform(...entry.transform);\n                    ctx.scale(1, -1);\n                    drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n                    ctx.restore();\n                }\n                this.compose();\n            }\n            paintSolidColorImageMask() {\n                if (!this.contentVisible) {\n                    return;\n                }\n                this.ctx.fillRect(0, 0, 1, 1);\n                this.compose();\n            }\n            markPoint(tag) {}\n            markPointProps(tag, properties) {}\n            beginMarkedContent(tag) {\n                this.markedContentStack.push({\n                    visible: true\n                });\n            }\n            beginMarkedContentProps(tag, properties) {\n                if (tag === \"OC\") {\n                    this.markedContentStack.push({\n                        visible: this.optionalContentConfig.isVisible(properties)\n                    });\n                } else {\n                    this.markedContentStack.push({\n                        visible: true\n                    });\n                }\n                this.contentVisible = this.isContentVisible();\n            }\n            endMarkedContent() {\n                this.markedContentStack.pop();\n                this.contentVisible = this.isContentVisible();\n            }\n            beginCompat() {}\n            endCompat() {}\n            consumePath(clipBox) {\n                const isEmpty = this.current.isEmptyClip();\n                if (this.pendingClip) {\n                    this.current.updateClipFromPath();\n                }\n                if (!this.pendingClip) {\n                    this.compose(clipBox);\n                }\n                const ctx = this.ctx;\n                if (this.pendingClip) {\n                    if (!isEmpty) {\n                        if (this.pendingClip === EO_CLIP) {\n                            ctx.clip(\"evenodd\");\n                        } else {\n                            ctx.clip();\n                        }\n                    }\n                    this.pendingClip = null;\n                }\n                this.current.startNewPathAndClipBox(this.current.clipBox);\n                ctx.beginPath();\n            }\n            getSinglePixelWidth() {\n                if (!this._cachedGetSinglePixelWidth) {\n                    const m = (0, display_utils.getCurrentTransform)(this.ctx);\n                    if (m[1] === 0 && m[2] === 0) {\n                        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n                    } else {\n                        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                        const normX = Math.hypot(m[0], m[2]);\n                        const normY = Math.hypot(m[1], m[3]);\n                        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n                    }\n                }\n                return this._cachedGetSinglePixelWidth;\n            }\n            getScaleForStroking() {\n                if (this._cachedScaleForStroking[0] === -1) {\n                    const { lineWidth } = this.current;\n                    const { a, b, c, d } = this.ctx.getTransform();\n                    let scaleX, scaleY;\n                    if (b === 0 && c === 0) {\n                        const normX = Math.abs(a);\n                        const normY = Math.abs(d);\n                        if (normX === normY) {\n                            if (lineWidth === 0) {\n                                scaleX = scaleY = 1 / normX;\n                            } else {\n                                const scaledLineWidth = normX * lineWidth;\n                                scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                            }\n                        } else if (lineWidth === 0) {\n                            scaleX = 1 / normX;\n                            scaleY = 1 / normY;\n                        } else {\n                            const scaledXLineWidth = normX * lineWidth;\n                            const scaledYLineWidth = normY * lineWidth;\n                            scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                            scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                        }\n                    } else {\n                        const absDet = Math.abs(a * d - b * c);\n                        const normX = Math.hypot(a, b);\n                        const normY = Math.hypot(c, d);\n                        if (lineWidth === 0) {\n                            scaleX = normY / absDet;\n                            scaleY = normX / absDet;\n                        } else {\n                            const baseArea = lineWidth * absDet;\n                            scaleX = normY > baseArea ? normY / baseArea : 1;\n                            scaleY = normX > baseArea ? normX / baseArea : 1;\n                        }\n                    }\n                    this._cachedScaleForStroking[0] = scaleX;\n                    this._cachedScaleForStroking[1] = scaleY;\n                }\n                return this._cachedScaleForStroking;\n            }\n            rescaleAndStroke(saveRestore) {\n                const { ctx } = this;\n                const { lineWidth } = this.current;\n                const [scaleX, scaleY] = this.getScaleForStroking();\n                ctx.lineWidth = lineWidth || 1;\n                if (scaleX === 1 && scaleY === 1) {\n                    ctx.stroke();\n                    return;\n                }\n                const dashes = ctx.getLineDash();\n                if (saveRestore) {\n                    ctx.save();\n                }\n                ctx.scale(scaleX, scaleY);\n                if (dashes.length > 0) {\n                    const scale = Math.max(scaleX, scaleY);\n                    ctx.setLineDash(dashes.map((x)=>x / scale));\n                    ctx.lineDashOffset /= scale;\n                }\n                ctx.stroke();\n                if (saveRestore) {\n                    ctx.restore();\n                }\n            }\n            isContentVisible() {\n                for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n                    if (!this.markedContentStack[i].visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        for(const op in util.OPS){\n            if (CanvasGraphics.prototype[op] !== undefined) {\n                CanvasGraphics.prototype[util.OPS[op]] = CanvasGraphics.prototype[op];\n            }\n        }\n    /***/ },\n    /***/ 473: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_362539__)=>{\n        /* harmony export */ __nested_webpack_require_362539__.d(__nested_webpack_exports__, {\n            /* harmony export */ DOMCMapReaderFactory: ()=>/* binding */ DOMCMapReaderFactory,\n            /* harmony export */ DOMCanvasFactory: ()=>/* binding */ DOMCanvasFactory,\n            /* harmony export */ DOMFilterFactory: ()=>/* binding */ DOMFilterFactory,\n            /* harmony export */ DOMSVGFactory: ()=>/* binding */ DOMSVGFactory,\n            /* harmony export */ DOMStandardFontDataFactory: ()=>/* binding */ DOMStandardFontDataFactory,\n            /* harmony export */ PDFDateString: ()=>/* binding */ PDFDateString,\n            /* harmony export */ PageViewport: ()=>/* binding */ PageViewport,\n            /* harmony export */ PixelsPerInch: ()=>/* binding */ PixelsPerInch,\n            /* harmony export */ RenderingCancelledException: ()=>/* binding */ RenderingCancelledException,\n            /* harmony export */ StatTimer: ()=>/* binding */ StatTimer,\n            /* harmony export */ fetchData: ()=>/* binding */ fetchData,\n            /* harmony export */ getColorValues: ()=>/* binding */ getColorValues,\n            /* harmony export */ getCurrentTransform: ()=>/* binding */ getCurrentTransform,\n            /* harmony export */ getCurrentTransformInverse: ()=>/* binding */ getCurrentTransformInverse,\n            /* harmony export */ getFilenameFromUrl: ()=>/* binding */ getFilenameFromUrl,\n            /* harmony export */ getPdfFilenameFromUrl: ()=>/* binding */ getPdfFilenameFromUrl,\n            /* harmony export */ getRGB: ()=>/* binding */ getRGB,\n            /* harmony export */ getXfaPageViewport: ()=>/* binding */ getXfaPageViewport,\n            /* harmony export */ isDataScheme: ()=>/* binding */ isDataScheme,\n            /* harmony export */ isPdfFile: ()=>/* binding */ isPdfFile,\n            /* harmony export */ isValidFetchUrl: ()=>/* binding */ isValidFetchUrl,\n            /* harmony export */ noContextMenu: ()=>/* binding */ noContextMenu,\n            /* harmony export */ setLayerDimensions: ()=>/* binding */ setLayerDimensions\n        });\n        /* unused harmony export deprecated */ /* harmony import */ var _base_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_362539__(822);\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_362539__(266);\n        const SVG_NS = \"http://www.w3.org/2000/svg\";\n        class PixelsPerInch {\n            static{\n                this.CSS = 96.0;\n            }\n            static{\n                this.PDF = 72.0;\n            }\n            static{\n                this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n            }\n        }\n        class DOMFilterFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseFilterFactory {\n            #_cache;\n            #_defs;\n            #docId;\n            #document;\n            #hcmFilter;\n            #hcmKey;\n            #hcmUrl;\n            #hcmHighlightFilter;\n            #hcmHighlightKey;\n            #hcmHighlightUrl;\n            #id;\n            constructor({ docId, ownerDocument = globalThis.document } = {}){\n                super();\n                this.#id = 0;\n                this.#docId = docId;\n                this.#document = ownerDocument;\n            }\n            get #cache() {\n                return this.#_cache ||= new Map();\n            }\n            get #defs() {\n                if (!this.#_defs) {\n                    const div = this.#document.createElement(\"div\");\n                    const { style } = div;\n                    style.visibility = \"hidden\";\n                    style.contain = \"strict\";\n                    style.width = style.height = 0;\n                    style.position = \"absolute\";\n                    style.top = style.left = 0;\n                    style.zIndex = -1;\n                    const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n                    svg.setAttribute(\"width\", 0);\n                    svg.setAttribute(\"height\", 0);\n                    this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n                    div.append(svg);\n                    svg.append(this.#_defs);\n                    this.#document.body.append(div);\n                }\n                return this.#_defs;\n            }\n            addFilter(maps) {\n                if (!maps) {\n                    return \"none\";\n                }\n                let value = this.#cache.get(maps);\n                if (value) {\n                    return value;\n                }\n                let tableR, tableG, tableB, key;\n                if (maps.length === 1) {\n                    const mapR = maps[0];\n                    const buffer = new Array(256);\n                    for(let i = 0; i < 256; i++){\n                        buffer[i] = mapR[i] / 255;\n                    }\n                    key = tableR = tableG = tableB = buffer.join(\",\");\n                } else {\n                    const [mapR, mapG, mapB] = maps;\n                    const bufferR = new Array(256);\n                    const bufferG = new Array(256);\n                    const bufferB = new Array(256);\n                    for(let i = 0; i < 256; i++){\n                        bufferR[i] = mapR[i] / 255;\n                        bufferG[i] = mapG[i] / 255;\n                        bufferB[i] = mapB[i] / 255;\n                    }\n                    tableR = bufferR.join(\",\");\n                    tableG = bufferG.join(\",\");\n                    tableB = bufferB.join(\",\");\n                    key = `${tableR}${tableG}${tableB}`;\n                }\n                value = this.#cache.get(key);\n                if (value) {\n                    this.#cache.set(maps, value);\n                    return value;\n                }\n                const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n                const url = `url(#${id})`;\n                this.#cache.set(maps, url);\n                this.#cache.set(key, url);\n                const filter = this.#createFilter(id);\n                this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n                return url;\n            }\n            addHCMFilter(fgColor, bgColor) {\n                const key = `${fgColor}-${bgColor}`;\n                if (this.#hcmKey === key) {\n                    return this.#hcmUrl;\n                }\n                this.#hcmKey = key;\n                this.#hcmUrl = \"none\";\n                this.#hcmFilter?.remove();\n                if (!fgColor || !bgColor) {\n                    return this.#hcmUrl;\n                }\n                const fgRGB = this.#getRGB(fgColor);\n                fgColor = _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.makeHexColor(...fgRGB);\n                const bgRGB = this.#getRGB(bgColor);\n                bgColor = _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.makeHexColor(...bgRGB);\n                this.#defs.style.color = \"\";\n                if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n                    return this.#hcmUrl;\n                }\n                const map = new Array(256);\n                for(let i = 0; i <= 255; i++){\n                    const x = i / 255;\n                    map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n                }\n                const table = map.join(\",\");\n                const id = `g_${this.#docId}_hcm_filter`;\n                const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                this.#addTransferMapConversion(table, table, table, filter);\n                this.#addGrayConversion(filter);\n                const getSteps = (c, n)=>{\n                    const start = fgRGB[c] / 255;\n                    const end = bgRGB[c] / 255;\n                    const arr = new Array(n + 1);\n                    for(let i = 0; i <= n; i++){\n                        arr[i] = start + i / n * (end - start);\n                    }\n                    return arr.join(\",\");\n                };\n                this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n                this.#hcmUrl = `url(#${id})`;\n                return this.#hcmUrl;\n            }\n            addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n                if (this.#hcmHighlightKey === key) {\n                    return this.#hcmHighlightUrl;\n                }\n                this.#hcmHighlightKey = key;\n                this.#hcmHighlightUrl = \"none\";\n                this.#hcmHighlightFilter?.remove();\n                if (!fgColor || !bgColor) {\n                    return this.#hcmHighlightUrl;\n                }\n                const [fgRGB, bgRGB] = [\n                    fgColor,\n                    bgColor\n                ].map(this.#getRGB.bind(this));\n                let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n                let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n                let [newFgRGB, newBgRGB] = [\n                    newFgColor,\n                    newBgColor\n                ].map(this.#getRGB.bind(this));\n                if (bgGray < fgGray) {\n                    [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                        bgGray,\n                        fgGray,\n                        newBgRGB,\n                        newFgRGB\n                    ];\n                }\n                this.#defs.style.color = \"\";\n                const getSteps = (fg, bg, n)=>{\n                    const arr = new Array(256);\n                    const step = (bgGray - fgGray) / n;\n                    const newStart = fg / 255;\n                    const newStep = (bg - fg) / (255 * n);\n                    let prev = 0;\n                    for(let i = 0; i <= n; i++){\n                        const k = Math.round(fgGray + i * step);\n                        const value = newStart + i * newStep;\n                        for(let j = prev; j <= k; j++){\n                            arr[j] = value;\n                        }\n                        prev = k + 1;\n                    }\n                    for(let i = prev; i < 256; i++){\n                        arr[i] = arr[prev - 1];\n                    }\n                    return arr.join(\",\");\n                };\n                const id = `g_${this.#docId}_hcm_highlight_filter`;\n                const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                this.#addGrayConversion(filter);\n                this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n                this.#hcmHighlightUrl = `url(#${id})`;\n                return this.#hcmHighlightUrl;\n            }\n            destroy(keepHCM = false) {\n                if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n                    return;\n                }\n                if (this.#_defs) {\n                    this.#_defs.parentNode.parentNode.remove();\n                    this.#_defs = null;\n                }\n                if (this.#_cache) {\n                    this.#_cache.clear();\n                    this.#_cache = null;\n                }\n                this.#id = 0;\n            }\n            #addGrayConversion(filter) {\n                const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n                feColorMatrix.setAttribute(\"type\", \"matrix\");\n                feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n                filter.append(feColorMatrix);\n            }\n            #createFilter(id) {\n                const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n                filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n                filter.setAttribute(\"id\", id);\n                this.#defs.append(filter);\n                return filter;\n            }\n            #appendFeFunc(feComponentTransfer, func, table) {\n                const feFunc = this.#document.createElementNS(SVG_NS, func);\n                feFunc.setAttribute(\"type\", \"discrete\");\n                feFunc.setAttribute(\"tableValues\", table);\n                feComponentTransfer.append(feFunc);\n            }\n            #addTransferMapConversion(rTable, gTable, bTable, filter) {\n                const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n                filter.append(feComponentTransfer);\n                this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n                this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n                this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n            }\n            #getRGB(color) {\n                this.#defs.style.color = color;\n                return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n            }\n        }\n        class DOMCanvasFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseCanvasFactory {\n            constructor({ ownerDocument = globalThis.document } = {}){\n                super();\n                this._document = ownerDocument;\n            }\n            _createCanvas(width, height) {\n                const canvas = this._document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                return canvas;\n            }\n        }\n        async function fetchData(url, type = \"text\") {\n            if (isValidFetchUrl(url, document.baseURI)) {\n                const response = await fetch(url);\n                if (!response.ok) {\n                    throw new Error(response.statusText);\n                }\n                switch(type){\n                    case \"arraybuffer\":\n                        return response.arrayBuffer();\n                    case \"blob\":\n                        return response.blob();\n                    case \"json\":\n                        return response.json();\n                }\n                return response.text();\n            }\n            return new Promise((resolve, reject)=>{\n                const request = new XMLHttpRequest();\n                request.open(\"GET\", url, true);\n                request.responseType = type;\n                request.onreadystatechange = ()=>{\n                    if (request.readyState !== XMLHttpRequest.DONE) {\n                        return;\n                    }\n                    if (request.status === 200 || request.status === 0) {\n                        let data;\n                        switch(type){\n                            case \"arraybuffer\":\n                            case \"blob\":\n                            case \"json\":\n                                data = request.response;\n                                break;\n                            default:\n                                data = request.responseText;\n                                break;\n                        }\n                        if (data) {\n                            resolve(data);\n                            return;\n                        }\n                    }\n                    reject(new Error(request.statusText));\n                };\n                request.send(null);\n            });\n        }\n        class DOMCMapReaderFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseCMapReaderFactory {\n            _fetchData(url, compressionType) {\n                return fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\").then((data)=>{\n                    return {\n                        cMapData: data instanceof ArrayBuffer ? new Uint8Array(data) : (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.stringToBytes)(data),\n                        compressionType\n                    };\n                });\n            }\n        }\n        class DOMStandardFontDataFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseStandardFontDataFactory {\n            _fetchData(url) {\n                return fetchData(url, \"arraybuffer\").then((data)=>{\n                    return new Uint8Array(data);\n                });\n            }\n        }\n        class DOMSVGFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseSVGFactory {\n            _createSVG(type) {\n                return document.createElementNS(SVG_NS, type);\n            }\n        }\n        class PageViewport {\n            constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n                this.viewBox = viewBox;\n                this.scale = scale;\n                this.rotation = rotation;\n                this.offsetX = offsetX;\n                this.offsetY = offsetY;\n                const centerX = (viewBox[2] + viewBox[0]) / 2;\n                const centerY = (viewBox[3] + viewBox[1]) / 2;\n                let rotateA, rotateB, rotateC, rotateD;\n                rotation %= 360;\n                if (rotation < 0) {\n                    rotation += 360;\n                }\n                switch(rotation){\n                    case 180:\n                        rotateA = -1;\n                        rotateB = 0;\n                        rotateC = 0;\n                        rotateD = 1;\n                        break;\n                    case 90:\n                        rotateA = 0;\n                        rotateB = 1;\n                        rotateC = 1;\n                        rotateD = 0;\n                        break;\n                    case 270:\n                        rotateA = 0;\n                        rotateB = -1;\n                        rotateC = -1;\n                        rotateD = 0;\n                        break;\n                    case 0:\n                        rotateA = 1;\n                        rotateB = 0;\n                        rotateC = 0;\n                        rotateD = -1;\n                        break;\n                    default:\n                        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n                }\n                if (dontFlip) {\n                    rotateC = -rotateC;\n                    rotateD = -rotateD;\n                }\n                let offsetCanvasX, offsetCanvasY;\n                let width, height;\n                if (rotateA === 0) {\n                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n                    width = (viewBox[3] - viewBox[1]) * scale;\n                    height = (viewBox[2] - viewBox[0]) * scale;\n                } else {\n                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n                    width = (viewBox[2] - viewBox[0]) * scale;\n                    height = (viewBox[3] - viewBox[1]) * scale;\n                }\n                this.transform = [\n                    rotateA * scale,\n                    rotateB * scale,\n                    rotateC * scale,\n                    rotateD * scale,\n                    offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n                    offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n                ];\n                this.width = width;\n                this.height = height;\n            }\n            get rawDims() {\n                const { viewBox } = this;\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.shadow)(this, \"rawDims\", {\n                    pageWidth: viewBox[2] - viewBox[0],\n                    pageHeight: viewBox[3] - viewBox[1],\n                    pageX: viewBox[0],\n                    pageY: viewBox[1]\n                });\n            }\n            clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n                return new PageViewport({\n                    viewBox: this.viewBox.slice(),\n                    scale,\n                    rotation,\n                    offsetX,\n                    offsetY,\n                    dontFlip\n                });\n            }\n            convertToViewportPoint(x, y) {\n                return _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.applyTransform([\n                    x,\n                    y\n                ], this.transform);\n            }\n            convertToViewportRectangle(rect) {\n                const topLeft = _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.applyTransform([\n                    rect[0],\n                    rect[1]\n                ], this.transform);\n                const bottomRight = _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.applyTransform([\n                    rect[2],\n                    rect[3]\n                ], this.transform);\n                return [\n                    topLeft[0],\n                    topLeft[1],\n                    bottomRight[0],\n                    bottomRight[1]\n                ];\n            }\n            convertToPdfPoint(x, y) {\n                return _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.Util.applyInverseTransform([\n                    x,\n                    y\n                ], this.transform);\n            }\n        }\n        class RenderingCancelledException extends _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.BaseException {\n            constructor(msg, extraDelay = 0){\n                super(msg, \"RenderingCancelledException\");\n                this.extraDelay = extraDelay;\n            }\n        }\n        function isDataScheme(url) {\n            const ii = url.length;\n            let i = 0;\n            while(i < ii && url[i].trim() === \"\"){\n                i++;\n            }\n            return url.substring(i, i + 5).toLowerCase() === \"data:\";\n        }\n        function isPdfFile(filename) {\n            return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n        }\n        function getFilenameFromUrl(url, onlyStripPath = false) {\n            if (!onlyStripPath) {\n                [url] = url.split(/[#?]/, 1);\n            }\n            return url.substring(url.lastIndexOf(\"/\") + 1);\n        }\n        function getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n            if (typeof url !== \"string\") {\n                return defaultFilename;\n            }\n            if (isDataScheme(url)) {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n                return defaultFilename;\n            }\n            const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n            const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n            const splitURI = reURI.exec(url);\n            let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n            if (suggestedFilename) {\n                suggestedFilename = suggestedFilename[0];\n                if (suggestedFilename.includes(\"%\")) {\n                    try {\n                        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n                    } catch  {}\n                }\n            }\n            return suggestedFilename || defaultFilename;\n        }\n        class StatTimer {\n            time(name) {\n                if (name in this.started) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.warn)(`Timer is already running for ${name}`);\n                }\n                this.started[name] = Date.now();\n            }\n            timeEnd(name) {\n                if (!(name in this.started)) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.warn)(`Timer has not been started for ${name}`);\n                }\n                this.times.push({\n                    name,\n                    start: this.started[name],\n                    end: Date.now()\n                });\n                delete this.started[name];\n            }\n            toString() {\n                const outBuf = [];\n                let longest = 0;\n                for (const { name } of this.times){\n                    longest = Math.max(name.length, longest);\n                }\n                for (const { name, start, end } of this.times){\n                    outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n                }\n                return outBuf.join(\"\");\n            }\n            constructor(){\n                this.started = Object.create(null);\n                this.times = [];\n            }\n        }\n        function isValidFetchUrl(url, baseUrl) {\n            try {\n                const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                return protocol === \"http:\" || protocol === \"https:\";\n            } catch  {\n                return false;\n            }\n        }\n        function noContextMenu(e) {\n            e.preventDefault();\n        }\n        function deprecated(details) {\n            console.log(\"Deprecated API usage: \" + details);\n        }\n        let pdfDateStringRegex;\n        class PDFDateString {\n            static toDateObject(input) {\n                if (!input || typeof input !== \"string\") {\n                    return null;\n                }\n                pdfDateStringRegex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n                const matches = pdfDateStringRegex.exec(input);\n                if (!matches) {\n                    return null;\n                }\n                const year = parseInt(matches[1], 10);\n                let month = parseInt(matches[2], 10);\n                month = month >= 1 && month <= 12 ? month - 1 : 0;\n                let day = parseInt(matches[3], 10);\n                day = day >= 1 && day <= 31 ? day : 1;\n                let hour = parseInt(matches[4], 10);\n                hour = hour >= 0 && hour <= 23 ? hour : 0;\n                let minute = parseInt(matches[5], 10);\n                minute = minute >= 0 && minute <= 59 ? minute : 0;\n                let second = parseInt(matches[6], 10);\n                second = second >= 0 && second <= 59 ? second : 0;\n                const universalTimeRelation = matches[7] || \"Z\";\n                let offsetHour = parseInt(matches[8], 10);\n                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n                let offsetMinute = parseInt(matches[9], 10) || 0;\n                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n                if (universalTimeRelation === \"-\") {\n                    hour += offsetHour;\n                    minute += offsetMinute;\n                } else if (universalTimeRelation === \"+\") {\n                    hour -= offsetHour;\n                    minute -= offsetMinute;\n                }\n                return new Date(Date.UTC(year, month, day, hour, minute, second));\n            }\n        }\n        function getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n            const { width, height } = xfaPage.attributes.style;\n            const viewBox = [\n                0,\n                0,\n                parseInt(width),\n                parseInt(height)\n            ];\n            return new PageViewport({\n                viewBox,\n                scale,\n                rotation\n            });\n        }\n        function getRGB(color) {\n            if (color.startsWith(\"#\")) {\n                const colorRGB = parseInt(color.slice(1), 16);\n                return [\n                    (colorRGB & 0xff0000) >> 16,\n                    (colorRGB & 0x00ff00) >> 8,\n                    colorRGB & 0x0000ff\n                ];\n            }\n            if (color.startsWith(\"rgb(\")) {\n                return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n            }\n            if (color.startsWith(\"rgba(\")) {\n                return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n            }\n            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.warn)(`Not a valid color format: \"${color}\"`);\n            return [\n                0,\n                0,\n                0\n            ];\n        }\n        function getColorValues(colors) {\n            const span = document.createElement(\"span\");\n            span.style.visibility = \"hidden\";\n            document.body.append(span);\n            for (const name of colors.keys()){\n                span.style.color = name;\n                const computedColor = window.getComputedStyle(span).color;\n                colors.set(name, getRGB(computedColor));\n            }\n            span.remove();\n        }\n        function getCurrentTransform(ctx) {\n            const { a, b, c, d, e, f } = ctx.getTransform();\n            return [\n                a,\n                b,\n                c,\n                d,\n                e,\n                f\n            ];\n        }\n        function getCurrentTransformInverse(ctx) {\n            const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n            return [\n                a,\n                b,\n                c,\n                d,\n                e,\n                f\n            ];\n        }\n        function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n            if (viewport instanceof PageViewport) {\n                const { pageWidth, pageHeight } = viewport.rawDims;\n                const { style } = div;\n                const useRound = _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.FeatureTest.isCSSRoundSupported;\n                const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n                const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`, heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;\n                if (!mustFlip || viewport.rotation % 180 === 0) {\n                    style.width = widthStr;\n                    style.height = heightStr;\n                } else {\n                    style.width = heightStr;\n                    style.height = widthStr;\n                }\n            }\n            if (mustRotate) {\n                div.setAttribute(\"data-main-rotation\", viewport.rotation);\n            }\n        }\n    /***/ },\n    /***/ 423: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_393175__)=>{\n        /* harmony export */ __nested_webpack_require_393175__.d(__nested_webpack_exports__, {\n            /* harmony export */ DrawLayer: ()=>/* binding */ DrawLayer\n        });\n        /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_393175__(473);\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_393175__(266);\n        class DrawLayer {\n            #parent;\n            #id;\n            #mapping;\n            constructor({ pageIndex }){\n                this.#parent = null;\n                this.#id = 0;\n                this.#mapping = new Map();\n                this.pageIndex = pageIndex;\n            }\n            setParent(parent) {\n                if (!this.#parent) {\n                    this.#parent = parent;\n                    return;\n                }\n                if (this.#parent !== parent) {\n                    if (this.#mapping.size > 0) {\n                        for (const root of this.#mapping.values()){\n                            root.remove();\n                            parent.append(root);\n                        }\n                    }\n                    this.#parent = parent;\n                }\n            }\n            static get _svgFactory() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_1__.shadow)(this, \"_svgFactory\", new _display_utils_js__WEBPACK_IMPORTED_MODULE_0__.DOMSVGFactory());\n            }\n            static #setBox(element, { x, y, width, height }) {\n                const { style } = element;\n                style.top = `${100 * y}%`;\n                style.left = `${100 * x}%`;\n                style.width = `${100 * width}%`;\n                style.height = `${100 * height}%`;\n            }\n            #createSVG(box) {\n                const svg = DrawLayer._svgFactory.create(1, 1, true);\n                this.#parent.append(svg);\n                DrawLayer.#setBox(svg, box);\n                return svg;\n            }\n            highlight({ outlines, box }, color, opacity) {\n                const id = this.#id++;\n                const root = this.#createSVG(box);\n                root.classList.add(\"highlight\");\n                const defs = DrawLayer._svgFactory.createElement(\"defs\");\n                root.append(defs);\n                const path = DrawLayer._svgFactory.createElement(\"path\");\n                defs.append(path);\n                const pathId = `path_p${this.pageIndex}_${id}`;\n                path.setAttribute(\"id\", pathId);\n                path.setAttribute(\"d\", DrawLayer.#extractPathFromHighlightOutlines(outlines));\n                const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n                defs.append(clipPath);\n                const clipPathId = `clip_${pathId}`;\n                clipPath.setAttribute(\"id\", clipPathId);\n                clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n                const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n                clipPath.append(clipPathUse);\n                clipPathUse.setAttribute(\"href\", `#${pathId}`);\n                clipPathUse.classList.add(\"clip\");\n                const use = DrawLayer._svgFactory.createElement(\"use\");\n                root.append(use);\n                root.setAttribute(\"fill\", color);\n                root.setAttribute(\"fill-opacity\", opacity);\n                use.setAttribute(\"href\", `#${pathId}`);\n                this.#mapping.set(id, root);\n                return {\n                    id,\n                    clipPathId: `url(#${clipPathId})`\n                };\n            }\n            highlightOutline({ outlines, box }) {\n                const id = this.#id++;\n                const root = this.#createSVG(box);\n                root.classList.add(\"highlightOutline\");\n                const defs = DrawLayer._svgFactory.createElement(\"defs\");\n                root.append(defs);\n                const path = DrawLayer._svgFactory.createElement(\"path\");\n                defs.append(path);\n                const pathId = `path_p${this.pageIndex}_${id}`;\n                path.setAttribute(\"id\", pathId);\n                path.setAttribute(\"d\", DrawLayer.#extractPathFromHighlightOutlines(outlines));\n                path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n                const use1 = DrawLayer._svgFactory.createElement(\"use\");\n                root.append(use1);\n                use1.setAttribute(\"href\", `#${pathId}`);\n                const use2 = use1.cloneNode();\n                root.append(use2);\n                use1.classList.add(\"mainOutline\");\n                use2.classList.add(\"secondaryOutline\");\n                this.#mapping.set(id, root);\n                return id;\n            }\n            static #extractPathFromHighlightOutlines(polygons) {\n                const buffer = [];\n                for (const polygon of polygons){\n                    let [prevX, prevY] = polygon;\n                    buffer.push(`M${prevX} ${prevY}`);\n                    for(let i = 2; i < polygon.length; i += 2){\n                        const x = polygon[i];\n                        const y = polygon[i + 1];\n                        if (x === prevX) {\n                            buffer.push(`V${y}`);\n                            prevY = y;\n                        } else if (y === prevY) {\n                            buffer.push(`H${x}`);\n                            prevX = x;\n                        }\n                    }\n                    buffer.push(\"Z\");\n                }\n                return buffer.join(\" \");\n            }\n            updateBox(id, box) {\n                DrawLayer.#setBox(this.#mapping.get(id), box);\n            }\n            rotate(id, angle) {\n                this.#mapping.get(id).setAttribute(\"data-main-rotation\", angle);\n            }\n            changeColor(id, color) {\n                this.#mapping.get(id).setAttribute(\"fill\", color);\n            }\n            changeOpacity(id, opacity) {\n                this.#mapping.get(id).setAttribute(\"fill-opacity\", opacity);\n            }\n            addClass(id, className) {\n                this.#mapping.get(id).classList.add(className);\n            }\n            removeClass(id, className) {\n                this.#mapping.get(id).classList.remove(className);\n            }\n            remove(id) {\n                if (this.#parent === null) {\n                    return;\n                }\n                this.#mapping.get(id).remove();\n                this.#mapping.delete(id);\n            }\n            destroy() {\n                this.#parent = null;\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                }\n                this.#mapping.clear();\n            }\n        }\n    /***/ },\n    /***/ 629: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_400043__)=>{\n        // EXPORTS\n        __nested_webpack_require_400043__.d(__nested_webpack_exports__, {\n            AnnotationEditorLayer: ()=>/* binding */ AnnotationEditorLayer\n        });\n        // EXTERNAL MODULE: ./src/shared/util.js\n        var util = __nested_webpack_require_400043__(266);\n        // EXTERNAL MODULE: ./src/display/editor/editor.js + 2 modules\n        var editor_editor = __nested_webpack_require_400043__(115);\n        // EXTERNAL MODULE: ./src/display/editor/tools.js\n        var tools = __nested_webpack_require_400043__(812);\n        // EXTERNAL MODULE: ./src/display/annotation_layer.js + 1 modules\n        var annotation_layer = __nested_webpack_require_400043__(640);\n        ; // CONCATENATED MODULE: ./src/display/editor/freetext.js\n        class FreeTextEditor extends editor_editor.AnnotationEditor {\n            #boundEditorDivBlur;\n            #boundEditorDivFocus;\n            #boundEditorDivInput;\n            #boundEditorDivKeydown;\n            #color;\n            #content;\n            #editorDivId;\n            #fontSize;\n            #initialData;\n            static{\n                this._freeTextDefaultContent = \"\";\n            }\n            static{\n                this._internalPadding = 0;\n            }\n            static{\n                this._defaultColor = null;\n            }\n            static{\n                this._defaultFontSize = 10;\n            }\n            static get _keyboardManager() {\n                const proto = FreeTextEditor.prototype;\n                const arrowChecker = (self)=>self.isEmpty();\n                const small = tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n                const big = tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n                return (0, util.shadow)(this, \"_keyboardManager\", new tools.KeyboardManager([\n                    [\n                        [\n                            \"ctrl+s\",\n                            \"mac+meta+s\",\n                            \"ctrl+p\",\n                            \"mac+meta+p\"\n                        ],\n                        proto.commitOrRemove,\n                        {\n                            bubbles: true\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+Enter\",\n                            \"mac+meta+Enter\",\n                            \"Escape\",\n                            \"mac+Escape\"\n                        ],\n                        proto.commitOrRemove\n                    ],\n                    [\n                        [\n                            \"ArrowLeft\",\n                            \"mac+ArrowLeft\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                -small,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowLeft\",\n                            \"mac+shift+ArrowLeft\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                -big,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowRight\",\n                            \"mac+ArrowRight\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                small,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowRight\",\n                            \"mac+shift+ArrowRight\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                big,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowUp\",\n                            \"mac+ArrowUp\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                0,\n                                -small\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowUp\",\n                            \"mac+shift+ArrowUp\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                0,\n                                -big\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowDown\",\n                            \"mac+ArrowDown\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                0,\n                                small\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowDown\",\n                            \"mac+shift+ArrowDown\"\n                        ],\n                        proto._translateEmpty,\n                        {\n                            args: [\n                                0,\n                                big\n                            ],\n                            checker: arrowChecker\n                        }\n                    ]\n                ]));\n            }\n            static{\n                this._type = \"freetext\";\n            }\n            static{\n                this._editorType = util.AnnotationEditorType.FREETEXT;\n            }\n            constructor(params){\n                super({\n                    ...params,\n                    name: \"freeTextEditor\"\n                });\n                this.#boundEditorDivBlur = this.editorDivBlur.bind(this);\n                this.#boundEditorDivFocus = this.editorDivFocus.bind(this);\n                this.#boundEditorDivInput = this.editorDivInput.bind(this);\n                this.#boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n                this.#content = \"\";\n                this.#editorDivId = `${this.id}-editor`;\n                this.#initialData = null;\n                this.#color = params.color || FreeTextEditor._defaultColor || editor_editor.AnnotationEditor._defaultLineColor;\n                this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n            }\n            static initialize(l10n) {\n                editor_editor.AnnotationEditor.initialize(l10n, {\n                    strings: [\n                        \"pdfjs-free-text-default-content\"\n                    ]\n                });\n                const style = getComputedStyle(document.documentElement);\n                this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n            }\n            static updateDefaultParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                        FreeTextEditor._defaultFontSize = value;\n                        break;\n                    case util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                        FreeTextEditor._defaultColor = value;\n                        break;\n                }\n            }\n            updateParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                        this.#updateFontSize(value);\n                        break;\n                    case util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                        this.#updateColor(value);\n                        break;\n                }\n            }\n            static get defaultPropertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                        FreeTextEditor._defaultFontSize\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                        FreeTextEditor._defaultColor || editor_editor.AnnotationEditor._defaultLineColor\n                    ]\n                ];\n            }\n            get propertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                        this.#fontSize\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                        this.#color\n                    ]\n                ];\n            }\n            #updateFontSize(fontSize) {\n                const setFontsize = (size)=>{\n                    this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n                    this.translate(0, -(size - this.#fontSize) * this.parentScale);\n                    this.#fontSize = size;\n                    this.#setEditorDimensions();\n                };\n                const savedFontsize = this.#fontSize;\n                this.addCommands({\n                    cmd: ()=>{\n                        setFontsize(fontSize);\n                    },\n                    undo: ()=>{\n                        setFontsize(savedFontsize);\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            #updateColor(color) {\n                const savedColor = this.#color;\n                this.addCommands({\n                    cmd: ()=>{\n                        this.#color = this.editorDiv.style.color = color;\n                    },\n                    undo: ()=>{\n                        this.#color = this.editorDiv.style.color = savedColor;\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            _translateEmpty(x, y) {\n                this._uiManager.translateSelectedEditors(x, y, true);\n            }\n            getInitialTranslation() {\n                const scale = this.parentScale;\n                return [\n                    -FreeTextEditor._internalPadding * scale,\n                    -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n                ];\n            }\n            rebuild() {\n                if (!this.parent) {\n                    return;\n                }\n                super.rebuild();\n                if (this.div === null) {\n                    return;\n                }\n                if (!this.isAttachedToDOM) {\n                    this.parent.add(this);\n                }\n            }\n            enableEditMode() {\n                if (this.isInEditMode()) {\n                    return;\n                }\n                this.parent.setEditingState(false);\n                this.parent.updateToolbar(util.AnnotationEditorType.FREETEXT);\n                super.enableEditMode();\n                this.overlayDiv.classList.remove(\"enabled\");\n                this.editorDiv.contentEditable = true;\n                this._isDraggable = false;\n                this.div.removeAttribute(\"aria-activedescendant\");\n                this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n                this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n                this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n            }\n            disableEditMode() {\n                if (!this.isInEditMode()) {\n                    return;\n                }\n                this.parent.setEditingState(true);\n                super.disableEditMode();\n                this.overlayDiv.classList.add(\"enabled\");\n                this.editorDiv.contentEditable = false;\n                this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n                this._isDraggable = true;\n                this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n                this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n                this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n                this.div.focus({\n                    preventScroll: true\n                });\n                this.isEditing = false;\n                this.parent.div.classList.add(\"freetextEditing\");\n            }\n            focusin(event) {\n                if (!this._focusEventsAllowed) {\n                    return;\n                }\n                super.focusin(event);\n                if (event.target !== this.editorDiv) {\n                    this.editorDiv.focus();\n                }\n            }\n            onceAdded() {\n                if (this.width) {\n                    this.#cheatInitialRect();\n                    return;\n                }\n                this.enableEditMode();\n                this.editorDiv.focus();\n                if (this._initialOptions?.isCentered) {\n                    this.center();\n                }\n                this._initialOptions = null;\n            }\n            isEmpty() {\n                return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n            }\n            remove() {\n                this.isEditing = false;\n                if (this.parent) {\n                    this.parent.setEditingState(true);\n                    this.parent.div.classList.add(\"freetextEditing\");\n                }\n                super.remove();\n            }\n            #extractText() {\n                const divs = this.editorDiv.getElementsByTagName(\"div\");\n                if (divs.length === 0) {\n                    return this.editorDiv.innerText;\n                }\n                const buffer = [];\n                for (const div of divs){\n                    buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n                }\n                return buffer.join(\"\\n\");\n            }\n            #setEditorDimensions() {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                let rect;\n                if (this.isAttachedToDOM) {\n                    rect = this.div.getBoundingClientRect();\n                } else {\n                    const { currentLayer, div } = this;\n                    const savedDisplay = div.style.display;\n                    div.style.display = \"hidden\";\n                    currentLayer.div.append(this.div);\n                    rect = div.getBoundingClientRect();\n                    div.remove();\n                    div.style.display = savedDisplay;\n                }\n                if (this.rotation % 180 === this.parentRotation % 180) {\n                    this.width = rect.width / parentWidth;\n                    this.height = rect.height / parentHeight;\n                } else {\n                    this.width = rect.height / parentWidth;\n                    this.height = rect.width / parentHeight;\n                }\n                this.fixAndSetPosition();\n            }\n            commit() {\n                if (!this.isInEditMode()) {\n                    return;\n                }\n                super.commit();\n                this.disableEditMode();\n                const savedText = this.#content;\n                const newText = this.#content = this.#extractText().trimEnd();\n                if (savedText === newText) {\n                    return;\n                }\n                const setText = (text)=>{\n                    this.#content = text;\n                    if (!text) {\n                        this.remove();\n                        return;\n                    }\n                    this.#setContent();\n                    this._uiManager.rebuild(this);\n                    this.#setEditorDimensions();\n                };\n                this.addCommands({\n                    cmd: ()=>{\n                        setText(newText);\n                    },\n                    undo: ()=>{\n                        setText(savedText);\n                    },\n                    mustExec: false\n                });\n                this.#setEditorDimensions();\n            }\n            shouldGetKeyboardEvents() {\n                return this.isInEditMode();\n            }\n            enterInEditMode() {\n                this.enableEditMode();\n                this.editorDiv.focus();\n            }\n            dblclick(event) {\n                this.enterInEditMode();\n            }\n            keydown(event) {\n                if (event.target === this.div && event.key === \"Enter\") {\n                    this.enterInEditMode();\n                    event.preventDefault();\n                }\n            }\n            editorDivKeydown(event) {\n                FreeTextEditor._keyboardManager.exec(this, event);\n            }\n            editorDivFocus(event) {\n                this.isEditing = true;\n            }\n            editorDivBlur(event) {\n                this.isEditing = false;\n            }\n            editorDivInput(event) {\n                this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n            }\n            disableEditing() {\n                this.editorDiv.setAttribute(\"role\", \"comment\");\n                this.editorDiv.removeAttribute(\"aria-multiline\");\n            }\n            enableEditing() {\n                this.editorDiv.setAttribute(\"role\", \"textbox\");\n                this.editorDiv.setAttribute(\"aria-multiline\", true);\n            }\n            render() {\n                if (this.div) {\n                    return this.div;\n                }\n                let baseX, baseY;\n                if (this.width) {\n                    baseX = this.x;\n                    baseY = this.y;\n                }\n                super.render();\n                this.editorDiv = document.createElement(\"div\");\n                this.editorDiv.className = \"internal\";\n                this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n                this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text\");\n                this.enableEditing();\n                editor_editor.AnnotationEditor._l10nPromise.get(\"pdfjs-free-text-default-content\").then((msg)=>this.editorDiv?.setAttribute(\"default-content\", msg));\n                this.editorDiv.contentEditable = true;\n                const { style } = this.editorDiv;\n                style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n                style.color = this.#color;\n                this.div.append(this.editorDiv);\n                this.overlayDiv = document.createElement(\"div\");\n                this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n                this.div.append(this.overlayDiv);\n                (0, tools.bindEvents)(this, this.div, [\n                    \"dblclick\",\n                    \"keydown\"\n                ]);\n                if (this.width) {\n                    const [parentWidth, parentHeight] = this.parentDimensions;\n                    if (this.annotationElementId) {\n                        const { position } = this.#initialData;\n                        let [tx, ty] = this.getInitialTranslation();\n                        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        const [pageX, pageY] = this.pageTranslation;\n                        let posX, posY;\n                        switch(this.rotation){\n                            case 0:\n                                posX = baseX + (position[0] - pageX) / pageWidth;\n                                posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                                break;\n                            case 90:\n                                posX = baseX + (position[0] - pageX) / pageWidth;\n                                posY = baseY - (position[1] - pageY) / pageHeight;\n                                [tx, ty] = [\n                                    ty,\n                                    -tx\n                                ];\n                                break;\n                            case 180:\n                                posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                                posY = baseY - (position[1] - pageY) / pageHeight;\n                                [tx, ty] = [\n                                    -tx,\n                                    -ty\n                                ];\n                                break;\n                            case 270:\n                                posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                                posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                                [tx, ty] = [\n                                    -ty,\n                                    tx\n                                ];\n                                break;\n                        }\n                        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n                    } else {\n                        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                    }\n                    this.#setContent();\n                    this._isDraggable = true;\n                    this.editorDiv.contentEditable = false;\n                } else {\n                    this._isDraggable = false;\n                    this.editorDiv.contentEditable = true;\n                }\n                return this.div;\n            }\n            #setContent() {\n                this.editorDiv.replaceChildren();\n                if (!this.#content) {\n                    return;\n                }\n                for (const line of this.#content.split(\"\\n\")){\n                    const div = document.createElement(\"div\");\n                    div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n                    this.editorDiv.append(div);\n                }\n            }\n            get contentDiv() {\n                return this.editorDiv;\n            }\n            static deserialize(data, parent, uiManager) {\n                let initialData = null;\n                if (data instanceof annotation_layer.FreeTextAnnotationElement) {\n                    const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n                    if (!textContent || textContent.length === 0) {\n                        return null;\n                    }\n                    initialData = data = {\n                        annotationType: util.AnnotationEditorType.FREETEXT,\n                        color: Array.from(fontColor),\n                        fontSize,\n                        value: textContent.join(\"\\n\"),\n                        position: textPosition,\n                        pageIndex: pageNumber - 1,\n                        rect,\n                        rotation,\n                        id,\n                        deleted: false\n                    };\n                }\n                const editor = super.deserialize(data, parent, uiManager);\n                editor.#fontSize = data.fontSize;\n                editor.#color = util.Util.makeHexColor(...data.color);\n                editor.#content = data.value;\n                editor.annotationElementId = data.id || null;\n                editor.#initialData = initialData;\n                return editor;\n            }\n            serialize(isForCopying = false) {\n                if (this.isEmpty()) {\n                    return null;\n                }\n                if (this.deleted) {\n                    return {\n                        pageIndex: this.pageIndex,\n                        id: this.annotationElementId,\n                        deleted: true\n                    };\n                }\n                const padding = FreeTextEditor._internalPadding * this.parentScale;\n                const rect = this.getRect(padding, padding);\n                const color = editor_editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n                const serialized = {\n                    annotationType: util.AnnotationEditorType.FREETEXT,\n                    color,\n                    fontSize: this.#fontSize,\n                    value: this.#content,\n                    pageIndex: this.pageIndex,\n                    rect,\n                    rotation: this.rotation,\n                    structTreeParentId: this._structTreeParentId\n                };\n                if (isForCopying) {\n                    return serialized;\n                }\n                if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n                    return null;\n                }\n                serialized.id = this.annotationElementId;\n                return serialized;\n            }\n            #hasElementChanged(serialized) {\n                const { value, fontSize, color, rect, pageIndex } = this.#initialData;\n                return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i)=>Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n            }\n            #cheatInitialRect(delayed = false) {\n                if (!this.annotationElementId) {\n                    return;\n                }\n                this.#setEditorDimensions();\n                if (!delayed && (this.width === 0 || this.height === 0)) {\n                    setTimeout(()=>this.#cheatInitialRect(true), 0);\n                    return;\n                }\n                const padding = FreeTextEditor._internalPadding * this.parentScale;\n                this.#initialData.rect = this.getRect(padding, padding);\n            }\n        }\n        // EXTERNAL MODULE: ./src/display/editor/color_picker.js\n        var color_picker = __nested_webpack_require_400043__(97);\n        // EXTERNAL MODULE: ./src/display/editor/outliner.js\n        var editor_outliner = __nested_webpack_require_400043__(405);\n        ; // CONCATENATED MODULE: ./src/display/editor/highlight.js\n        class HighlightEditor extends editor_editor.AnnotationEditor {\n            #boxes;\n            #clipPathId;\n            #colorPicker;\n            #focusOutlines;\n            #highlightDiv;\n            #highlightOutlines;\n            #id;\n            #lastPoint;\n            #opacity;\n            #outlineId;\n            static{\n                this._defaultColor = null;\n            }\n            static{\n                this._defaultOpacity = 1;\n            }\n            static{\n                this._type = \"highlight\";\n            }\n            static{\n                this._editorType = util.AnnotationEditorType.HIGHLIGHT;\n            }\n            constructor(params){\n                super({\n                    ...params,\n                    name: \"highlightEditor\"\n                });\n                this.#clipPathId = null;\n                this.#colorPicker = null;\n                this.#focusOutlines = null;\n                this.#highlightDiv = null;\n                this.#highlightOutlines = null;\n                this.#id = null;\n                this.#lastPoint = null;\n                this.#outlineId = null;\n                HighlightEditor._defaultColor ||= this._uiManager.highlightColors?.values().next().value || \"#fff066\";\n                this.color = params.color || HighlightEditor._defaultColor;\n                this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n                this.#boxes = params.boxes || null;\n                this._isDraggable = false;\n                this.#createOutlines();\n                this.#addToDrawLayer();\n                this.rotate(this.rotation);\n            }\n            #createOutlines() {\n                const outliner = new editor_outliner.Outliner(this.#boxes, 0.001);\n                this.#highlightOutlines = outliner.getOutlines();\n                ({ x: this.x, y: this.y, width: this.width, height: this.height } = this.#highlightOutlines.box);\n                const outlinerForOutline = new editor_outliner.Outliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n                this.#focusOutlines = outlinerForOutline.getOutlines();\n                const { lastPoint } = this.#focusOutlines.box;\n                this.#lastPoint = [\n                    (lastPoint[0] - this.x) / this.width,\n                    (lastPoint[1] - this.y) / this.height\n                ];\n            }\n            static initialize(l10n) {\n                editor_editor.AnnotationEditor.initialize(l10n);\n            }\n            static updateDefaultParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                        HighlightEditor._defaultColor = value;\n                        break;\n                }\n            }\n            get toolbarPosition() {\n                return this.#lastPoint;\n            }\n            updateParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                        this.#updateColor(value);\n                        break;\n                }\n            }\n            static get defaultPropertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,\n                        HighlightEditor._defaultColor\n                    ]\n                ];\n            }\n            get propertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                        this.color || HighlightEditor._defaultColor\n                    ]\n                ];\n            }\n            #updateColor(color) {\n                const savedColor = this.color;\n                this.addCommands({\n                    cmd: ()=>{\n                        this.color = color;\n                        this.parent.drawLayer.changeColor(this.#id, color);\n                        this.#colorPicker?.updateColor(color);\n                    },\n                    undo: ()=>{\n                        this.color = savedColor;\n                        this.parent.drawLayer.changeColor(this.#id, savedColor);\n                        this.#colorPicker?.updateColor(savedColor);\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            async addEditToolbar() {\n                const toolbar = await super.addEditToolbar();\n                if (!toolbar) {\n                    return null;\n                }\n                if (this._uiManager.highlightColors) {\n                    this.#colorPicker = new color_picker.ColorPicker({\n                        editor: this\n                    });\n                    toolbar.addColorPicker(this.#colorPicker);\n                }\n                return toolbar;\n            }\n            disableEditing() {\n                super.disableEditing();\n                this.div.classList.toggle(\"disabled\", true);\n            }\n            enableEditing() {\n                super.enableEditing();\n                this.div.classList.toggle(\"disabled\", false);\n            }\n            fixAndSetPosition() {\n                return super.fixAndSetPosition(0);\n            }\n            getRect(tx, ty) {\n                return super.getRect(tx, ty, 0);\n            }\n            onceAdded() {\n                this.parent.addUndoableEditor(this);\n                this.div.focus();\n            }\n            remove() {\n                super.remove();\n                this.#cleanDrawLayer();\n            }\n            rebuild() {\n                if (!this.parent) {\n                    return;\n                }\n                super.rebuild();\n                if (this.div === null) {\n                    return;\n                }\n                this.#addToDrawLayer();\n                if (!this.isAttachedToDOM) {\n                    this.parent.add(this);\n                }\n            }\n            setParent(parent) {\n                let mustBeSelected = false;\n                if (this.parent && !parent) {\n                    this.#cleanDrawLayer();\n                } else if (parent) {\n                    this.#addToDrawLayer(parent);\n                    mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n                }\n                super.setParent(parent);\n                if (mustBeSelected) {\n                    this.select();\n                }\n            }\n            #cleanDrawLayer() {\n                if (this.#id === null || !this.parent) {\n                    return;\n                }\n                this.parent.drawLayer.remove(this.#id);\n                this.#id = null;\n                this.parent.drawLayer.remove(this.#outlineId);\n                this.#outlineId = null;\n            }\n            #addToDrawLayer(parent = this.parent) {\n                if (this.#id !== null) {\n                    return;\n                }\n                ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.highlight(this.#highlightOutlines, this.color, this.#opacity));\n                if (this.#highlightDiv) {\n                    this.#highlightDiv.style.clipPath = this.#clipPathId;\n                }\n                this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);\n            }\n            static #rotateBbox({ x, y, width, height }, angle) {\n                switch(angle){\n                    case 90:\n                        return {\n                            x: 1 - y - height,\n                            y: x,\n                            width: height,\n                            height: width\n                        };\n                    case 180:\n                        return {\n                            x: 1 - x - width,\n                            y: 1 - y - height,\n                            width,\n                            height\n                        };\n                    case 270:\n                        return {\n                            x: y,\n                            y: 1 - x - width,\n                            width: height,\n                            height: width\n                        };\n                }\n                return {\n                    x,\n                    y,\n                    width,\n                    height\n                };\n            }\n            rotate(angle) {\n                const { drawLayer } = this.parent;\n                drawLayer.rotate(this.#id, angle);\n                drawLayer.rotate(this.#outlineId, angle);\n                drawLayer.updateBox(this.#id, HighlightEditor.#rotateBbox(this, angle));\n                drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));\n            }\n            render() {\n                if (this.div) {\n                    return this.div;\n                }\n                const div = super.render();\n                const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n                div.append(highlightDiv);\n                highlightDiv.className = \"internal\";\n                highlightDiv.style.clipPath = this.#clipPathId;\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.setDims(this.width * parentWidth, this.height * parentHeight);\n                (0, tools.bindEvents)(this, this.#highlightDiv, [\n                    \"pointerover\",\n                    \"pointerleave\"\n                ]);\n                this.enableEditing();\n                return div;\n            }\n            pointerover() {\n                this.parent.drawLayer.addClass(this.#outlineId, \"hovered\");\n            }\n            pointerleave() {\n                this.parent.drawLayer.removeClass(this.#outlineId, \"hovered\");\n            }\n            select() {\n                super.select();\n                this.parent?.drawLayer.removeClass(this.#outlineId, \"hovered\");\n                this.parent?.drawLayer.addClass(this.#outlineId, \"selected\");\n            }\n            unselect() {\n                super.unselect();\n                this.parent?.drawLayer.removeClass(this.#outlineId, \"selected\");\n            }\n            #serializeBoxes() {\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const boxes = this.#boxes;\n                const quadPoints = new Array(boxes.length * 8);\n                let i = 0;\n                for (const { x, y, width, height } of boxes){\n                    const sx = x * pageWidth;\n                    const sy = (1 - y - height) * pageHeight;\n                    quadPoints[i] = quadPoints[i + 4] = sx;\n                    quadPoints[i + 1] = quadPoints[i + 3] = sy;\n                    quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n                    quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;\n                    i += 8;\n                }\n                return quadPoints;\n            }\n            #serializeOutlines() {\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const width = this.width * pageWidth;\n                const height = this.height * pageHeight;\n                const tx = this.x * pageWidth;\n                const ty = (1 - this.y - this.height) * pageHeight;\n                const outlines = [];\n                for (const outline of this.#highlightOutlines.outlines){\n                    const points = new Array(outline.length);\n                    for(let i = 0; i < outline.length; i += 2){\n                        points[i] = tx + outline[i] * width;\n                        points[i + 1] = ty + (1 - outline[i + 1]) * height;\n                    }\n                    outlines.push(points);\n                }\n                return outlines;\n            }\n            static deserialize(data, parent, uiManager) {\n                const editor = super.deserialize(data, parent, uiManager);\n                const { rect, color, quadPoints } = data;\n                editor.color = util.Util.makeHexColor(...color);\n                editor.#opacity = data.opacity;\n                const [pageWidth, pageHeight] = editor.pageDimensions;\n                editor.width = (rect[2] - rect[0]) / pageWidth;\n                editor.height = (rect[3] - rect[1]) / pageHeight;\n                const boxes = editor.#boxes = [];\n                for(let i = 0; i < quadPoints.length; i += 8){\n                    boxes.push({\n                        x: quadPoints[4] / pageWidth,\n                        y: 1 - quadPoints[i + 5] / pageHeight,\n                        width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                        height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight\n                    });\n                }\n                editor.#createOutlines();\n                return editor;\n            }\n            serialize(isForCopying = false) {\n                if (this.isEmpty() || isForCopying) {\n                    return null;\n                }\n                const rect = this.getRect(0, 0);\n                const color = editor_editor.AnnotationEditor._colorManager.convert(this.color);\n                return {\n                    annotationType: util.AnnotationEditorType.HIGHLIGHT,\n                    color,\n                    opacity: this.#opacity,\n                    quadPoints: this.#serializeBoxes(),\n                    outlines: this.#serializeOutlines(),\n                    pageIndex: this.pageIndex,\n                    rect,\n                    rotation: 0,\n                    structTreeParentId: this._structTreeParentId\n                };\n            }\n            static canCreateNewEmptyEditor() {\n                return false;\n            }\n        }\n        // EXTERNAL MODULE: ./src/display/display_utils.js\n        var display_utils = __nested_webpack_require_400043__(473);\n        ; // CONCATENATED MODULE: ./src/display/editor/ink.js\n        class InkEditor extends editor_editor.AnnotationEditor {\n            #baseHeight;\n            #baseWidth;\n            #boundCanvasPointermove;\n            #boundCanvasPointerleave;\n            #boundCanvasPointerup;\n            #boundCanvasPointerdown;\n            #canvasContextMenuTimeoutId;\n            #currentPath2D;\n            #disableEditing;\n            #hasSomethingToDraw;\n            #isCanvasInitialized;\n            #observer;\n            #realWidth;\n            #realHeight;\n            #requestFrameCallback;\n            static{\n                this._defaultColor = null;\n            }\n            static{\n                this._defaultOpacity = 1;\n            }\n            static{\n                this._defaultThickness = 1;\n            }\n            static{\n                this._type = \"ink\";\n            }\n            static{\n                this._editorType = util.AnnotationEditorType.INK;\n            }\n            constructor(params){\n                super({\n                    ...params,\n                    name: \"inkEditor\"\n                });\n                this.#baseHeight = 0;\n                this.#baseWidth = 0;\n                this.#boundCanvasPointermove = this.canvasPointermove.bind(this);\n                this.#boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n                this.#boundCanvasPointerup = this.canvasPointerup.bind(this);\n                this.#boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n                this.#canvasContextMenuTimeoutId = null;\n                this.#currentPath2D = new Path2D();\n                this.#disableEditing = false;\n                this.#hasSomethingToDraw = false;\n                this.#isCanvasInitialized = false;\n                this.#observer = null;\n                this.#realWidth = 0;\n                this.#realHeight = 0;\n                this.#requestFrameCallback = null;\n                this.color = params.color || null;\n                this.thickness = params.thickness || null;\n                this.opacity = params.opacity || null;\n                this.paths = [];\n                this.bezierPath2D = [];\n                this.allRawPaths = [];\n                this.currentPath = [];\n                this.scaleFactor = 1;\n                this.translationX = this.translationY = 0;\n                this.x = 0;\n                this.y = 0;\n                this._willKeepAspectRatio = true;\n            }\n            static initialize(l10n) {\n                editor_editor.AnnotationEditor.initialize(l10n);\n            }\n            static updateDefaultParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.INK_THICKNESS:\n                        InkEditor._defaultThickness = value;\n                        break;\n                    case util.AnnotationEditorParamsType.INK_COLOR:\n                        InkEditor._defaultColor = value;\n                        break;\n                    case util.AnnotationEditorParamsType.INK_OPACITY:\n                        InkEditor._defaultOpacity = value / 100;\n                        break;\n                }\n            }\n            updateParams(type, value) {\n                switch(type){\n                    case util.AnnotationEditorParamsType.INK_THICKNESS:\n                        this.#updateThickness(value);\n                        break;\n                    case util.AnnotationEditorParamsType.INK_COLOR:\n                        this.#updateColor(value);\n                        break;\n                    case util.AnnotationEditorParamsType.INK_OPACITY:\n                        this.#updateOpacity(value);\n                        break;\n                }\n            }\n            static get defaultPropertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.INK_THICKNESS,\n                        InkEditor._defaultThickness\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.INK_COLOR,\n                        InkEditor._defaultColor || editor_editor.AnnotationEditor._defaultLineColor\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.INK_OPACITY,\n                        Math.round(InkEditor._defaultOpacity * 100)\n                    ]\n                ];\n            }\n            get propertiesToUpdate() {\n                return [\n                    [\n                        util.AnnotationEditorParamsType.INK_THICKNESS,\n                        this.thickness || InkEditor._defaultThickness\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.INK_COLOR,\n                        this.color || InkEditor._defaultColor || editor_editor.AnnotationEditor._defaultLineColor\n                    ],\n                    [\n                        util.AnnotationEditorParamsType.INK_OPACITY,\n                        Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))\n                    ]\n                ];\n            }\n            #updateThickness(thickness) {\n                const savedThickness = this.thickness;\n                this.addCommands({\n                    cmd: ()=>{\n                        this.thickness = thickness;\n                        this.#fitToContent();\n                    },\n                    undo: ()=>{\n                        this.thickness = savedThickness;\n                        this.#fitToContent();\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.INK_THICKNESS,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            #updateColor(color) {\n                const savedColor = this.color;\n                this.addCommands({\n                    cmd: ()=>{\n                        this.color = color;\n                        this.#redraw();\n                    },\n                    undo: ()=>{\n                        this.color = savedColor;\n                        this.#redraw();\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.INK_COLOR,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            #updateOpacity(opacity) {\n                opacity /= 100;\n                const savedOpacity = this.opacity;\n                this.addCommands({\n                    cmd: ()=>{\n                        this.opacity = opacity;\n                        this.#redraw();\n                    },\n                    undo: ()=>{\n                        this.opacity = savedOpacity;\n                        this.#redraw();\n                    },\n                    mustExec: true,\n                    type: util.AnnotationEditorParamsType.INK_OPACITY,\n                    overwriteIfSameType: true,\n                    keepUndo: true\n                });\n            }\n            rebuild() {\n                if (!this.parent) {\n                    return;\n                }\n                super.rebuild();\n                if (this.div === null) {\n                    return;\n                }\n                if (!this.canvas) {\n                    this.#createCanvas();\n                    this.#createObserver();\n                }\n                if (!this.isAttachedToDOM) {\n                    this.parent.add(this);\n                    this.#setCanvasDims();\n                }\n                this.#fitToContent();\n            }\n            remove() {\n                if (this.canvas === null) {\n                    return;\n                }\n                if (!this.isEmpty()) {\n                    this.commit();\n                }\n                this.canvas.width = this.canvas.height = 0;\n                this.canvas.remove();\n                this.canvas = null;\n                if (this.#canvasContextMenuTimeoutId) {\n                    clearTimeout(this.#canvasContextMenuTimeoutId);\n                    this.#canvasContextMenuTimeoutId = null;\n                }\n                this.#observer.disconnect();\n                this.#observer = null;\n                super.remove();\n            }\n            setParent(parent) {\n                if (!this.parent && parent) {\n                    this._uiManager.removeShouldRescale(this);\n                } else if (this.parent && parent === null) {\n                    this._uiManager.addShouldRescale(this);\n                }\n                super.setParent(parent);\n            }\n            onScaleChanging() {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                const width = this.width * parentWidth;\n                const height = this.height * parentHeight;\n                this.setDimensions(width, height);\n            }\n            enableEditMode() {\n                if (this.#disableEditing || this.canvas === null) {\n                    return;\n                }\n                super.enableEditMode();\n                this._isDraggable = false;\n                this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n            }\n            disableEditMode() {\n                if (!this.isInEditMode() || this.canvas === null) {\n                    return;\n                }\n                super.disableEditMode();\n                this._isDraggable = !this.isEmpty();\n                this.div.classList.remove(\"editing\");\n                this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n            }\n            onceAdded() {\n                this._isDraggable = !this.isEmpty();\n            }\n            isEmpty() {\n                return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n            }\n            #getInitialBBox() {\n                const { parentRotation, parentDimensions: [width, height] } = this;\n                switch(parentRotation){\n                    case 90:\n                        return [\n                            0,\n                            height,\n                            height,\n                            width\n                        ];\n                    case 180:\n                        return [\n                            width,\n                            height,\n                            width,\n                            height\n                        ];\n                    case 270:\n                        return [\n                            width,\n                            0,\n                            height,\n                            width\n                        ];\n                    default:\n                        return [\n                            0,\n                            0,\n                            width,\n                            height\n                        ];\n                }\n            }\n            #setStroke() {\n                const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this;\n                ctx.lineWidth = thickness * parentScale / scaleFactor;\n                ctx.lineCap = \"round\";\n                ctx.lineJoin = \"round\";\n                ctx.miterLimit = 10;\n                ctx.strokeStyle = `${color}${(0, tools.opacityToHex)(opacity)}`;\n            }\n            #startDrawing(x, y) {\n                this.canvas.addEventListener(\"contextmenu\", display_utils.noContextMenu);\n                this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                this.isEditing = true;\n                if (!this.#isCanvasInitialized) {\n                    this.#isCanvasInitialized = true;\n                    this.#setCanvasDims();\n                    this.thickness ||= InkEditor._defaultThickness;\n                    this.color ||= InkEditor._defaultColor || editor_editor.AnnotationEditor._defaultLineColor;\n                    this.opacity ??= InkEditor._defaultOpacity;\n                }\n                this.currentPath.push([\n                    x,\n                    y\n                ]);\n                this.#hasSomethingToDraw = false;\n                this.#setStroke();\n                this.#requestFrameCallback = ()=>{\n                    this.#drawPoints();\n                    if (this.#requestFrameCallback) {\n                        window.requestAnimationFrame(this.#requestFrameCallback);\n                    }\n                };\n                window.requestAnimationFrame(this.#requestFrameCallback);\n            }\n            #draw(x, y) {\n                const [lastX, lastY] = this.currentPath.at(-1);\n                if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n                    return;\n                }\n                const currentPath = this.currentPath;\n                let path2D = this.#currentPath2D;\n                currentPath.push([\n                    x,\n                    y\n                ]);\n                this.#hasSomethingToDraw = true;\n                if (currentPath.length <= 2) {\n                    path2D.moveTo(...currentPath[0]);\n                    path2D.lineTo(x, y);\n                    return;\n                }\n                if (currentPath.length === 3) {\n                    this.#currentPath2D = path2D = new Path2D();\n                    path2D.moveTo(...currentPath[0]);\n                }\n                this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n            }\n            #endPath() {\n                if (this.currentPath.length === 0) {\n                    return;\n                }\n                const lastPoint = this.currentPath.at(-1);\n                this.#currentPath2D.lineTo(...lastPoint);\n            }\n            #stopDrawing(x, y) {\n                this.#requestFrameCallback = null;\n                x = Math.min(Math.max(x, 0), this.canvas.width);\n                y = Math.min(Math.max(y, 0), this.canvas.height);\n                this.#draw(x, y);\n                this.#endPath();\n                let bezier;\n                if (this.currentPath.length !== 1) {\n                    bezier = this.#generateBezierPoints();\n                } else {\n                    const xy = [\n                        x,\n                        y\n                    ];\n                    bezier = [\n                        [\n                            xy,\n                            xy.slice(),\n                            xy.slice(),\n                            xy\n                        ]\n                    ];\n                }\n                const path2D = this.#currentPath2D;\n                const currentPath = this.currentPath;\n                this.currentPath = [];\n                this.#currentPath2D = new Path2D();\n                const cmd = ()=>{\n                    this.allRawPaths.push(currentPath);\n                    this.paths.push(bezier);\n                    this.bezierPath2D.push(path2D);\n                    this.rebuild();\n                };\n                const undo = ()=>{\n                    this.allRawPaths.pop();\n                    this.paths.pop();\n                    this.bezierPath2D.pop();\n                    if (this.paths.length === 0) {\n                        this.remove();\n                    } else {\n                        if (!this.canvas) {\n                            this.#createCanvas();\n                            this.#createObserver();\n                        }\n                        this.#fitToContent();\n                    }\n                };\n                this.addCommands({\n                    cmd,\n                    undo,\n                    mustExec: true\n                });\n            }\n            #drawPoints() {\n                if (!this.#hasSomethingToDraw) {\n                    return;\n                }\n                this.#hasSomethingToDraw = false;\n                const thickness = Math.ceil(this.thickness * this.parentScale);\n                const lastPoints = this.currentPath.slice(-3);\n                const x = lastPoints.map((xy)=>xy[0]);\n                const y = lastPoints.map((xy)=>xy[1]);\n                const xMin = Math.min(...x) - thickness;\n                const xMax = Math.max(...x) + thickness;\n                const yMin = Math.min(...y) - thickness;\n                const yMax = Math.max(...y) + thickness;\n                const { ctx } = this;\n                ctx.save();\n                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                for (const path of this.bezierPath2D){\n                    ctx.stroke(path);\n                }\n                ctx.stroke(this.#currentPath2D);\n                ctx.restore();\n            }\n            #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n                const prevX = (x0 + x1) / 2;\n                const prevY = (y0 + y1) / 2;\n                const x3 = (x1 + x2) / 2;\n                const y3 = (y1 + y2) / 2;\n                path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n            }\n            #generateBezierPoints() {\n                const path = this.currentPath;\n                if (path.length <= 2) {\n                    return [\n                        [\n                            path[0],\n                            path[0],\n                            path.at(-1),\n                            path.at(-1)\n                        ]\n                    ];\n                }\n                const bezierPoints = [];\n                let i;\n                let [x0, y0] = path[0];\n                for(i = 1; i < path.length - 2; i++){\n                    const [x1, y1] = path[i];\n                    const [x2, y2] = path[i + 1];\n                    const x3 = (x1 + x2) / 2;\n                    const y3 = (y1 + y2) / 2;\n                    const control1 = [\n                        x0 + 2 * (x1 - x0) / 3,\n                        y0 + 2 * (y1 - y0) / 3\n                    ];\n                    const control2 = [\n                        x3 + 2 * (x1 - x3) / 3,\n                        y3 + 2 * (y1 - y3) / 3\n                    ];\n                    bezierPoints.push([\n                        [\n                            x0,\n                            y0\n                        ],\n                        control1,\n                        control2,\n                        [\n                            x3,\n                            y3\n                        ]\n                    ]);\n                    [x0, y0] = [\n                        x3,\n                        y3\n                    ];\n                }\n                const [x1, y1] = path[i];\n                const [x2, y2] = path[i + 1];\n                const control1 = [\n                    x0 + 2 * (x1 - x0) / 3,\n                    y0 + 2 * (y1 - y0) / 3\n                ];\n                const control2 = [\n                    x2 + 2 * (x1 - x2) / 3,\n                    y2 + 2 * (y1 - y2) / 3\n                ];\n                bezierPoints.push([\n                    [\n                        x0,\n                        y0\n                    ],\n                    control1,\n                    control2,\n                    [\n                        x2,\n                        y2\n                    ]\n                ]);\n                return bezierPoints;\n            }\n            #redraw() {\n                if (this.isEmpty()) {\n                    this.#updateTransform();\n                    return;\n                }\n                this.#setStroke();\n                const { canvas, ctx } = this;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                this.#updateTransform();\n                for (const path of this.bezierPath2D){\n                    ctx.stroke(path);\n                }\n            }\n            commit() {\n                if (this.#disableEditing) {\n                    return;\n                }\n                super.commit();\n                this.isEditing = false;\n                this.disableEditMode();\n                this.setInForeground();\n                this.#disableEditing = true;\n                this.div.classList.add(\"disabled\");\n                this.#fitToContent(true);\n                this.select();\n                this.parent.addInkEditorIfNeeded(true);\n                this.moveInDOM();\n                this.div.focus({\n                    preventScroll: true\n                });\n            }\n            focusin(event) {\n                if (!this._focusEventsAllowed) {\n                    return;\n                }\n                super.focusin(event);\n                this.enableEditMode();\n            }\n            canvasPointerdown(event) {\n                if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n                    return;\n                }\n                this.setInForeground();\n                event.preventDefault();\n                if (!this.div.contains(document.activeElement)) {\n                    this.div.focus({\n                        preventScroll: true\n                    });\n                }\n                this.#startDrawing(event.offsetX, event.offsetY);\n            }\n            canvasPointermove(event) {\n                event.preventDefault();\n                this.#draw(event.offsetX, event.offsetY);\n            }\n            canvasPointerup(event) {\n                event.preventDefault();\n                this.#endDrawing(event);\n            }\n            canvasPointerleave(event) {\n                this.#endDrawing(event);\n            }\n            #endDrawing(event) {\n                this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                if (this.#canvasContextMenuTimeoutId) {\n                    clearTimeout(this.#canvasContextMenuTimeoutId);\n                }\n                this.#canvasContextMenuTimeoutId = setTimeout(()=>{\n                    this.#canvasContextMenuTimeoutId = null;\n                    this.canvas.removeEventListener(\"contextmenu\", display_utils.noContextMenu);\n                }, 10);\n                this.#stopDrawing(event.offsetX, event.offsetY);\n                this.addToAnnotationStorage();\n                this.setInBackground();\n            }\n            #createCanvas() {\n                this.canvas = document.createElement(\"canvas\");\n                this.canvas.width = this.canvas.height = 0;\n                this.canvas.className = \"inkEditorCanvas\";\n                this.canvas.setAttribute(\"data-l10n-id\", \"pdfjs-ink-canvas\");\n                this.div.append(this.canvas);\n                this.ctx = this.canvas.getContext(\"2d\");\n            }\n            #createObserver() {\n                this.#observer = new ResizeObserver((entries)=>{\n                    const rect = entries[0].contentRect;\n                    if (rect.width && rect.height) {\n                        this.setDimensions(rect.width, rect.height);\n                    }\n                });\n                this.#observer.observe(this.div);\n            }\n            get isResizable() {\n                return !this.isEmpty() && this.#disableEditing;\n            }\n            render() {\n                if (this.div) {\n                    return this.div;\n                }\n                let baseX, baseY;\n                if (this.width) {\n                    baseX = this.x;\n                    baseY = this.y;\n                }\n                super.render();\n                this.div.setAttribute(\"data-l10n-id\", \"pdfjs-ink\");\n                const [x, y, w, h] = this.#getInitialBBox();\n                this.setAt(x, y, 0, 0);\n                this.setDims(w, h);\n                this.#createCanvas();\n                if (this.width) {\n                    const [parentWidth, parentHeight] = this.parentDimensions;\n                    this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                    this.#isCanvasInitialized = true;\n                    this.#setCanvasDims();\n                    this.setDims(this.width * parentWidth, this.height * parentHeight);\n                    this.#redraw();\n                    this.div.classList.add(\"disabled\");\n                } else {\n                    this.div.classList.add(\"editing\");\n                    this.enableEditMode();\n                }\n                this.#createObserver();\n                return this.div;\n            }\n            #setCanvasDims() {\n                if (!this.#isCanvasInitialized) {\n                    return;\n                }\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.canvas.width = Math.ceil(this.width * parentWidth);\n                this.canvas.height = Math.ceil(this.height * parentHeight);\n                this.#updateTransform();\n            }\n            setDimensions(width, height) {\n                const roundedWidth = Math.round(width);\n                const roundedHeight = Math.round(height);\n                if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n                    return;\n                }\n                this.#realWidth = roundedWidth;\n                this.#realHeight = roundedHeight;\n                this.canvas.style.visibility = \"hidden\";\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.width = width / parentWidth;\n                this.height = height / parentHeight;\n                this.fixAndSetPosition();\n                if (this.#disableEditing) {\n                    this.#setScaleFactor(width, height);\n                }\n                this.#setCanvasDims();\n                this.#redraw();\n                this.canvas.style.visibility = \"visible\";\n                this.fixDims();\n            }\n            #setScaleFactor(width, height) {\n                const padding = this.#getPadding();\n                const scaleFactorW = (width - padding) / this.#baseWidth;\n                const scaleFactorH = (height - padding) / this.#baseHeight;\n                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n            }\n            #updateTransform() {\n                const padding = this.#getPadding() / 2;\n                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n            }\n            static #buildPath2D(bezier) {\n                const path2D = new Path2D();\n                for(let i = 0, ii = bezier.length; i < ii; i++){\n                    const [first, control1, control2, second] = bezier[i];\n                    if (i === 0) {\n                        path2D.moveTo(...first);\n                    }\n                    path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n                }\n                return path2D;\n            }\n            static #toPDFCoordinates(points, rect, rotation) {\n                const [blX, blY, trX, trY] = rect;\n                switch(rotation){\n                    case 0:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            points[i] += blX;\n                            points[i + 1] = trY - points[i + 1];\n                        }\n                        break;\n                    case 90:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            const x = points[i];\n                            points[i] = points[i + 1] + blX;\n                            points[i + 1] = x + blY;\n                        }\n                        break;\n                    case 180:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            points[i] = trX - points[i];\n                            points[i + 1] += blY;\n                        }\n                        break;\n                    case 270:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            const x = points[i];\n                            points[i] = trX - points[i + 1];\n                            points[i + 1] = trY - x;\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Invalid rotation\");\n                }\n                return points;\n            }\n            static #fromPDFCoordinates(points, rect, rotation) {\n                const [blX, blY, trX, trY] = rect;\n                switch(rotation){\n                    case 0:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            points[i] -= blX;\n                            points[i + 1] = trY - points[i + 1];\n                        }\n                        break;\n                    case 90:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            const x = points[i];\n                            points[i] = points[i + 1] - blY;\n                            points[i + 1] = x - blX;\n                        }\n                        break;\n                    case 180:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            points[i] = trX - points[i];\n                            points[i + 1] -= blY;\n                        }\n                        break;\n                    case 270:\n                        for(let i = 0, ii = points.length; i < ii; i += 2){\n                            const x = points[i];\n                            points[i] = trY - points[i + 1];\n                            points[i + 1] = trX - x;\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Invalid rotation\");\n                }\n                return points;\n            }\n            #serializePaths(s, tx, ty, rect) {\n                const paths = [];\n                const padding = this.thickness / 2;\n                const shiftX = s * tx + padding;\n                const shiftY = s * ty + padding;\n                for (const bezier of this.paths){\n                    const buffer = [];\n                    const points = [];\n                    for(let j = 0, jj = bezier.length; j < jj; j++){\n                        const [first, control1, control2, second] = bezier[j];\n                        const p10 = s * first[0] + shiftX;\n                        const p11 = s * first[1] + shiftY;\n                        const p20 = s * control1[0] + shiftX;\n                        const p21 = s * control1[1] + shiftY;\n                        const p30 = s * control2[0] + shiftX;\n                        const p31 = s * control2[1] + shiftY;\n                        const p40 = s * second[0] + shiftX;\n                        const p41 = s * second[1] + shiftY;\n                        if (j === 0) {\n                            buffer.push(p10, p11);\n                            points.push(p10, p11);\n                        }\n                        buffer.push(p20, p21, p30, p31, p40, p41);\n                        points.push(p20, p21);\n                        if (j === jj - 1) {\n                            points.push(p40, p41);\n                        }\n                    }\n                    paths.push({\n                        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n                        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n                    });\n                }\n                return paths;\n            }\n            #getBbox() {\n                let xMin = Infinity;\n                let xMax = -Infinity;\n                let yMin = Infinity;\n                let yMax = -Infinity;\n                for (const path of this.paths){\n                    for (const [first, control1, control2, second] of path){\n                        const bbox = util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n                        xMin = Math.min(xMin, bbox[0]);\n                        yMin = Math.min(yMin, bbox[1]);\n                        xMax = Math.max(xMax, bbox[2]);\n                        yMax = Math.max(yMax, bbox[3]);\n                    }\n                }\n                return [\n                    xMin,\n                    yMin,\n                    xMax,\n                    yMax\n                ];\n            }\n            #getPadding() {\n                return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n            }\n            #fitToContent(firstTime = false) {\n                if (this.isEmpty()) {\n                    return;\n                }\n                if (!this.#disableEditing) {\n                    this.#redraw();\n                    return;\n                }\n                const bbox = this.#getBbox();\n                const padding = this.#getPadding();\n                this.#baseWidth = Math.max(editor_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                this.#baseHeight = Math.max(editor_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n                const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.width = width / parentWidth;\n                this.height = height / parentHeight;\n                this.setAspectRatio(width, height);\n                const prevTranslationX = this.translationX;\n                const prevTranslationY = this.translationY;\n                this.translationX = -bbox[0];\n                this.translationY = -bbox[1];\n                this.#setCanvasDims();\n                this.#redraw();\n                this.#realWidth = width;\n                this.#realHeight = height;\n                this.setDims(width, height);\n                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n            }\n            static deserialize(data, parent, uiManager) {\n                if (data instanceof annotation_layer.InkAnnotationElement) {\n                    return null;\n                }\n                const editor = super.deserialize(data, parent, uiManager);\n                editor.thickness = data.thickness;\n                editor.color = util.Util.makeHexColor(...data.color);\n                editor.opacity = data.opacity;\n                const [pageWidth, pageHeight] = editor.pageDimensions;\n                const width = editor.width * pageWidth;\n                const height = editor.height * pageHeight;\n                const scaleFactor = editor.parentScale;\n                const padding = data.thickness / 2;\n                editor.#disableEditing = true;\n                editor.#realWidth = Math.round(width);\n                editor.#realHeight = Math.round(height);\n                const { paths, rect, rotation } = data;\n                for (let { bezier } of paths){\n                    bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n                    const path = [];\n                    editor.paths.push(path);\n                    let p0 = scaleFactor * (bezier[0] - padding);\n                    let p1 = scaleFactor * (bezier[1] - padding);\n                    for(let i = 2, ii = bezier.length; i < ii; i += 6){\n                        const p10 = scaleFactor * (bezier[i] - padding);\n                        const p11 = scaleFactor * (bezier[i + 1] - padding);\n                        const p20 = scaleFactor * (bezier[i + 2] - padding);\n                        const p21 = scaleFactor * (bezier[i + 3] - padding);\n                        const p30 = scaleFactor * (bezier[i + 4] - padding);\n                        const p31 = scaleFactor * (bezier[i + 5] - padding);\n                        path.push([\n                            [\n                                p0,\n                                p1\n                            ],\n                            [\n                                p10,\n                                p11\n                            ],\n                            [\n                                p20,\n                                p21\n                            ],\n                            [\n                                p30,\n                                p31\n                            ]\n                        ]);\n                        p0 = p30;\n                        p1 = p31;\n                    }\n                    const path2D = this.#buildPath2D(path);\n                    editor.bezierPath2D.push(path2D);\n                }\n                const bbox = editor.#getBbox();\n                editor.#baseWidth = Math.max(editor_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                editor.#baseHeight = Math.max(editor_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                editor.#setScaleFactor(width, height);\n                return editor;\n            }\n            serialize() {\n                if (this.isEmpty()) {\n                    return null;\n                }\n                const rect = this.getRect(0, 0);\n                const color = editor_editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n                return {\n                    annotationType: util.AnnotationEditorType.INK,\n                    color,\n                    thickness: this.thickness,\n                    opacity: this.opacity,\n                    paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n                    pageIndex: this.pageIndex,\n                    rect,\n                    rotation: this.rotation,\n                    structTreeParentId: this._structTreeParentId\n                };\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/display/editor/stamp.js\n        class StampEditor extends editor_editor.AnnotationEditor {\n            #bitmap;\n            #bitmapId;\n            #bitmapPromise;\n            #bitmapUrl;\n            #bitmapFile;\n            #bitmapFileName;\n            #canvas;\n            #observer;\n            #resizeTimeoutId;\n            #isSvg;\n            #hasBeenAddedInUndoStack;\n            static{\n                this._type = \"stamp\";\n            }\n            static{\n                this._editorType = util.AnnotationEditorType.STAMP;\n            }\n            constructor(params){\n                super({\n                    ...params,\n                    name: \"stampEditor\"\n                });\n                this.#bitmap = null;\n                this.#bitmapId = null;\n                this.#bitmapPromise = null;\n                this.#bitmapUrl = null;\n                this.#bitmapFile = null;\n                this.#bitmapFileName = \"\";\n                this.#canvas = null;\n                this.#observer = null;\n                this.#resizeTimeoutId = null;\n                this.#isSvg = false;\n                this.#hasBeenAddedInUndoStack = false;\n                this.#bitmapUrl = params.bitmapUrl;\n                this.#bitmapFile = params.bitmapFile;\n            }\n            static initialize(l10n) {\n                editor_editor.AnnotationEditor.initialize(l10n);\n            }\n            static get supportedTypes() {\n                const types = [\n                    \"apng\",\n                    \"avif\",\n                    \"bmp\",\n                    \"gif\",\n                    \"jpeg\",\n                    \"png\",\n                    \"svg+xml\",\n                    \"webp\",\n                    \"x-icon\"\n                ];\n                return (0, util.shadow)(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n            }\n            static get supportedTypesStr() {\n                return (0, util.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n            }\n            static isHandlingMimeForPasting(mime) {\n                return this.supportedTypes.includes(mime);\n            }\n            static paste(item, parent) {\n                parent.pasteEditor(util.AnnotationEditorType.STAMP, {\n                    bitmapFile: item.getAsFile()\n                });\n            }\n            #getBitmapFetched(data, fromId = false) {\n                if (!data) {\n                    this.remove();\n                    return;\n                }\n                this.#bitmap = data.bitmap;\n                if (!fromId) {\n                    this.#bitmapId = data.id;\n                    this.#isSvg = data.isSvg;\n                }\n                if (data.file) {\n                    this.#bitmapFileName = data.file.name;\n                }\n                this.#createCanvas();\n            }\n            #getBitmapDone() {\n                this.#bitmapPromise = null;\n                this._uiManager.enableWaiting(false);\n                if (this.#canvas) {\n                    this.div.focus();\n                }\n            }\n            #getBitmap() {\n                if (this.#bitmapId) {\n                    this._uiManager.enableWaiting(true);\n                    this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n                    return;\n                }\n                if (this.#bitmapUrl) {\n                    const url = this.#bitmapUrl;\n                    this.#bitmapUrl = null;\n                    this._uiManager.enableWaiting(true);\n                    this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                    return;\n                }\n                if (this.#bitmapFile) {\n                    const file = this.#bitmapFile;\n                    this.#bitmapFile = null;\n                    this._uiManager.enableWaiting(true);\n                    this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                    return;\n                }\n                const input = document.createElement(\"input\");\n                input.type = \"file\";\n                input.accept = StampEditor.supportedTypesStr;\n                this.#bitmapPromise = new Promise((resolve)=>{\n                    input.addEventListener(\"change\", async ()=>{\n                        if (!input.files || input.files.length === 0) {\n                            this.remove();\n                        } else {\n                            this._uiManager.enableWaiting(true);\n                            const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                            this.#getBitmapFetched(data);\n                        }\n                        resolve();\n                    });\n                    input.addEventListener(\"cancel\", ()=>{\n                        this.remove();\n                        resolve();\n                    });\n                }).finally(()=>this.#getBitmapDone());\n                input.click();\n            }\n            remove() {\n                if (this.#bitmapId) {\n                    this.#bitmap = null;\n                    this._uiManager.imageManager.deleteId(this.#bitmapId);\n                    this.#canvas?.remove();\n                    this.#canvas = null;\n                    this.#observer?.disconnect();\n                    this.#observer = null;\n                    if (this.#resizeTimeoutId) {\n                        clearTimeout(this.#resizeTimeoutId);\n                        this.#resizeTimeoutId = null;\n                    }\n                }\n                super.remove();\n            }\n            rebuild() {\n                if (!this.parent) {\n                    if (this.#bitmapId) {\n                        this.#getBitmap();\n                    }\n                    return;\n                }\n                super.rebuild();\n                if (this.div === null) {\n                    return;\n                }\n                if (this.#bitmapId) {\n                    this.#getBitmap();\n                }\n                if (!this.isAttachedToDOM) {\n                    this.parent.add(this);\n                }\n            }\n            onceAdded() {\n                this._isDraggable = true;\n                this.div.focus();\n            }\n            isEmpty() {\n                return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n            }\n            get isResizable() {\n                return true;\n            }\n            render() {\n                if (this.div) {\n                    return this.div;\n                }\n                let baseX, baseY;\n                if (this.width) {\n                    baseX = this.x;\n                    baseY = this.y;\n                }\n                super.render();\n                this.div.hidden = true;\n                if (this.#bitmap) {\n                    this.#createCanvas();\n                } else {\n                    this.#getBitmap();\n                }\n                if (this.width) {\n                    const [parentWidth, parentHeight] = this.parentDimensions;\n                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                }\n                return this.div;\n            }\n            #createCanvas() {\n                const { div } = this;\n                let { width, height } = this.#bitmap;\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const MAX_RATIO = 0.75;\n                if (this.width) {\n                    width = this.width * pageWidth;\n                    height = this.height * pageHeight;\n                } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n                    const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n                    width *= factor;\n                    height *= factor;\n                }\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n                this._uiManager.enableWaiting(false);\n                const canvas = this.#canvas = document.createElement(\"canvas\");\n                div.append(canvas);\n                div.hidden = false;\n                this.#drawBitmap(width, height);\n                this.#createObserver();\n                if (!this.#hasBeenAddedInUndoStack) {\n                    this.parent.addUndoableEditor(this);\n                    this.#hasBeenAddedInUndoStack = true;\n                }\n                this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        subtype: this.editorType,\n                        data: {\n                            action: \"inserted_image\"\n                        }\n                    }\n                });\n                this.addAltTextButton();\n                if (this.#bitmapFileName) {\n                    canvas.setAttribute(\"aria-label\", this.#bitmapFileName);\n                }\n            }\n            #setDimensions(width, height) {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.width = width / parentWidth;\n                this.height = height / parentHeight;\n                this.setDims(width, height);\n                if (this._initialOptions?.isCentered) {\n                    this.center();\n                } else {\n                    this.fixAndSetPosition();\n                }\n                this._initialOptions = null;\n                if (this.#resizeTimeoutId !== null) {\n                    clearTimeout(this.#resizeTimeoutId);\n                }\n                const TIME_TO_WAIT = 200;\n                this.#resizeTimeoutId = setTimeout(()=>{\n                    this.#resizeTimeoutId = null;\n                    this.#drawBitmap(width, height);\n                }, TIME_TO_WAIT);\n            }\n            #scaleBitmap(width, height) {\n                const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n                let newWidth = bitmapWidth;\n                let newHeight = bitmapHeight;\n                let bitmap = this.#bitmap;\n                while(newWidth > 2 * width || newHeight > 2 * height){\n                    const prevWidth = newWidth;\n                    const prevHeight = newHeight;\n                    if (newWidth > 2 * width) {\n                        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n                    }\n                    if (newHeight > 2 * height) {\n                        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n                    }\n                    const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                    const ctx = offscreen.getContext(\"2d\");\n                    ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                    bitmap = offscreen.transferToImageBitmap();\n                }\n                return bitmap;\n            }\n            #drawBitmap(width, height) {\n                width = Math.ceil(width);\n                height = Math.ceil(height);\n                const canvas = this.#canvas;\n                if (!canvas || canvas.width === width && canvas.height === height) {\n                    return;\n                }\n                canvas.width = width;\n                canvas.height = height;\n                const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);\n                const ctx = canvas.getContext(\"2d\");\n                ctx.filter = this._uiManager.hcmFilter;\n                ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n            }\n            getImageForAltText() {\n                return this.#canvas;\n            }\n            #serializeBitmap(toUrl) {\n                if (toUrl) {\n                    if (this.#isSvg) {\n                        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                        if (url) {\n                            return url;\n                        }\n                    }\n                    const canvas = document.createElement(\"canvas\");\n                    ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n                    const ctx = canvas.getContext(\"2d\");\n                    ctx.drawImage(this.#bitmap, 0, 0);\n                    return canvas.toDataURL();\n                }\n                if (this.#isSvg) {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    const width = Math.round(this.width * pageWidth * display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                    const height = Math.round(this.height * pageHeight * display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                    const offscreen = new OffscreenCanvas(width, height);\n                    const ctx = offscreen.getContext(\"2d\");\n                    ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n                    return offscreen.transferToImageBitmap();\n                }\n                return structuredClone(this.#bitmap);\n            }\n            #createObserver() {\n                this.#observer = new ResizeObserver((entries)=>{\n                    const rect = entries[0].contentRect;\n                    if (rect.width && rect.height) {\n                        this.#setDimensions(rect.width, rect.height);\n                    }\n                });\n                this.#observer.observe(this.div);\n            }\n            static deserialize(data, parent, uiManager) {\n                if (data instanceof annotation_layer.StampAnnotationElement) {\n                    return null;\n                }\n                const editor = super.deserialize(data, parent, uiManager);\n                const { rect, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n                if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n                    editor.#bitmapId = bitmapId;\n                } else {\n                    editor.#bitmapUrl = bitmapUrl;\n                }\n                editor.#isSvg = isSvg;\n                const [parentWidth, parentHeight] = editor.pageDimensions;\n                editor.width = (rect[2] - rect[0]) / parentWidth;\n                editor.height = (rect[3] - rect[1]) / parentHeight;\n                if (accessibilityData) {\n                    editor.altTextData = accessibilityData;\n                }\n                return editor;\n            }\n            serialize(isForCopying = false, context = null) {\n                if (this.isEmpty()) {\n                    return null;\n                }\n                const serialized = {\n                    annotationType: util.AnnotationEditorType.STAMP,\n                    bitmapId: this.#bitmapId,\n                    pageIndex: this.pageIndex,\n                    rect: this.getRect(0, 0),\n                    rotation: this.rotation,\n                    isSvg: this.#isSvg,\n                    structTreeParentId: this._structTreeParentId\n                };\n                if (isForCopying) {\n                    serialized.bitmapUrl = this.#serializeBitmap(true);\n                    serialized.accessibilityData = this.altTextData;\n                    return serialized;\n                }\n                const { decorative, altText } = this.altTextData;\n                if (!decorative && altText) {\n                    serialized.accessibilityData = {\n                        type: \"Figure\",\n                        alt: altText\n                    };\n                }\n                if (context === null) {\n                    return serialized;\n                }\n                context.stamps ||= new Map();\n                const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n                if (!context.stamps.has(this.#bitmapId)) {\n                    context.stamps.set(this.#bitmapId, {\n                        area,\n                        serialized\n                    });\n                    serialized.bitmap = this.#serializeBitmap(false);\n                } else if (this.#isSvg) {\n                    const prevData = context.stamps.get(this.#bitmapId);\n                    if (area > prevData.area) {\n                        prevData.area = area;\n                        prevData.serialized.bitmap.close();\n                        prevData.serialized.bitmap = this.#serializeBitmap(false);\n                    }\n                }\n                return serialized;\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/display/editor/annotation_editor_layer.js\n        class AnnotationEditorLayer {\n            #accessibilityManager;\n            #allowClick;\n            #annotationLayer;\n            #boundPointerup;\n            #boundPointerUpAfterSelection;\n            #boundPointerdown;\n            #editorFocusTimeoutId;\n            #boundSelectionStart;\n            #editors;\n            #hadPointerDown;\n            #isCleaningUp;\n            #isDisabling;\n            #textLayer;\n            #uiManager;\n            static{\n                this._initialized = false;\n            }\n            static #editorTypes = new Map([\n                FreeTextEditor,\n                InkEditor,\n                StampEditor,\n                HighlightEditor\n            ].map((type)=>[\n                    type._editorType,\n                    type\n                ]));\n            constructor({ uiManager, pageIndex, div, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n                this.#allowClick = false;\n                this.#annotationLayer = null;\n                this.#boundPointerup = this.pointerup.bind(this);\n                this.#boundPointerUpAfterSelection = this.pointerUpAfterSelection.bind(this);\n                this.#boundPointerdown = this.pointerdown.bind(this);\n                this.#editorFocusTimeoutId = null;\n                this.#boundSelectionStart = this.selectionStart.bind(this);\n                this.#editors = new Map();\n                this.#hadPointerDown = false;\n                this.#isCleaningUp = false;\n                this.#isDisabling = false;\n                this.#textLayer = null;\n                const editorTypes = [\n                    ...AnnotationEditorLayer.#editorTypes.values()\n                ];\n                if (!AnnotationEditorLayer._initialized) {\n                    AnnotationEditorLayer._initialized = true;\n                    for (const editorType of editorTypes){\n                        editorType.initialize(l10n);\n                    }\n                }\n                uiManager.registerEditorTypes(editorTypes);\n                this.#uiManager = uiManager;\n                this.pageIndex = pageIndex;\n                this.div = div;\n                this.#accessibilityManager = accessibilityManager;\n                this.#annotationLayer = annotationLayer;\n                this.viewport = viewport;\n                this.#textLayer = textLayer;\n                this.drawLayer = drawLayer;\n                this.#uiManager.addLayer(this);\n            }\n            get isEmpty() {\n                return this.#editors.size === 0;\n            }\n            updateToolbar(mode) {\n                this.#uiManager.updateToolbar(mode);\n            }\n            updateMode(mode = this.#uiManager.getMode()) {\n                this.#cleanup();\n                switch(mode){\n                    case util.AnnotationEditorType.NONE:\n                        this.disableTextSelection();\n                        this.togglePointerEvents(false);\n                        this.disableClick();\n                        break;\n                    case util.AnnotationEditorType.INK:\n                        this.addInkEditorIfNeeded(false);\n                        this.disableTextSelection();\n                        this.togglePointerEvents(true);\n                        this.disableClick();\n                        break;\n                    case util.AnnotationEditorType.HIGHLIGHT:\n                        this.enableTextSelection();\n                        this.togglePointerEvents(false);\n                        this.disableClick();\n                        break;\n                    default:\n                        this.disableTextSelection();\n                        this.togglePointerEvents(true);\n                        this.enableClick();\n                }\n                if (mode !== util.AnnotationEditorType.NONE) {\n                    const { classList } = this.div;\n                    for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n                        classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n                    }\n                    this.div.hidden = false;\n                }\n            }\n            addInkEditorIfNeeded(isCommitting) {\n                if (this.#uiManager.getMode() !== util.AnnotationEditorType.INK) {\n                    return;\n                }\n                if (!isCommitting) {\n                    for (const editor of this.#editors.values()){\n                        if (editor.isEmpty()) {\n                            editor.setInBackground();\n                            return;\n                        }\n                    }\n                }\n                const editor = this.#createAndAddNewEditor({\n                    offsetX: 0,\n                    offsetY: 0\n                }, false);\n                editor.setInBackground();\n            }\n            setEditingState(isEditing) {\n                this.#uiManager.setEditingState(isEditing);\n            }\n            addCommands(params) {\n                this.#uiManager.addCommands(params);\n            }\n            togglePointerEvents(enabled = false) {\n                this.div.classList.toggle(\"disabled\", !enabled);\n            }\n            enable() {\n                this.togglePointerEvents(true);\n                const annotationElementIds = new Set();\n                for (const editor of this.#editors.values()){\n                    editor.enableEditing();\n                    if (editor.annotationElementId) {\n                        annotationElementIds.add(editor.annotationElementId);\n                    }\n                }\n                if (!this.#annotationLayer) {\n                    return;\n                }\n                const editables = this.#annotationLayer.getEditableAnnotations();\n                for (const editable of editables){\n                    editable.hide();\n                    if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                        continue;\n                    }\n                    if (annotationElementIds.has(editable.data.id)) {\n                        continue;\n                    }\n                    const editor = this.deserialize(editable);\n                    if (!editor) {\n                        continue;\n                    }\n                    this.addOrRebuild(editor);\n                    editor.enableEditing();\n                }\n            }\n            disable() {\n                this.#isDisabling = true;\n                this.togglePointerEvents(false);\n                const hiddenAnnotationIds = new Set();\n                for (const editor of this.#editors.values()){\n                    editor.disableEditing();\n                    if (!editor.annotationElementId || editor.serialize() !== null) {\n                        hiddenAnnotationIds.add(editor.annotationElementId);\n                        continue;\n                    }\n                    this.getEditableAnnotation(editor.annotationElementId)?.show();\n                    editor.remove();\n                }\n                if (this.#annotationLayer) {\n                    const editables = this.#annotationLayer.getEditableAnnotations();\n                    for (const editable of editables){\n                        const { id } = editable.data;\n                        if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {\n                            continue;\n                        }\n                        editable.show();\n                    }\n                }\n                this.#cleanup();\n                if (this.isEmpty) {\n                    this.div.hidden = true;\n                }\n                const { classList } = this.div;\n                for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n                    classList.remove(`${editorType._type}Editing`);\n                }\n                this.disableTextSelection();\n                this.#isDisabling = false;\n            }\n            getEditableAnnotation(id) {\n                return this.#annotationLayer?.getEditableAnnotation(id) || null;\n            }\n            setActiveEditor(editor) {\n                const currentActive = this.#uiManager.getActive();\n                if (currentActive === editor) {\n                    return;\n                }\n                this.#uiManager.setActiveEditor(editor);\n            }\n            enableTextSelection() {\n                if (this.#textLayer?.div) {\n                    document.addEventListener(\"selectstart\", this.#boundSelectionStart);\n                }\n            }\n            disableTextSelection() {\n                if (this.#textLayer?.div) {\n                    document.removeEventListener(\"selectstart\", this.#boundSelectionStart);\n                }\n            }\n            enableClick() {\n                this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n                this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n            }\n            disableClick() {\n                this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n                this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n            }\n            attach(editor) {\n                this.#editors.set(editor.id, editor);\n                const { annotationElementId } = editor;\n                if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n                    this.#uiManager.removeDeletedAnnotationElement(editor);\n                }\n            }\n            detach(editor) {\n                this.#editors.delete(editor.id);\n                this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                if (!this.#isDisabling && editor.annotationElementId) {\n                    this.#uiManager.addDeletedAnnotationElement(editor);\n                }\n            }\n            remove(editor) {\n                this.detach(editor);\n                this.#uiManager.removeEditor(editor);\n                editor.div.remove();\n                editor.isAttachedToDOM = false;\n                if (!this.#isCleaningUp) {\n                    this.addInkEditorIfNeeded(false);\n                }\n            }\n            changeParent(editor) {\n                if (editor.parent === this) {\n                    return;\n                }\n                if (editor.annotationElementId) {\n                    this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n                    editor_editor.AnnotationEditor.deleteAnnotationElement(editor);\n                    editor.annotationElementId = null;\n                }\n                this.attach(editor);\n                editor.parent?.detach(editor);\n                editor.setParent(this);\n                if (editor.div && editor.isAttachedToDOM) {\n                    editor.div.remove();\n                    this.div.append(editor.div);\n                }\n            }\n            add(editor) {\n                this.changeParent(editor);\n                this.#uiManager.addEditor(editor);\n                this.attach(editor);\n                if (!editor.isAttachedToDOM) {\n                    const div = editor.render();\n                    this.div.append(div);\n                    editor.isAttachedToDOM = true;\n                }\n                editor.fixAndSetPosition();\n                editor.onceAdded();\n                this.#uiManager.addToAnnotationStorage(editor);\n            }\n            moveEditorInDOM(editor) {\n                if (!editor.isAttachedToDOM) {\n                    return;\n                }\n                const { activeElement } = document;\n                if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n                    editor._focusEventsAllowed = false;\n                    this.#editorFocusTimeoutId = setTimeout(()=>{\n                        this.#editorFocusTimeoutId = null;\n                        if (!editor.div.contains(document.activeElement)) {\n                            editor.div.addEventListener(\"focusin\", ()=>{\n                                editor._focusEventsAllowed = true;\n                            }, {\n                                once: true\n                            });\n                            activeElement.focus();\n                        } else {\n                            editor._focusEventsAllowed = true;\n                        }\n                    }, 0);\n                }\n                editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n            }\n            addOrRebuild(editor) {\n                if (editor.needsToBeRebuilt()) {\n                    editor.parent ||= this;\n                    editor.rebuild();\n                } else {\n                    this.add(editor);\n                }\n            }\n            addUndoableEditor(editor) {\n                const cmd = ()=>editor._uiManager.rebuild(editor);\n                const undo = ()=>{\n                    editor.remove();\n                };\n                this.addCommands({\n                    cmd,\n                    undo,\n                    mustExec: false\n                });\n            }\n            getNextId() {\n                return this.#uiManager.getId();\n            }\n            get #currentEditorType() {\n                return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n            }\n            #createNewEditor(params) {\n                const editorType = this.#currentEditorType;\n                return editorType ? new editorType.prototype.constructor(params) : null;\n            }\n            canCreateNewEmptyEditor() {\n                return this.#currentEditorType?.canCreateNewEmptyEditor();\n            }\n            pasteEditor(mode, params) {\n                this.#uiManager.updateToolbar(mode);\n                this.#uiManager.updateMode(mode);\n                const { offsetX, offsetY } = this.#getCenterPoint();\n                const id = this.getNextId();\n                const editor = this.#createNewEditor({\n                    parent: this,\n                    id,\n                    x: offsetX,\n                    y: offsetY,\n                    uiManager: this.#uiManager,\n                    isCentered: true,\n                    ...params\n                });\n                if (editor) {\n                    this.add(editor);\n                }\n            }\n            deserialize(data) {\n                return AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n            }\n            #createAndAddNewEditor(event, isCentered, data = {}) {\n                const id = this.getNextId();\n                const editor = this.#createNewEditor({\n                    parent: this,\n                    id,\n                    x: event.offsetX,\n                    y: event.offsetY,\n                    uiManager: this.#uiManager,\n                    isCentered,\n                    ...data\n                });\n                if (editor) {\n                    this.add(editor);\n                }\n                return editor;\n            }\n            #getCenterPoint() {\n                const { x, y, width, height } = this.div.getBoundingClientRect();\n                const tlX = Math.max(0, x);\n                const tlY = Math.max(0, y);\n                const brX = Math.min(window.innerWidth, x + width);\n                const brY = Math.min(window.innerHeight, y + height);\n                const centerX = (tlX + brX) / 2 - x;\n                const centerY = (tlY + brY) / 2 - y;\n                const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n                    centerX,\n                    centerY\n                ] : [\n                    centerY,\n                    centerX\n                ];\n                return {\n                    offsetX,\n                    offsetY\n                };\n            }\n            addNewEditor() {\n                this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n            }\n            setSelected(editor) {\n                this.#uiManager.setSelected(editor);\n            }\n            toggleSelected(editor) {\n                this.#uiManager.toggleSelected(editor);\n            }\n            isSelected(editor) {\n                return this.#uiManager.isSelected(editor);\n            }\n            unselect(editor) {\n                this.#uiManager.unselect(editor);\n            }\n            selectionStart(_event) {\n                this.#textLayer?.div.addEventListener(\"pointerup\", this.#boundPointerUpAfterSelection, {\n                    once: true\n                });\n            }\n            pointerUpAfterSelection(event) {\n                const selection = document.getSelection();\n                if (selection.rangeCount === 0) {\n                    return;\n                }\n                const range = selection.getRangeAt(0);\n                if (range.collapsed) {\n                    return;\n                }\n                if (!this.#textLayer?.div.contains(range.commonAncestorContainer)) {\n                    return;\n                }\n                const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = this.#textLayer.div.getBoundingClientRect();\n                const bboxes = range.getClientRects();\n                let rotator;\n                switch(this.viewport.rotation){\n                    case 90:\n                        rotator = (x, y, w, h)=>({\n                                x: (y - layerY) / parentHeight,\n                                y: 1 - (x + w - layerX) / parentWidth,\n                                width: h / parentHeight,\n                                height: w / parentWidth\n                            });\n                        break;\n                    case 180:\n                        rotator = (x, y, w, h)=>({\n                                x: 1 - (x + w - layerX) / parentWidth,\n                                y: 1 - (y + h - layerY) / parentHeight,\n                                width: w / parentWidth,\n                                height: h / parentHeight\n                            });\n                        break;\n                    case 270:\n                        rotator = (x, y, w, h)=>({\n                                x: 1 - (y + h - layerY) / parentHeight,\n                                y: (x - layerX) / parentWidth,\n                                width: h / parentHeight,\n                                height: w / parentWidth\n                            });\n                        break;\n                    default:\n                        rotator = (x, y, w, h)=>({\n                                x: (x - layerX) / parentWidth,\n                                y: (y - layerY) / parentHeight,\n                                width: w / parentWidth,\n                                height: h / parentHeight\n                            });\n                        break;\n                }\n                const boxes = [];\n                for (const { x, y, width, height } of bboxes){\n                    if (width === 0 || height === 0) {\n                        continue;\n                    }\n                    boxes.push(rotator(x, y, width, height));\n                }\n                if (boxes.length !== 0) {\n                    this.#createAndAddNewEditor(event, false, {\n                        boxes\n                    });\n                }\n                selection.empty();\n            }\n            pointerup(event) {\n                const { isMac } = util.FeatureTest.platform;\n                if (event.button !== 0 || event.ctrlKey && isMac) {\n                    return;\n                }\n                if (event.target !== this.div) {\n                    return;\n                }\n                if (!this.#hadPointerDown) {\n                    return;\n                }\n                this.#hadPointerDown = false;\n                if (!this.#allowClick) {\n                    this.#allowClick = true;\n                    return;\n                }\n                if (this.#uiManager.getMode() === util.AnnotationEditorType.STAMP) {\n                    this.#uiManager.unselectAll();\n                    return;\n                }\n                this.#createAndAddNewEditor(event, false);\n            }\n            pointerdown(event) {\n                if (this.#uiManager.getMode() === util.AnnotationEditorType.HIGHLIGHT) {\n                    this.enableTextSelection();\n                }\n                if (this.#hadPointerDown) {\n                    this.#hadPointerDown = false;\n                    return;\n                }\n                const { isMac } = util.FeatureTest.platform;\n                if (event.button !== 0 || event.ctrlKey && isMac) {\n                    return;\n                }\n                if (event.target !== this.div) {\n                    return;\n                }\n                this.#hadPointerDown = true;\n                const editor = this.#uiManager.getActive();\n                this.#allowClick = !editor || editor.isEmpty();\n            }\n            findNewParent(editor, x, y) {\n                const layer = this.#uiManager.findParent(x, y);\n                if (layer === null || layer === this) {\n                    return false;\n                }\n                layer.changeParent(editor);\n                return true;\n            }\n            destroy() {\n                if (this.#uiManager.getActive()?.parent === this) {\n                    this.#uiManager.commitOrRemove();\n                    this.#uiManager.setActiveEditor(null);\n                }\n                if (this.#editorFocusTimeoutId) {\n                    clearTimeout(this.#editorFocusTimeoutId);\n                    this.#editorFocusTimeoutId = null;\n                }\n                for (const editor of this.#editors.values()){\n                    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                    editor.setParent(null);\n                    editor.isAttachedToDOM = false;\n                    editor.div.remove();\n                }\n                this.div = null;\n                this.#editors.clear();\n                this.#uiManager.removeLayer(this);\n            }\n            #cleanup() {\n                this.#isCleaningUp = true;\n                for (const editor of this.#editors.values()){\n                    if (editor.isEmpty()) {\n                        editor.remove();\n                    }\n                }\n                this.#isCleaningUp = false;\n            }\n            render({ viewport }) {\n                this.viewport = viewport;\n                (0, display_utils.setLayerDimensions)(this.div, viewport);\n                for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n                    this.add(editor);\n                }\n                this.updateMode();\n            }\n            update({ viewport }) {\n                this.#uiManager.commitOrRemove();\n                const oldRotation = this.viewport.rotation;\n                const rotation = viewport.rotation;\n                this.viewport = viewport;\n                (0, display_utils.setLayerDimensions)(this.div, {\n                    rotation\n                });\n                if (oldRotation !== rotation) {\n                    for (const editor of this.#editors.values()){\n                        editor.rotate(rotation);\n                    }\n                }\n                this.updateMode();\n            }\n            get pageDimensions() {\n                const { pageWidth, pageHeight } = this.viewport.rawDims;\n                return [\n                    pageWidth,\n                    pageHeight\n                ];\n            }\n        }\n    /***/ },\n    /***/ 97: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_521775__)=>{\n        /* harmony export */ __nested_webpack_require_521775__.d(__nested_webpack_exports__, {\n            /* harmony export */ ColorPicker: ()=>/* binding */ ColorPicker\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_521775__(266);\n        /* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_521775__(812);\n        /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_521775__(473);\n        class ColorPicker {\n            #boundKeyDown;\n            #button;\n            #buttonSwatch;\n            #defaultColor;\n            #dropdown;\n            #dropdownWasFromKeyboard;\n            #isMainColorPicker;\n            #eventBus;\n            #uiManager;\n            static get _keyboardManager() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_keyboardManager\", new _tools_js__WEBPACK_IMPORTED_MODULE_1__.KeyboardManager([\n                    [\n                        [\n                            \"Escape\",\n                            \"mac+Escape\"\n                        ],\n                        ColorPicker.prototype._hideDropdownFromKeyboard\n                    ],\n                    [\n                        [\n                            \" \",\n                            \"mac+ \"\n                        ],\n                        ColorPicker.prototype._colorSelectFromKeyboard\n                    ],\n                    [\n                        [\n                            \"ArrowDown\",\n                            \"ArrowRight\",\n                            \"mac+ArrowDown\",\n                            \"mac+ArrowRight\"\n                        ],\n                        ColorPicker.prototype._moveToNext\n                    ],\n                    [\n                        [\n                            \"ArrowUp\",\n                            \"ArrowLeft\",\n                            \"mac+ArrowUp\",\n                            \"mac+ArrowLeft\"\n                        ],\n                        ColorPicker.prototype._moveToPrevious\n                    ],\n                    [\n                        [\n                            \"Home\",\n                            \"mac+Home\"\n                        ],\n                        ColorPicker.prototype._moveToBeginning\n                    ],\n                    [\n                        [\n                            \"End\",\n                            \"mac+End\"\n                        ],\n                        ColorPicker.prototype._moveToEnd\n                    ]\n                ]));\n            }\n            constructor({ editor = null, uiManager = null }){\n                this.#boundKeyDown = this.#keyDown.bind(this);\n                this.#button = null;\n                this.#buttonSwatch = null;\n                this.#dropdown = null;\n                this.#dropdownWasFromKeyboard = false;\n                this.#isMainColorPicker = false;\n                this.#uiManager = null;\n                this.#isMainColorPicker = !editor;\n                this.#uiManager = editor?._uiManager || uiManager;\n                this.#eventBus = this.#uiManager._eventBus;\n                this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n            }\n            renderButton() {\n                const button = this.#button = document.createElement(\"button\");\n                button.className = \"colorPicker\";\n                button.tabIndex = \"0\";\n                button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n                button.setAttribute(\"aria-haspopup\", true);\n                button.addEventListener(\"click\", this.#openDropdown.bind(this));\n                const swatch = this.#buttonSwatch = document.createElement(\"span\");\n                swatch.className = \"swatch\";\n                swatch.style.backgroundColor = this.#defaultColor;\n                button.append(swatch);\n                return button;\n            }\n            renderMainDropdown() {\n                const dropdown = this.#dropdown = this.#getDropdownRoot(_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR);\n                dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n                dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n                return dropdown;\n            }\n            #getDropdownRoot(paramType) {\n                const div = document.createElement(\"div\");\n                div.addEventListener(\"contextmenu\", _display_utils_js__WEBPACK_IMPORTED_MODULE_2__.noContextMenu);\n                div.className = \"dropdown\";\n                div.role = \"listbox\";\n                div.setAttribute(\"aria-multiselectable\", false);\n                div.setAttribute(\"aria-orientation\", \"vertical\");\n                div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n                for (const [name, color] of this.#uiManager.highlightColors){\n                    const button = document.createElement(\"button\");\n                    button.tabIndex = \"0\";\n                    button.role = \"option\";\n                    button.setAttribute(\"data-color\", color);\n                    button.title = name;\n                    button.setAttribute(\"data-l10n-id\", `pdfjs-editor-colorpicker-${name}`);\n                    const swatch = document.createElement(\"span\");\n                    button.append(swatch);\n                    swatch.className = \"swatch\";\n                    swatch.style.backgroundColor = color;\n                    button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n                    button.addEventListener(\"click\", this.#colorSelect.bind(this, paramType, color));\n                    div.append(button);\n                }\n                div.addEventListener(\"keydown\", this.#boundKeyDown);\n                return div;\n            }\n            #colorSelect(type, color, event) {\n                event.stopPropagation();\n                this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n                    source: this,\n                    type,\n                    value: color\n                });\n            }\n            _colorSelectFromKeyboard(event) {\n                const color = event.target.getAttribute(\"data-color\");\n                if (!color) {\n                    return;\n                }\n                this.#colorSelect(color, event);\n            }\n            _moveToNext(event) {\n                if (event.target === this.#button) {\n                    this.#dropdown.firstChild?.focus();\n                    return;\n                }\n                event.target.nextSibling?.focus();\n            }\n            _moveToPrevious(event) {\n                event.target.previousSibling?.focus();\n            }\n            _moveToBeginning() {\n                this.#dropdown.firstChild?.focus();\n            }\n            _moveToEnd() {\n                this.#dropdown.lastChild?.focus();\n            }\n            #keyDown(event) {\n                ColorPicker._keyboardManager.exec(this, event);\n            }\n            #openDropdown(event) {\n                if (this.#dropdown && !this.#dropdown.classList.contains(\"hidden\")) {\n                    this.hideDropdown();\n                    return;\n                }\n                this.#button.addEventListener(\"keydown\", this.#boundKeyDown);\n                this.#dropdownWasFromKeyboard = event.detail === 0;\n                if (this.#dropdown) {\n                    this.#dropdown.classList.remove(\"hidden\");\n                    return;\n                }\n                const root = this.#dropdown = this.#getDropdownRoot(_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorParamsType.HIGHLIGHT_COLOR);\n                this.#button.append(root);\n            }\n            hideDropdown() {\n                this.#dropdown?.classList.add(\"hidden\");\n            }\n            _hideDropdownFromKeyboard() {\n                if (this.#isMainColorPicker || !this.#dropdown || this.#dropdown.classList.contains(\"hidden\")) {\n                    return;\n                }\n                this.hideDropdown();\n                this.#button.removeEventListener(\"keydown\", this.#boundKeyDown);\n                this.#button.focus({\n                    preventScroll: true,\n                    focusVisible: this.#dropdownWasFromKeyboard\n                });\n            }\n            updateColor(color) {\n                if (this.#buttonSwatch) {\n                    this.#buttonSwatch.style.backgroundColor = color;\n                }\n                if (!this.#dropdown) {\n                    return;\n                }\n                const i = this.#uiManager.highlightColors.values();\n                for (const child of this.#dropdown.children){\n                    child.setAttribute(\"aria-selected\", i.next().value === color);\n                }\n            }\n            destroy() {\n                this.#button?.remove();\n                this.#button = null;\n                this.#buttonSwatch = null;\n                this.#dropdown?.remove();\n                this.#dropdown = null;\n            }\n        }\n    /***/ },\n    /***/ 115: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_531090__)=>{\n        // EXPORTS\n        __nested_webpack_require_531090__.d(__nested_webpack_exports__, {\n            AnnotationEditor: ()=>/* binding */ AnnotationEditor\n        });\n        // EXTERNAL MODULE: ./src/display/editor/tools.js\n        var tools = __nested_webpack_require_531090__(812);\n        // EXTERNAL MODULE: ./src/shared/util.js\n        var util = __nested_webpack_require_531090__(266);\n        // EXTERNAL MODULE: ./src/display/display_utils.js\n        var display_utils = __nested_webpack_require_531090__(473);\n        ; // CONCATENATED MODULE: ./src/display/editor/alt_text.js\n        class AltText {\n            #altText;\n            #altTextDecorative;\n            #altTextButton;\n            #altTextTooltip;\n            #altTextTooltipTimeout;\n            #altTextWasFromKeyBoard;\n            #editor;\n            static{\n                this._l10nPromise = null;\n            }\n            constructor(editor){\n                this.#altText = \"\";\n                this.#altTextDecorative = false;\n                this.#altTextButton = null;\n                this.#altTextTooltip = null;\n                this.#altTextTooltipTimeout = null;\n                this.#altTextWasFromKeyBoard = false;\n                this.#editor = null;\n                this.#editor = editor;\n            }\n            static initialize(l10nPromise) {\n                AltText._l10nPromise ||= l10nPromise;\n            }\n            async render() {\n                const altText = this.#altTextButton = document.createElement(\"button\");\n                altText.className = \"altText\";\n                const msg = await AltText._l10nPromise.get(\"pdfjs-editor-alt-text-button-label\");\n                altText.textContent = msg;\n                altText.setAttribute(\"aria-label\", msg);\n                altText.tabIndex = \"0\";\n                altText.addEventListener(\"contextmenu\", display_utils.noContextMenu);\n                altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation());\n                const onClick = (event)=>{\n                    event.preventDefault();\n                    this.#editor._uiManager.editAltText(this.#editor);\n                };\n                altText.addEventListener(\"click\", onClick, {\n                    capture: true\n                });\n                altText.addEventListener(\"keydown\", (event)=>{\n                    if (event.target === altText && event.key === \"Enter\") {\n                        this.#altTextWasFromKeyBoard = true;\n                        onClick(event);\n                    }\n                });\n                await this.#setState();\n                return altText;\n            }\n            finish() {\n                if (!this.#altTextButton) {\n                    return;\n                }\n                this.#altTextButton.focus({\n                    focusVisible: this.#altTextWasFromKeyBoard\n                });\n                this.#altTextWasFromKeyBoard = false;\n            }\n            get data() {\n                return {\n                    altText: this.#altText,\n                    decorative: this.#altTextDecorative\n                };\n            }\n            set data({ altText, decorative }) {\n                if (this.#altText === altText && this.#altTextDecorative === decorative) {\n                    return;\n                }\n                this.#altText = altText;\n                this.#altTextDecorative = decorative;\n                this.#setState();\n            }\n            toggle(enabled = false) {\n                if (!this.#altTextButton) {\n                    return;\n                }\n                if (!enabled && this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextButton.disabled = !enabled;\n            }\n            destroy() {\n                this.#altTextButton?.remove();\n                this.#altTextButton = null;\n                this.#altTextTooltip = null;\n            }\n            async #setState() {\n                const button = this.#altTextButton;\n                if (!button) {\n                    return;\n                }\n                if (!this.#altText && !this.#altTextDecorative) {\n                    button.classList.remove(\"done\");\n                    this.#altTextTooltip?.remove();\n                    return;\n                }\n                button.classList.add(\"done\");\n                AltText._l10nPromise.get(\"pdfjs-editor-alt-text-edit-button-label\").then((msg)=>{\n                    button.setAttribute(\"aria-label\", msg);\n                });\n                let tooltip = this.#altTextTooltip;\n                if (!tooltip) {\n                    this.#altTextTooltip = tooltip = document.createElement(\"span\");\n                    tooltip.className = \"tooltip\";\n                    tooltip.setAttribute(\"role\", \"tooltip\");\n                    const id = tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n                    button.setAttribute(\"aria-describedby\", id);\n                    const DELAY_TO_SHOW_TOOLTIP = 100;\n                    button.addEventListener(\"mouseenter\", ()=>{\n                        this.#altTextTooltipTimeout = setTimeout(()=>{\n                            this.#altTextTooltipTimeout = null;\n                            this.#altTextTooltip.classList.add(\"show\");\n                            this.#editor._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                                source: this,\n                                details: {\n                                    type: \"editing\",\n                                    subtype: this.#editor.editorType,\n                                    data: {\n                                        action: \"alt_text_tooltip\"\n                                    }\n                                }\n                            });\n                        }, DELAY_TO_SHOW_TOOLTIP);\n                    });\n                    button.addEventListener(\"mouseleave\", ()=>{\n                        if (this.#altTextTooltipTimeout) {\n                            clearTimeout(this.#altTextTooltipTimeout);\n                            this.#altTextTooltipTimeout = null;\n                        }\n                        this.#altTextTooltip?.classList.remove(\"show\");\n                    });\n                }\n                tooltip.innerText = this.#altTextDecorative ? await AltText._l10nPromise.get(\"pdfjs-editor-alt-text-decorative-tooltip\") : this.#altText;\n                if (!tooltip.parentNode) {\n                    button.append(tooltip);\n                }\n                const element = this.#editor.getImageForAltText();\n                element?.setAttribute(\"aria-describedby\", tooltip.id);\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/display/editor/toolbar.js\n        class EditorToolbar {\n            #toolbar;\n            #colorPicker;\n            #editor;\n            #buttons;\n            constructor(editor){\n                this.#toolbar = null;\n                this.#colorPicker = null;\n                this.#buttons = null;\n                this.#editor = editor;\n            }\n            render() {\n                const editToolbar = this.#toolbar = document.createElement(\"div\");\n                editToolbar.className = \"editToolbar\";\n                editToolbar.addEventListener(\"contextmenu\", display_utils.noContextMenu);\n                editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown);\n                const buttons = this.#buttons = document.createElement(\"div\");\n                buttons.className = \"buttons\";\n                editToolbar.append(buttons);\n                const position = this.#editor.toolbarPosition;\n                if (position) {\n                    const { style } = editToolbar;\n                    const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n                    style.insetInlineEnd = `${100 * x}%`;\n                    style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n                }\n                this.#addDeleteButton();\n                return editToolbar;\n            }\n            static #pointerDown(e) {\n                e.stopPropagation();\n            }\n            #focusIn(e) {\n                this.#editor._focusEventsAllowed = false;\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            #focusOut(e) {\n                this.#editor._focusEventsAllowed = true;\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            #addListenersToElement(element) {\n                element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n                    capture: true\n                });\n                element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n                    capture: true\n                });\n                element.addEventListener(\"contextmenu\", display_utils.noContextMenu);\n            }\n            hide() {\n                this.#toolbar.classList.add(\"hidden\");\n                this.#colorPicker?.hideDropdown();\n            }\n            show() {\n                this.#toolbar.classList.remove(\"hidden\");\n            }\n            #addDeleteButton() {\n                const button = document.createElement(\"button\");\n                button.className = \"delete\";\n                button.tabIndex = 0;\n                button.setAttribute(\"data-l10n-id\", `pdfjs-editor-remove-${this.#editor.editorType}-button`);\n                this.#addListenersToElement(button);\n                button.addEventListener(\"click\", (e)=>{\n                    this.#editor._uiManager.delete();\n                });\n                this.#buttons.append(button);\n            }\n            get #divider() {\n                const divider = document.createElement(\"div\");\n                divider.className = \"divider\";\n                return divider;\n            }\n            addAltTextButton(button) {\n                this.#addListenersToElement(button);\n                this.#buttons.prepend(button, this.#divider);\n            }\n            addColorPicker(colorPicker) {\n                this.#colorPicker = colorPicker;\n                const button = colorPicker.renderButton();\n                this.#addListenersToElement(button);\n                this.#buttons.prepend(button, this.#divider);\n            }\n            remove() {\n                this.#toolbar.remove();\n                this.#colorPicker?.destroy();\n                this.#colorPicker = null;\n            }\n        }\n        ; // CONCATENATED MODULE: ./src/display/editor/editor.js\n        class AnnotationEditor {\n            #allResizerDivs;\n            #altText;\n            #keepAspectRatio;\n            #resizersDiv;\n            #savedDimensions;\n            #boundFocusin;\n            #boundFocusout;\n            #editToolbar;\n            #focusedResizerName;\n            #hasBeenClicked;\n            #isEditing;\n            #isInEditMode;\n            #isResizerEnabledForKeyboard;\n            #moveInDOMTimeout;\n            #isDraggable;\n            #zIndex;\n            static{\n                this._borderLineWidth = -1;\n            }\n            static{\n                this._colorManager = new tools.ColorManager();\n            }\n            static{\n                this._zIndex = 1;\n            }\n            static get _resizerKeyboardManager() {\n                const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n                const small = tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n                const big = tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n                return (0, util.shadow)(this, \"_resizerKeyboardManager\", new tools.KeyboardManager([\n                    [\n                        [\n                            \"ArrowLeft\",\n                            \"mac+ArrowLeft\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                -small,\n                                0\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowLeft\",\n                            \"mac+shift+ArrowLeft\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                -big,\n                                0\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowRight\",\n                            \"mac+ArrowRight\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                small,\n                                0\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowRight\",\n                            \"mac+shift+ArrowRight\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                big,\n                                0\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowUp\",\n                            \"mac+ArrowUp\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                0,\n                                -small\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowUp\",\n                            \"mac+shift+ArrowUp\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                0,\n                                -big\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowDown\",\n                            \"mac+ArrowDown\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                0,\n                                small\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowDown\",\n                            \"mac+shift+ArrowDown\"\n                        ],\n                        resize,\n                        {\n                            args: [\n                                0,\n                                big\n                            ]\n                        }\n                    ],\n                    [\n                        [\n                            \"Escape\",\n                            \"mac+Escape\"\n                        ],\n                        AnnotationEditor.prototype._stopResizingWithKeyboard\n                    ]\n                ]));\n            }\n            constructor(parameters){\n                this.#allResizerDivs = null;\n                this.#altText = null;\n                this.#keepAspectRatio = false;\n                this.#resizersDiv = null;\n                this.#savedDimensions = null;\n                this.#boundFocusin = this.focusin.bind(this);\n                this.#boundFocusout = this.focusout.bind(this);\n                this.#editToolbar = null;\n                this.#focusedResizerName = \"\";\n                this.#hasBeenClicked = false;\n                this.#isEditing = false;\n                this.#isInEditMode = false;\n                this.#isResizerEnabledForKeyboard = false;\n                this.#moveInDOMTimeout = null;\n                this._initialOptions = Object.create(null);\n                this._uiManager = null;\n                this._focusEventsAllowed = true;\n                this._l10nPromise = null;\n                this.#isDraggable = false;\n                this.#zIndex = AnnotationEditor._zIndex++;\n                if (this.constructor === AnnotationEditor) {\n                    (0, util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n                }\n                this.parent = parameters.parent;\n                this.id = parameters.id;\n                this.width = this.height = null;\n                this.pageIndex = parameters.parent.pageIndex;\n                this.name = parameters.name;\n                this.div = null;\n                this._uiManager = parameters.uiManager;\n                this.annotationElementId = null;\n                this._willKeepAspectRatio = false;\n                this._initialOptions.isCentered = parameters.isCentered;\n                this._structTreeParentId = null;\n                const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n                this.rotation = rotation;\n                this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n                this.pageDimensions = [\n                    pageWidth,\n                    pageHeight\n                ];\n                this.pageTranslation = [\n                    pageX,\n                    pageY\n                ];\n                const [width, height] = this.parentDimensions;\n                this.x = parameters.x / width;\n                this.y = parameters.y / height;\n                this.isAttachedToDOM = false;\n                this.deleted = false;\n            }\n            get editorType() {\n                return Object.getPrototypeOf(this).constructor._type;\n            }\n            static get _defaultLineColor() {\n                return (0, util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n            }\n            static deleteAnnotationElement(editor) {\n                const fakeEditor = new FakeEditor({\n                    id: editor.parent.getNextId(),\n                    parent: editor.parent,\n                    uiManager: editor._uiManager\n                });\n                fakeEditor.annotationElementId = editor.annotationElementId;\n                fakeEditor.deleted = true;\n                fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n            }\n            static initialize(l10n, options = null) {\n                AnnotationEditor._l10nPromise ||= new Map([\n                    \"pdfjs-editor-alt-text-button-label\",\n                    \"pdfjs-editor-alt-text-edit-button-label\",\n                    \"pdfjs-editor-alt-text-decorative-tooltip\",\n                    \"pdfjs-editor-resizer-label-topLeft\",\n                    \"pdfjs-editor-resizer-label-topMiddle\",\n                    \"pdfjs-editor-resizer-label-topRight\",\n                    \"pdfjs-editor-resizer-label-middleRight\",\n                    \"pdfjs-editor-resizer-label-bottomRight\",\n                    \"pdfjs-editor-resizer-label-bottomMiddle\",\n                    \"pdfjs-editor-resizer-label-bottomLeft\",\n                    \"pdfjs-editor-resizer-label-middleLeft\"\n                ].map((str)=>[\n                        str,\n                        l10n.get(str.replaceAll(/([A-Z])/g, (c)=>`-${c.toLowerCase()}`))\n                    ]));\n                if (options?.strings) {\n                    for (const str of options.strings){\n                        AnnotationEditor._l10nPromise.set(str, l10n.get(str));\n                    }\n                }\n                if (AnnotationEditor._borderLineWidth !== -1) {\n                    return;\n                }\n                const style = getComputedStyle(document.documentElement);\n                AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n            }\n            static updateDefaultParams(_type, _value) {}\n            static get defaultPropertiesToUpdate() {\n                return [];\n            }\n            static isHandlingMimeForPasting(mime) {\n                return false;\n            }\n            static paste(item, parent) {\n                (0, util.unreachable)(\"Not implemented\");\n            }\n            get propertiesToUpdate() {\n                return [];\n            }\n            get _isDraggable() {\n                return this.#isDraggable;\n            }\n            set _isDraggable(value) {\n                this.#isDraggable = value;\n                this.div?.classList.toggle(\"draggable\", value);\n            }\n            get isEnterHandled() {\n                return true;\n            }\n            center() {\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                switch(this.parentRotation){\n                    case 90:\n                        this.x -= this.height * pageHeight / (pageWidth * 2);\n                        this.y += this.width * pageWidth / (pageHeight * 2);\n                        break;\n                    case 180:\n                        this.x += this.width / 2;\n                        this.y += this.height / 2;\n                        break;\n                    case 270:\n                        this.x += this.height * pageHeight / (pageWidth * 2);\n                        this.y -= this.width * pageWidth / (pageHeight * 2);\n                        break;\n                    default:\n                        this.x -= this.width / 2;\n                        this.y -= this.height / 2;\n                        break;\n                }\n                this.fixAndSetPosition();\n            }\n            addCommands(params) {\n                this._uiManager.addCommands(params);\n            }\n            get currentLayer() {\n                return this._uiManager.currentLayer;\n            }\n            setInBackground() {\n                this.div.style.zIndex = 0;\n            }\n            setInForeground() {\n                this.div.style.zIndex = this.#zIndex;\n            }\n            setParent(parent) {\n                if (parent !== null) {\n                    this.pageIndex = parent.pageIndex;\n                    this.pageDimensions = parent.pageDimensions;\n                } else {\n                    this.#stopResizing();\n                }\n                this.parent = parent;\n            }\n            focusin(event) {\n                if (!this._focusEventsAllowed) {\n                    return;\n                }\n                if (!this.#hasBeenClicked) {\n                    this.parent.setSelected(this);\n                } else {\n                    this.#hasBeenClicked = false;\n                }\n            }\n            focusout(event) {\n                if (!this._focusEventsAllowed) {\n                    return;\n                }\n                if (!this.isAttachedToDOM) {\n                    return;\n                }\n                const target = event.relatedTarget;\n                if (target?.closest(`#${this.id}`)) {\n                    return;\n                }\n                event.preventDefault();\n                if (!this.parent?.isMultipleSelection) {\n                    this.commitOrRemove();\n                }\n            }\n            commitOrRemove() {\n                if (this.isEmpty()) {\n                    this.remove();\n                } else {\n                    this.commit();\n                }\n            }\n            commit() {\n                this.addToAnnotationStorage();\n            }\n            addToAnnotationStorage() {\n                this._uiManager.addToAnnotationStorage(this);\n            }\n            setAt(x, y, tx, ty) {\n                const [width, height] = this.parentDimensions;\n                [tx, ty] = this.screenToPageTranslation(tx, ty);\n                this.x = (x + tx) / width;\n                this.y = (y + ty) / height;\n                this.fixAndSetPosition();\n            }\n            #translate([width, height], x, y) {\n                [x, y] = this.screenToPageTranslation(x, y);\n                this.x += x / width;\n                this.y += y / height;\n                this.fixAndSetPosition();\n            }\n            translate(x, y) {\n                this.#translate(this.parentDimensions, x, y);\n            }\n            translateInPage(x, y) {\n                this.#translate(this.pageDimensions, x, y);\n                this.div.scrollIntoView({\n                    block: \"nearest\"\n                });\n            }\n            drag(tx, ty) {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.x += tx / parentWidth;\n                this.y += ty / parentHeight;\n                if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n                    const { x, y } = this.div.getBoundingClientRect();\n                    if (this.parent.findNewParent(this, x, y)) {\n                        this.x -= Math.floor(this.x);\n                        this.y -= Math.floor(this.y);\n                    }\n                }\n                let { x, y } = this;\n                const [bx, by] = this.#getBaseTranslation();\n                x += bx;\n                y += by;\n                this.div.style.left = `${(100 * x).toFixed(2)}%`;\n                this.div.style.top = `${(100 * y).toFixed(2)}%`;\n                this.div.scrollIntoView({\n                    block: \"nearest\"\n                });\n            }\n            #getBaseTranslation() {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                const { _borderLineWidth } = AnnotationEditor;\n                const x = _borderLineWidth / parentWidth;\n                const y = _borderLineWidth / parentHeight;\n                switch(this.rotation){\n                    case 90:\n                        return [\n                            -x,\n                            y\n                        ];\n                    case 180:\n                        return [\n                            x,\n                            y\n                        ];\n                    case 270:\n                        return [\n                            x,\n                            -y\n                        ];\n                    default:\n                        return [\n                            -x,\n                            -y\n                        ];\n                }\n            }\n            fixAndSetPosition(rotation = this.rotation) {\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                let { x, y, width, height } = this;\n                width *= pageWidth;\n                height *= pageHeight;\n                x *= pageWidth;\n                y *= pageHeight;\n                switch(rotation){\n                    case 0:\n                        x = Math.max(0, Math.min(pageWidth - width, x));\n                        y = Math.max(0, Math.min(pageHeight - height, y));\n                        break;\n                    case 90:\n                        x = Math.max(0, Math.min(pageWidth - height, x));\n                        y = Math.min(pageHeight, Math.max(width, y));\n                        break;\n                    case 180:\n                        x = Math.min(pageWidth, Math.max(width, x));\n                        y = Math.min(pageHeight, Math.max(height, y));\n                        break;\n                    case 270:\n                        x = Math.min(pageWidth, Math.max(height, x));\n                        y = Math.max(0, Math.min(pageHeight - width, y));\n                        break;\n                }\n                this.x = x /= pageWidth;\n                this.y = y /= pageHeight;\n                const [bx, by] = this.#getBaseTranslation();\n                x += bx;\n                y += by;\n                const { style } = this.div;\n                style.left = `${(100 * x).toFixed(2)}%`;\n                style.top = `${(100 * y).toFixed(2)}%`;\n                this.moveInDOM();\n            }\n            static #rotatePoint(x, y, angle) {\n                switch(angle){\n                    case 90:\n                        return [\n                            y,\n                            -x\n                        ];\n                    case 180:\n                        return [\n                            -x,\n                            -y\n                        ];\n                    case 270:\n                        return [\n                            -y,\n                            x\n                        ];\n                    default:\n                        return [\n                            x,\n                            y\n                        ];\n                }\n            }\n            screenToPageTranslation(x, y) {\n                return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n            }\n            pageTranslationToScreen(x, y) {\n                return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n            }\n            #getRotationMatrix(rotation) {\n                switch(rotation){\n                    case 90:\n                        {\n                            const [pageWidth, pageHeight] = this.pageDimensions;\n                            return [\n                                0,\n                                -pageWidth / pageHeight,\n                                pageHeight / pageWidth,\n                                0\n                            ];\n                        }\n                    case 180:\n                        return [\n                            -1,\n                            0,\n                            0,\n                            -1\n                        ];\n                    case 270:\n                        {\n                            const [pageWidth, pageHeight] = this.pageDimensions;\n                            return [\n                                0,\n                                pageWidth / pageHeight,\n                                -pageHeight / pageWidth,\n                                0\n                            ];\n                        }\n                    default:\n                        return [\n                            1,\n                            0,\n                            0,\n                            1\n                        ];\n                }\n            }\n            get parentScale() {\n                return this._uiManager.viewParameters.realScale;\n            }\n            get parentRotation() {\n                return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n            }\n            get parentDimensions() {\n                const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n                const scaledWidth = pageWidth * parentScale;\n                const scaledHeight = pageHeight * parentScale;\n                return util.FeatureTest.isCSSRoundSupported ? [\n                    Math.round(scaledWidth),\n                    Math.round(scaledHeight)\n                ] : [\n                    scaledWidth,\n                    scaledHeight\n                ];\n            }\n            setDims(width, height) {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n                if (!this.#keepAspectRatio) {\n                    this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n                }\n            }\n            fixDims() {\n                const { style } = this.div;\n                const { height, width } = style;\n                const widthPercent = width.endsWith(\"%\");\n                const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n                if (widthPercent && heightPercent) {\n                    return;\n                }\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                if (!widthPercent) {\n                    style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n                }\n                if (!this.#keepAspectRatio && !heightPercent) {\n                    style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n                }\n            }\n            getInitialTranslation() {\n                return [\n                    0,\n                    0\n                ];\n            }\n            #createResizers() {\n                if (this.#resizersDiv) {\n                    return;\n                }\n                this.#resizersDiv = document.createElement(\"div\");\n                this.#resizersDiv.classList.add(\"resizers\");\n                const classes = this._willKeepAspectRatio ? [\n                    \"topLeft\",\n                    \"topRight\",\n                    \"bottomRight\",\n                    \"bottomLeft\"\n                ] : [\n                    \"topLeft\",\n                    \"topMiddle\",\n                    \"topRight\",\n                    \"middleRight\",\n                    \"bottomRight\",\n                    \"bottomMiddle\",\n                    \"bottomLeft\",\n                    \"middleLeft\"\n                ];\n                for (const name of classes){\n                    const div = document.createElement(\"div\");\n                    this.#resizersDiv.append(div);\n                    div.classList.add(\"resizer\", name);\n                    div.setAttribute(\"data-resizer-name\", name);\n                    div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name));\n                    div.addEventListener(\"contextmenu\", display_utils.noContextMenu);\n                    div.tabIndex = -1;\n                }\n                this.div.prepend(this.#resizersDiv);\n            }\n            #resizerPointerdown(name, event) {\n                event.preventDefault();\n                const { isMac } = util.FeatureTest.platform;\n                if (event.button !== 0 || event.ctrlKey && isMac) {\n                    return;\n                }\n                this.#altText?.toggle(false);\n                const boundResizerPointermove = this.#resizerPointermove.bind(this, name);\n                const savedDraggable = this._isDraggable;\n                this._isDraggable = false;\n                const pointerMoveOptions = {\n                    passive: true,\n                    capture: true\n                };\n                this.parent.togglePointerEvents(false);\n                window.addEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                const savedX = this.x;\n                const savedY = this.y;\n                const savedWidth = this.width;\n                const savedHeight = this.height;\n                const savedParentCursor = this.parent.div.style.cursor;\n                const savedCursor = this.div.style.cursor;\n                this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n                const pointerUpCallback = ()=>{\n                    this.parent.togglePointerEvents(true);\n                    this.#altText?.toggle(true);\n                    this._isDraggable = savedDraggable;\n                    window.removeEventListener(\"pointerup\", pointerUpCallback);\n                    window.removeEventListener(\"blur\", pointerUpCallback);\n                    window.removeEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                    this.parent.div.style.cursor = savedParentCursor;\n                    this.div.style.cursor = savedCursor;\n                    this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n                };\n                window.addEventListener(\"pointerup\", pointerUpCallback);\n                window.addEventListener(\"blur\", pointerUpCallback);\n            }\n            #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {\n                const newX = this.x;\n                const newY = this.y;\n                const newWidth = this.width;\n                const newHeight = this.height;\n                if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n                    return;\n                }\n                this.addCommands({\n                    cmd: ()=>{\n                        this.width = newWidth;\n                        this.height = newHeight;\n                        this.x = newX;\n                        this.y = newY;\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                        this.fixAndSetPosition();\n                    },\n                    undo: ()=>{\n                        this.width = savedWidth;\n                        this.height = savedHeight;\n                        this.x = savedX;\n                        this.y = savedY;\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n                        this.fixAndSetPosition();\n                    },\n                    mustExec: true\n                });\n            }\n            #resizerPointermove(name, event) {\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                const savedX = this.x;\n                const savedY = this.y;\n                const savedWidth = this.width;\n                const savedHeight = this.height;\n                const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n                const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n                const round = (x)=>Math.round(x * 10000) / 10000;\n                const rotationMatrix = this.#getRotationMatrix(this.rotation);\n                const transf = (x, y)=>[\n                        rotationMatrix[0] * x + rotationMatrix[2] * y,\n                        rotationMatrix[1] * x + rotationMatrix[3] * y\n                    ];\n                const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n                const invTransf = (x, y)=>[\n                        invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                        invRotationMatrix[1] * x + invRotationMatrix[3] * y\n                    ];\n                let getPoint;\n                let getOpposite;\n                let isDiagonal = false;\n                let isHorizontal = false;\n                switch(name){\n                    case \"topLeft\":\n                        isDiagonal = true;\n                        getPoint = (w, h)=>[\n                                0,\n                                0\n                            ];\n                        getOpposite = (w, h)=>[\n                                w,\n                                h\n                            ];\n                        break;\n                    case \"topMiddle\":\n                        getPoint = (w, h)=>[\n                                w / 2,\n                                0\n                            ];\n                        getOpposite = (w, h)=>[\n                                w / 2,\n                                h\n                            ];\n                        break;\n                    case \"topRight\":\n                        isDiagonal = true;\n                        getPoint = (w, h)=>[\n                                w,\n                                0\n                            ];\n                        getOpposite = (w, h)=>[\n                                0,\n                                h\n                            ];\n                        break;\n                    case \"middleRight\":\n                        isHorizontal = true;\n                        getPoint = (w, h)=>[\n                                w,\n                                h / 2\n                            ];\n                        getOpposite = (w, h)=>[\n                                0,\n                                h / 2\n                            ];\n                        break;\n                    case \"bottomRight\":\n                        isDiagonal = true;\n                        getPoint = (w, h)=>[\n                                w,\n                                h\n                            ];\n                        getOpposite = (w, h)=>[\n                                0,\n                                0\n                            ];\n                        break;\n                    case \"bottomMiddle\":\n                        getPoint = (w, h)=>[\n                                w / 2,\n                                h\n                            ];\n                        getOpposite = (w, h)=>[\n                                w / 2,\n                                0\n                            ];\n                        break;\n                    case \"bottomLeft\":\n                        isDiagonal = true;\n                        getPoint = (w, h)=>[\n                                0,\n                                h\n                            ];\n                        getOpposite = (w, h)=>[\n                                w,\n                                0\n                            ];\n                        break;\n                    case \"middleLeft\":\n                        isHorizontal = true;\n                        getPoint = (w, h)=>[\n                                0,\n                                h / 2\n                            ];\n                        getOpposite = (w, h)=>[\n                                w,\n                                h / 2\n                            ];\n                        break;\n                }\n                const point = getPoint(savedWidth, savedHeight);\n                const oppositePoint = getOpposite(savedWidth, savedHeight);\n                let transfOppositePoint = transf(...oppositePoint);\n                const oppositeX = round(savedX + transfOppositePoint[0]);\n                const oppositeY = round(savedY + transfOppositePoint[1]);\n                let ratioX = 1;\n                let ratioY = 1;\n                let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n                [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n                if (isDiagonal) {\n                    const oldDiag = Math.hypot(savedWidth, savedHeight);\n                    ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n                } else if (isHorizontal) {\n                    ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n                } else {\n                    ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n                }\n                const newWidth = round(savedWidth * ratioX);\n                const newHeight = round(savedHeight * ratioY);\n                transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n                const newX = oppositeX - transfOppositePoint[0];\n                const newY = oppositeY - transfOppositePoint[1];\n                this.width = newWidth;\n                this.height = newHeight;\n                this.x = newX;\n                this.y = newY;\n                this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                this.fixAndSetPosition();\n            }\n            altTextFinish() {\n                this.#altText?.finish();\n            }\n            async addEditToolbar() {\n                if (this.#editToolbar || this.#isInEditMode) {\n                    return this.#editToolbar;\n                }\n                this.#editToolbar = new EditorToolbar(this);\n                this.div.append(this.#editToolbar.render());\n                if (this.#altText) {\n                    this.#editToolbar.addAltTextButton(await this.#altText.render());\n                }\n                return this.#editToolbar;\n            }\n            removeEditToolbar() {\n                if (!this.#editToolbar) {\n                    return;\n                }\n                this.#editToolbar.remove();\n                this.#editToolbar = null;\n                this.#altText?.destroy();\n            }\n            getClientDimensions() {\n                return this.div.getBoundingClientRect();\n            }\n            async addAltTextButton() {\n                if (this.#altText) {\n                    return;\n                }\n                AltText.initialize(AnnotationEditor._l10nPromise);\n                this.#altText = new AltText(this);\n                await this.addEditToolbar();\n            }\n            get altTextData() {\n                return this.#altText?.data;\n            }\n            set altTextData(data) {\n                if (!this.#altText) {\n                    return;\n                }\n                this.#altText.data = data;\n            }\n            render() {\n                this.div = document.createElement(\"div\");\n                this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n                this.div.className = this.name;\n                this.div.setAttribute(\"id\", this.id);\n                this.div.setAttribute(\"tabIndex\", 0);\n                this.setInForeground();\n                this.div.addEventListener(\"focusin\", this.#boundFocusin);\n                this.div.addEventListener(\"focusout\", this.#boundFocusout);\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                if (this.parentRotation % 180 !== 0) {\n                    this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n                    this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n                }\n                const [tx, ty] = this.getInitialTranslation();\n                this.translate(tx, ty);\n                (0, tools.bindEvents)(this, this.div, [\n                    \"pointerdown\"\n                ]);\n                return this.div;\n            }\n            pointerdown(event) {\n                const { isMac } = util.FeatureTest.platform;\n                if (event.button !== 0 || event.ctrlKey && isMac) {\n                    event.preventDefault();\n                    return;\n                }\n                this.#hasBeenClicked = true;\n                if (this._isDraggable) {\n                    this.#setUpDragSession(event);\n                    return;\n                }\n                this.#selectOnPointerEvent(event);\n            }\n            #selectOnPointerEvent(event) {\n                const { isMac } = util.FeatureTest.platform;\n                if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n                    this.parent.toggleSelected(this);\n                } else {\n                    this.parent.setSelected(this);\n                }\n            }\n            #setUpDragSession(event) {\n                const isSelected = this._uiManager.isSelected(this);\n                this._uiManager.setUpDragSession();\n                let pointerMoveOptions, pointerMoveCallback;\n                if (isSelected) {\n                    pointerMoveOptions = {\n                        passive: true,\n                        capture: true\n                    };\n                    pointerMoveCallback = (e)=>{\n                        const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);\n                        this._uiManager.dragSelectedEditors(tx, ty);\n                    };\n                    window.addEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                }\n                const pointerUpCallback = ()=>{\n                    window.removeEventListener(\"pointerup\", pointerUpCallback);\n                    window.removeEventListener(\"blur\", pointerUpCallback);\n                    if (isSelected) {\n                        window.removeEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                    }\n                    this.#hasBeenClicked = false;\n                    if (!this._uiManager.endDragSession()) {\n                        this.#selectOnPointerEvent(event);\n                    }\n                };\n                window.addEventListener(\"pointerup\", pointerUpCallback);\n                window.addEventListener(\"blur\", pointerUpCallback);\n            }\n            moveInDOM() {\n                if (this.#moveInDOMTimeout) {\n                    clearTimeout(this.#moveInDOMTimeout);\n                }\n                this.#moveInDOMTimeout = setTimeout(()=>{\n                    this.#moveInDOMTimeout = null;\n                    this.parent?.moveEditorInDOM(this);\n                }, 0);\n            }\n            _setParentAndPosition(parent, x, y) {\n                parent.changeParent(this);\n                this.x = x;\n                this.y = y;\n                this.fixAndSetPosition();\n            }\n            getRect(tx, ty, rotation = this.rotation) {\n                const scale = this.parentScale;\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                const shiftX = tx / scale;\n                const shiftY = ty / scale;\n                const x = this.x * pageWidth;\n                const y = this.y * pageHeight;\n                const width = this.width * pageWidth;\n                const height = this.height * pageHeight;\n                switch(rotation){\n                    case 0:\n                        return [\n                            x + shiftX + pageX,\n                            pageHeight - y - shiftY - height + pageY,\n                            x + shiftX + width + pageX,\n                            pageHeight - y - shiftY + pageY\n                        ];\n                    case 90:\n                        return [\n                            x + shiftY + pageX,\n                            pageHeight - y + shiftX + pageY,\n                            x + shiftY + height + pageX,\n                            pageHeight - y + shiftX + width + pageY\n                        ];\n                    case 180:\n                        return [\n                            x - shiftX - width + pageX,\n                            pageHeight - y + shiftY + pageY,\n                            x - shiftX + pageX,\n                            pageHeight - y + shiftY + height + pageY\n                        ];\n                    case 270:\n                        return [\n                            x - shiftY - height + pageX,\n                            pageHeight - y - shiftX - width + pageY,\n                            x - shiftY + pageX,\n                            pageHeight - y - shiftX + pageY\n                        ];\n                    default:\n                        throw new Error(\"Invalid rotation\");\n                }\n            }\n            getRectInCurrentCoords(rect, pageHeight) {\n                const [x1, y1, x2, y2] = rect;\n                const width = x2 - x1;\n                const height = y2 - y1;\n                switch(this.rotation){\n                    case 0:\n                        return [\n                            x1,\n                            pageHeight - y2,\n                            width,\n                            height\n                        ];\n                    case 90:\n                        return [\n                            x1,\n                            pageHeight - y1,\n                            height,\n                            width\n                        ];\n                    case 180:\n                        return [\n                            x2,\n                            pageHeight - y1,\n                            width,\n                            height\n                        ];\n                    case 270:\n                        return [\n                            x2,\n                            pageHeight - y2,\n                            height,\n                            width\n                        ];\n                    default:\n                        throw new Error(\"Invalid rotation\");\n                }\n            }\n            onceAdded() {}\n            isEmpty() {\n                return false;\n            }\n            enableEditMode() {\n                this.#isInEditMode = true;\n            }\n            disableEditMode() {\n                this.#isInEditMode = false;\n            }\n            isInEditMode() {\n                return this.#isInEditMode;\n            }\n            shouldGetKeyboardEvents() {\n                return this.#isResizerEnabledForKeyboard;\n            }\n            needsToBeRebuilt() {\n                return this.div && !this.isAttachedToDOM;\n            }\n            rebuild() {\n                this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n                this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n            }\n            rotate(_angle) {}\n            serialize(isForCopying = false, context = null) {\n                (0, util.unreachable)(\"An editor must be serializable\");\n            }\n            static deserialize(data, parent, uiManager) {\n                const editor = new this.prototype.constructor({\n                    parent,\n                    id: parent.getNextId(),\n                    uiManager\n                });\n                editor.rotation = data.rotation;\n                const [pageWidth, pageHeight] = editor.pageDimensions;\n                const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n                editor.x = x / pageWidth;\n                editor.y = y / pageHeight;\n                editor.width = width / pageWidth;\n                editor.height = height / pageHeight;\n                return editor;\n            }\n            remove() {\n                this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n                this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n                if (!this.isEmpty()) {\n                    this.commit();\n                }\n                if (this.parent) {\n                    this.parent.remove(this);\n                } else {\n                    this._uiManager.removeEditor(this);\n                }\n                if (this.#moveInDOMTimeout) {\n                    clearTimeout(this.#moveInDOMTimeout);\n                    this.#moveInDOMTimeout = null;\n                }\n                this.#stopResizing();\n                this.removeEditToolbar();\n            }\n            get isResizable() {\n                return false;\n            }\n            makeResizable() {\n                if (this.isResizable) {\n                    this.#createResizers();\n                    this.#resizersDiv.classList.remove(\"hidden\");\n                    (0, tools.bindEvents)(this, this.div, [\n                        \"keydown\"\n                    ]);\n                }\n            }\n            get toolbarPosition() {\n                return null;\n            }\n            keydown(event) {\n                if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n                    return;\n                }\n                this._uiManager.setSelected(this);\n                this.#savedDimensions = {\n                    savedX: this.x,\n                    savedY: this.y,\n                    savedWidth: this.width,\n                    savedHeight: this.height\n                };\n                const children = this.#resizersDiv.children;\n                if (!this.#allResizerDivs) {\n                    this.#allResizerDivs = Array.from(children);\n                    const boundResizerKeydown = this.#resizerKeydown.bind(this);\n                    const boundResizerBlur = this.#resizerBlur.bind(this);\n                    for (const div of this.#allResizerDivs){\n                        const name = div.getAttribute(\"data-resizer-name\");\n                        div.setAttribute(\"role\", \"spinbutton\");\n                        div.addEventListener(\"keydown\", boundResizerKeydown);\n                        div.addEventListener(\"blur\", boundResizerBlur);\n                        div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name));\n                        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then((msg)=>div.setAttribute(\"aria-label\", msg));\n                    }\n                }\n                const first = this.#allResizerDivs[0];\n                let firstPosition = 0;\n                for (const div of children){\n                    if (div === first) {\n                        break;\n                    }\n                    firstPosition++;\n                }\n                const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n                if (nextFirstPosition !== firstPosition) {\n                    if (nextFirstPosition < firstPosition) {\n                        for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                            this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                        }\n                    } else if (nextFirstPosition > firstPosition) {\n                        for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                            this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                        }\n                    }\n                    let i = 0;\n                    for (const child of children){\n                        const div = this.#allResizerDivs[i++];\n                        const name = div.getAttribute(\"data-resizer-name\");\n                        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then((msg)=>child.setAttribute(\"aria-label\", msg));\n                    }\n                }\n                this.#setResizerTabIndex(0);\n                this.#isResizerEnabledForKeyboard = true;\n                this.#resizersDiv.firstChild.focus({\n                    focusVisible: true\n                });\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            }\n            #resizerKeydown(event) {\n                AnnotationEditor._resizerKeyboardManager.exec(this, event);\n            }\n            #resizerBlur(event) {\n                if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n                    this.#stopResizing();\n                }\n            }\n            #resizerFocus(name) {\n                this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n            }\n            #setResizerTabIndex(value) {\n                if (!this.#allResizerDivs) {\n                    return;\n                }\n                for (const div of this.#allResizerDivs){\n                    div.tabIndex = value;\n                }\n            }\n            _resizeWithKeyboard(x, y) {\n                if (!this.#isResizerEnabledForKeyboard) {\n                    return;\n                }\n                this.#resizerPointermove(this.#focusedResizerName, {\n                    movementX: x,\n                    movementY: y\n                });\n            }\n            #stopResizing() {\n                this.#isResizerEnabledForKeyboard = false;\n                this.#setResizerTabIndex(-1);\n                if (this.#savedDimensions) {\n                    const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n                    this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n                    this.#savedDimensions = null;\n                }\n            }\n            _stopResizingWithKeyboard() {\n                this.#stopResizing();\n                this.div.focus();\n            }\n            select() {\n                this.makeResizable();\n                this.div?.classList.add(\"selectedEditor\");\n                if (!this.#editToolbar) {\n                    this.addEditToolbar().then(()=>{\n                        if (this.div?.classList.contains(\"selectedEditor\")) {\n                            this.#editToolbar?.show();\n                        }\n                    });\n                    return;\n                }\n                this.#editToolbar?.show();\n            }\n            unselect() {\n                this.#resizersDiv?.classList.add(\"hidden\");\n                this.div?.classList.remove(\"selectedEditor\");\n                if (this.div?.contains(document.activeElement)) {\n                    this._uiManager.currentLayer.div.focus();\n                }\n                this.#editToolbar?.hide();\n            }\n            updateParams(type, value) {}\n            disableEditing() {}\n            enableEditing() {}\n            enterInEditMode() {}\n            getImageForAltText() {\n                return null;\n            }\n            get contentDiv() {\n                return this.div;\n            }\n            get isEditing() {\n                return this.#isEditing;\n            }\n            set isEditing(value) {\n                this.#isEditing = value;\n                if (!this.parent) {\n                    return;\n                }\n                if (value) {\n                    this.parent.setSelected(this);\n                    this.parent.setActiveEditor(this);\n                } else {\n                    this.parent.setActiveEditor(null);\n                }\n            }\n            setAspectRatio(width, height) {\n                this.#keepAspectRatio = true;\n                const aspectRatio = width / height;\n                const { style } = this.div;\n                style.aspectRatio = aspectRatio;\n                style.height = \"auto\";\n            }\n            static get MIN_SIZE() {\n                return 16;\n            }\n            static canCreateNewEmptyEditor() {\n                return true;\n            }\n        }\n        class FakeEditor extends AnnotationEditor {\n            constructor(params){\n                super(params);\n                this.annotationElementId = params.annotationElementId;\n                this.deleted = true;\n            }\n            serialize() {\n                return {\n                    id: this.annotationElementId,\n                    deleted: true,\n                    pageIndex: this.pageIndex\n                };\n            }\n        }\n    /***/ },\n    /***/ 405: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_593988__)=>{\n        /* harmony export */ __nested_webpack_require_593988__.d(__nested_webpack_exports__, {\n            /* harmony export */ Outliner: ()=>/* binding */ Outliner\n        });\n        class Outliner {\n            #box;\n            #verticalEdges;\n            #intervals;\n            constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n                this.#verticalEdges = [];\n                this.#intervals = [];\n                let minX = Infinity;\n                let maxX = -Infinity;\n                let minY = Infinity;\n                let maxY = -Infinity;\n                const NUMBER_OF_DIGITS = 4;\n                const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n                for (const { x, y, width, height } of boxes){\n                    const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n                    const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n                    const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n                    const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n                    const left = [\n                        x1,\n                        y1,\n                        y2,\n                        true\n                    ];\n                    const right = [\n                        x2,\n                        y1,\n                        y2,\n                        false\n                    ];\n                    this.#verticalEdges.push(left, right);\n                    minX = Math.min(minX, x1);\n                    maxX = Math.max(maxX, x2);\n                    minY = Math.min(minY, y1);\n                    maxY = Math.max(maxY, y2);\n                }\n                const bboxWidth = maxX - minX + 2 * innerMargin;\n                const bboxHeight = maxY - minY + 2 * innerMargin;\n                const shiftedMinX = minX - innerMargin;\n                const shiftedMinY = minY - innerMargin;\n                const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n                const lastPoint = [\n                    lastEdge[0],\n                    lastEdge[2]\n                ];\n                for (const edge of this.#verticalEdges){\n                    const [x, y1, y2] = edge;\n                    edge[0] = (x - shiftedMinX) / bboxWidth;\n                    edge[1] = (y1 - shiftedMinY) / bboxHeight;\n                    edge[2] = (y2 - shiftedMinY) / bboxHeight;\n                }\n                this.#box = {\n                    x: shiftedMinX,\n                    y: shiftedMinY,\n                    width: bboxWidth,\n                    height: bboxHeight,\n                    lastPoint\n                };\n            }\n            getOutlines() {\n                this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n                const outlineVerticalEdges = [];\n                for (const edge of this.#verticalEdges){\n                    if (edge[3]) {\n                        outlineVerticalEdges.push(...this.#breakEdge(edge));\n                        this.#insert(edge);\n                    } else {\n                        this.#remove(edge);\n                        outlineVerticalEdges.push(...this.#breakEdge(edge));\n                    }\n                }\n                return this.#getOutlines(outlineVerticalEdges);\n            }\n            #getOutlines(outlineVerticalEdges) {\n                const edges = [];\n                const allEdges = new Set();\n                for (const edge of outlineVerticalEdges){\n                    const [x, y1, y2] = edge;\n                    edges.push([\n                        x,\n                        y1,\n                        edge\n                    ], [\n                        x,\n                        y2,\n                        edge\n                    ]);\n                }\n                edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n                for(let i = 0, ii = edges.length; i < ii; i += 2){\n                    const edge1 = edges[i][2];\n                    const edge2 = edges[i + 1][2];\n                    edge1.push(edge2);\n                    edge2.push(edge1);\n                    allEdges.add(edge1);\n                    allEdges.add(edge2);\n                }\n                const outlines = [];\n                let outline;\n                while(allEdges.size > 0){\n                    const edge = allEdges.values().next().value;\n                    let [x, y1, y2, edge1, edge2] = edge;\n                    allEdges.delete(edge);\n                    let lastPointX = x;\n                    let lastPointY = y1;\n                    outline = [\n                        x,\n                        y2\n                    ];\n                    outlines.push(outline);\n                    while(true){\n                        let e;\n                        if (allEdges.has(edge1)) {\n                            e = edge1;\n                        } else if (allEdges.has(edge2)) {\n                            e = edge2;\n                        } else {\n                            break;\n                        }\n                        allEdges.delete(e);\n                        [x, y1, y2, edge1, edge2] = e;\n                        if (lastPointX !== x) {\n                            outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                            lastPointX = x;\n                        }\n                        lastPointY = lastPointY === y1 ? y2 : y1;\n                    }\n                    outline.push(lastPointX, lastPointY);\n                }\n                return {\n                    outlines,\n                    box: this.#box\n                };\n            }\n            #binarySearch(y) {\n                const array = this.#intervals;\n                let start = 0;\n                let end = array.length - 1;\n                while(start <= end){\n                    const middle = start + end >> 1;\n                    const y1 = array[middle][0];\n                    if (y1 === y) {\n                        return middle;\n                    }\n                    if (y1 < y) {\n                        start = middle + 1;\n                    } else {\n                        end = middle - 1;\n                    }\n                }\n                return end + 1;\n            }\n            #insert([, y1, y2]) {\n                const index = this.#binarySearch(y1);\n                this.#intervals.splice(index, 0, [\n                    y1,\n                    y2\n                ]);\n            }\n            #remove([, y1, y2]) {\n                const index = this.#binarySearch(y1);\n                for(let i = index; i < this.#intervals.length; i++){\n                    const [start, end] = this.#intervals[i];\n                    if (start !== y1) {\n                        break;\n                    }\n                    if (start === y1 && end === y2) {\n                        this.#intervals.splice(i, 1);\n                        return;\n                    }\n                }\n                for(let i = index - 1; i >= 0; i--){\n                    const [start, end] = this.#intervals[i];\n                    if (start !== y1) {\n                        break;\n                    }\n                    if (start === y1 && end === y2) {\n                        this.#intervals.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n            #breakEdge(edge) {\n                const [x, y1, y2] = edge;\n                const results = [\n                    [\n                        x,\n                        y1,\n                        y2\n                    ]\n                ];\n                const index = this.#binarySearch(y2);\n                for(let i = 0; i < index; i++){\n                    const [start, end] = this.#intervals[i];\n                    for(let j = 0, jj = results.length; j < jj; j++){\n                        const [, y3, y4] = results[j];\n                        if (end <= y3 || y4 <= start) {\n                            continue;\n                        }\n                        if (y3 >= start) {\n                            if (y4 > end) {\n                                results[j][1] = end;\n                            } else {\n                                if (jj === 1) {\n                                    return [];\n                                }\n                                results.splice(j, 1);\n                                j--;\n                                jj--;\n                            }\n                            continue;\n                        }\n                        results[j][2] = start;\n                        if (y4 > end) {\n                            results.push([\n                                x,\n                                end,\n                                y4\n                            ]);\n                        }\n                    }\n                }\n                return results;\n            }\n        }\n    /***/ },\n    /***/ 812: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_603097__)=>{\n        /* harmony export */ __nested_webpack_require_603097__.d(__nested_webpack_exports__, {\n            /* harmony export */ AnnotationEditorUIManager: ()=>/* binding */ AnnotationEditorUIManager,\n            /* harmony export */ ColorManager: ()=>/* binding */ ColorManager,\n            /* harmony export */ KeyboardManager: ()=>/* binding */ KeyboardManager,\n            /* harmony export */ bindEvents: ()=>/* binding */ bindEvents,\n            /* harmony export */ opacityToHex: ()=>/* binding */ opacityToHex\n        });\n        /* unused harmony export CommandManager */ /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_603097__(266);\n        /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_603097__(473);\n        function bindEvents(obj, element, names) {\n            for (const name of names){\n                element.addEventListener(name, obj[name].bind(obj));\n            }\n        }\n        function opacityToHex(opacity) {\n            return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n        }\n        class IdManager {\n            #id;\n            getId() {\n                return `${_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorPrefix}${this.#id++}`;\n            }\n            constructor(){\n                this.#id = 0;\n            }\n        }\n        class ImageManager {\n            #baseId;\n            #id;\n            #cache;\n            static get _isSVGFittingCanvas() {\n                const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n                const canvas = new OffscreenCanvas(1, 3);\n                const ctx = canvas.getContext(\"2d\");\n                const image = new Image();\n                image.src = svg;\n                const promise = image.decode().then(()=>{\n                    ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n                    return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n                });\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_isSVGFittingCanvas\", promise);\n            }\n            async #get(key, rawData) {\n                this.#cache ||= new Map();\n                let data = this.#cache.get(key);\n                if (data === null) {\n                    return null;\n                }\n                if (data?.bitmap) {\n                    data.refCounter += 1;\n                    return data;\n                }\n                try {\n                    data ||= {\n                        bitmap: null,\n                        id: `image_${this.#baseId}_${this.#id++}`,\n                        refCounter: 0,\n                        isSvg: false\n                    };\n                    let image;\n                    if (typeof rawData === \"string\") {\n                        data.url = rawData;\n                        image = await (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.fetchData)(rawData, \"blob\");\n                    } else {\n                        image = data.file = rawData;\n                    }\n                    if (image.type === \"image/svg+xml\") {\n                        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                        const fileReader = new FileReader();\n                        const imageElement = new Image();\n                        const imagePromise = new Promise((resolve, reject)=>{\n                            imageElement.onload = ()=>{\n                                data.bitmap = imageElement;\n                                data.isSvg = true;\n                                resolve();\n                            };\n                            fileReader.onload = async ()=>{\n                                const url = data.svgUrl = fileReader.result;\n                                imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                            };\n                            imageElement.onerror = fileReader.onerror = reject;\n                        });\n                        fileReader.readAsDataURL(image);\n                        await imagePromise;\n                    } else {\n                        data.bitmap = await createImageBitmap(image);\n                    }\n                    data.refCounter = 1;\n                } catch (e) {\n                    console.error(e);\n                    data = null;\n                }\n                this.#cache.set(key, data);\n                if (data) {\n                    this.#cache.set(data.id, data);\n                }\n                return data;\n            }\n            async getFromFile(file) {\n                const { lastModified, name, size, type } = file;\n                return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n            }\n            async getFromUrl(url) {\n                return this.#get(url, url);\n            }\n            async getFromId(id) {\n                this.#cache ||= new Map();\n                const data = this.#cache.get(id);\n                if (!data) {\n                    return null;\n                }\n                if (data.bitmap) {\n                    data.refCounter += 1;\n                    return data;\n                }\n                if (data.file) {\n                    return this.getFromFile(data.file);\n                }\n                return this.getFromUrl(data.url);\n            }\n            getSvgUrl(id) {\n                const data = this.#cache.get(id);\n                if (!data?.isSvg) {\n                    return null;\n                }\n                return data.svgUrl;\n            }\n            deleteId(id) {\n                this.#cache ||= new Map();\n                const data = this.#cache.get(id);\n                if (!data) {\n                    return;\n                }\n                data.refCounter -= 1;\n                if (data.refCounter !== 0) {\n                    return;\n                }\n                data.bitmap = null;\n            }\n            isValidId(id) {\n                return id.startsWith(`image_${this.#baseId}_`);\n            }\n            constructor(){\n                this.#baseId = (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.getUuid)();\n                this.#id = 0;\n                this.#cache = null;\n            }\n        }\n        class CommandManager {\n            #commands;\n            #locked;\n            #maxSize;\n            #position;\n            constructor(maxSize = 128){\n                this.#commands = [];\n                this.#locked = false;\n                this.#position = -1;\n                this.#maxSize = maxSize;\n            }\n            add({ cmd, undo, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n                if (mustExec) {\n                    cmd();\n                }\n                if (this.#locked) {\n                    return;\n                }\n                const save = {\n                    cmd,\n                    undo,\n                    type\n                };\n                if (this.#position === -1) {\n                    if (this.#commands.length > 0) {\n                        this.#commands.length = 0;\n                    }\n                    this.#position = 0;\n                    this.#commands.push(save);\n                    return;\n                }\n                if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n                    if (keepUndo) {\n                        save.undo = this.#commands[this.#position].undo;\n                    }\n                    this.#commands[this.#position] = save;\n                    return;\n                }\n                const next = this.#position + 1;\n                if (next === this.#maxSize) {\n                    this.#commands.splice(0, 1);\n                } else {\n                    this.#position = next;\n                    if (next < this.#commands.length) {\n                        this.#commands.splice(next);\n                    }\n                }\n                this.#commands.push(save);\n            }\n            undo() {\n                if (this.#position === -1) {\n                    return;\n                }\n                this.#locked = true;\n                this.#commands[this.#position].undo();\n                this.#locked = false;\n                this.#position -= 1;\n            }\n            redo() {\n                if (this.#position < this.#commands.length - 1) {\n                    this.#position += 1;\n                    this.#locked = true;\n                    this.#commands[this.#position].cmd();\n                    this.#locked = false;\n                }\n            }\n            hasSomethingToUndo() {\n                return this.#position !== -1;\n            }\n            hasSomethingToRedo() {\n                return this.#position < this.#commands.length - 1;\n            }\n            destroy() {\n                this.#commands = null;\n            }\n        }\n        class KeyboardManager {\n            constructor(callbacks){\n                this.buffer = [];\n                this.callbacks = new Map();\n                this.allKeys = new Set();\n                const { isMac } = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.FeatureTest.platform;\n                for (const [keys, callback, options = {}] of callbacks){\n                    for (const key of keys){\n                        const isMacKey = key.startsWith(\"mac+\");\n                        if (isMac && isMacKey) {\n                            this.callbacks.set(key.slice(4), {\n                                callback,\n                                options\n                            });\n                            this.allKeys.add(key.split(\"+\").at(-1));\n                        } else if (!isMac && !isMacKey) {\n                            this.callbacks.set(key, {\n                                callback,\n                                options\n                            });\n                            this.allKeys.add(key.split(\"+\").at(-1));\n                        }\n                    }\n                }\n            }\n            #serialize(event) {\n                if (event.altKey) {\n                    this.buffer.push(\"alt\");\n                }\n                if (event.ctrlKey) {\n                    this.buffer.push(\"ctrl\");\n                }\n                if (event.metaKey) {\n                    this.buffer.push(\"meta\");\n                }\n                if (event.shiftKey) {\n                    this.buffer.push(\"shift\");\n                }\n                this.buffer.push(event.key);\n                const str = this.buffer.join(\"+\");\n                this.buffer.length = 0;\n                return str;\n            }\n            exec(self, event) {\n                if (!this.allKeys.has(event.key)) {\n                    return;\n                }\n                const info = this.callbacks.get(this.#serialize(event));\n                if (!info) {\n                    return;\n                }\n                const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n                if (checker && !checker(self, event)) {\n                    return;\n                }\n                callback.bind(self, ...args, event)();\n                if (!bubbles) {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n            }\n        }\n        class ColorManager {\n            static{\n                this._colorsMapping = new Map([\n                    [\n                        \"CanvasText\",\n                        [\n                            0,\n                            0,\n                            0\n                        ]\n                    ],\n                    [\n                        \"Canvas\",\n                        [\n                            255,\n                            255,\n                            255\n                        ]\n                    ]\n                ]);\n            }\n            get _colors() {\n                const colors = new Map([\n                    [\n                        \"CanvasText\",\n                        null\n                    ],\n                    [\n                        \"Canvas\",\n                        null\n                    ]\n                ]);\n                (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.getColorValues)(colors);\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_colors\", colors);\n            }\n            convert(color) {\n                const rgb = (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.getRGB)(color);\n                if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n                    return rgb;\n                }\n                for (const [name, RGB] of this._colors){\n                    if (RGB.every((x, i)=>x === rgb[i])) {\n                        return ColorManager._colorsMapping.get(name);\n                    }\n                }\n                return rgb;\n            }\n            getHexCode(name) {\n                const rgb = this._colors.get(name);\n                if (!rgb) {\n                    return name;\n                }\n                return _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.Util.makeHexColor(...rgb);\n            }\n        }\n        class AnnotationEditorUIManager {\n            #activeEditor;\n            #allEditors;\n            #allLayers;\n            #altTextManager;\n            #annotationStorage;\n            #commandManager;\n            #currentPageIndex;\n            #deletedAnnotationsElementIds;\n            #draggingEditors;\n            #editorTypes;\n            #editorsToRescale;\n            #filterFactory;\n            #focusMainContainerTimeoutId;\n            #highlightColors;\n            #idManager;\n            #isEnabled;\n            #isWaiting;\n            #lastActiveElement;\n            #mainHighlightColorPicker;\n            #mode;\n            #selectedEditors;\n            #pageColors;\n            #boundBlur;\n            #boundFocus;\n            #boundCopy;\n            #boundCut;\n            #boundPaste;\n            #boundKeydown;\n            #boundOnEditingAction;\n            #boundOnPageChanging;\n            #boundOnScaleChanging;\n            #boundOnRotationChanging;\n            #previousStates;\n            #translation;\n            #translationTimeoutId;\n            #container;\n            #viewer;\n            static{\n                this.TRANSLATE_SMALL = 1;\n            }\n            static{\n                this.TRANSLATE_BIG = 10;\n            }\n            static get _keyboardManager() {\n                const proto = AnnotationEditorUIManager.prototype;\n                const arrowChecker = (self)=>{\n                    return self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n                };\n                const textInputChecker = (_self, { target: el })=>{\n                    if (el instanceof HTMLInputElement) {\n                        const { type } = el;\n                        return type !== \"text\" && type !== \"number\";\n                    }\n                    return true;\n                };\n                const small = this.TRANSLATE_SMALL;\n                const big = this.TRANSLATE_BIG;\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_keyboardManager\", new KeyboardManager([\n                    [\n                        [\n                            \"ctrl+a\",\n                            \"mac+meta+a\"\n                        ],\n                        proto.selectAll,\n                        {\n                            checker: textInputChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+z\",\n                            \"mac+meta+z\"\n                        ],\n                        proto.undo,\n                        {\n                            checker: textInputChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+y\",\n                            \"ctrl+shift+z\",\n                            \"mac+meta+shift+z\",\n                            \"ctrl+shift+Z\",\n                            \"mac+meta+shift+Z\"\n                        ],\n                        proto.redo,\n                        {\n                            checker: textInputChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"Backspace\",\n                            \"alt+Backspace\",\n                            \"ctrl+Backspace\",\n                            \"shift+Backspace\",\n                            \"mac+Backspace\",\n                            \"mac+alt+Backspace\",\n                            \"mac+ctrl+Backspace\",\n                            \"Delete\",\n                            \"ctrl+Delete\",\n                            \"shift+Delete\",\n                            \"mac+Delete\"\n                        ],\n                        proto.delete,\n                        {\n                            checker: textInputChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"Enter\",\n                            \"mac+Enter\"\n                        ],\n                        proto.addNewEditorFromKeyboard,\n                        {\n                            checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                        }\n                    ],\n                    [\n                        [\n                            \" \",\n                            \"mac+ \"\n                        ],\n                        proto.addNewEditorFromKeyboard,\n                        {\n                            checker: (self)=>self.#container.contains(document.activeElement)\n                        }\n                    ],\n                    [\n                        [\n                            \"Escape\",\n                            \"mac+Escape\"\n                        ],\n                        proto.unselectAll\n                    ],\n                    [\n                        [\n                            \"ArrowLeft\",\n                            \"mac+ArrowLeft\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                -small,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowLeft\",\n                            \"mac+shift+ArrowLeft\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                -big,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowRight\",\n                            \"mac+ArrowRight\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                small,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowRight\",\n                            \"mac+shift+ArrowRight\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                big,\n                                0\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowUp\",\n                            \"mac+ArrowUp\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                0,\n                                -small\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowUp\",\n                            \"mac+shift+ArrowUp\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                0,\n                                -big\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ArrowDown\",\n                            \"mac+ArrowDown\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                0,\n                                small\n                            ],\n                            checker: arrowChecker\n                        }\n                    ],\n                    [\n                        [\n                            \"ctrl+ArrowDown\",\n                            \"mac+shift+ArrowDown\"\n                        ],\n                        proto.translateSelectedEditors,\n                        {\n                            args: [\n                                0,\n                                big\n                            ],\n                            checker: arrowChecker\n                        }\n                    ]\n                ]));\n            }\n            constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors){\n                this.#activeEditor = null;\n                this.#allEditors = new Map();\n                this.#allLayers = new Map();\n                this.#altTextManager = null;\n                this.#annotationStorage = null;\n                this.#commandManager = new CommandManager();\n                this.#currentPageIndex = 0;\n                this.#deletedAnnotationsElementIds = new Set();\n                this.#draggingEditors = null;\n                this.#editorTypes = null;\n                this.#editorsToRescale = new Set();\n                this.#filterFactory = null;\n                this.#focusMainContainerTimeoutId = null;\n                this.#highlightColors = null;\n                this.#idManager = new IdManager();\n                this.#isEnabled = false;\n                this.#isWaiting = false;\n                this.#lastActiveElement = null;\n                this.#mainHighlightColorPicker = null;\n                this.#mode = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorType.NONE;\n                this.#selectedEditors = new Set();\n                this.#pageColors = null;\n                this.#boundBlur = this.blur.bind(this);\n                this.#boundFocus = this.focus.bind(this);\n                this.#boundCopy = this.copy.bind(this);\n                this.#boundCut = this.cut.bind(this);\n                this.#boundPaste = this.paste.bind(this);\n                this.#boundKeydown = this.keydown.bind(this);\n                this.#boundOnEditingAction = this.onEditingAction.bind(this);\n                this.#boundOnPageChanging = this.onPageChanging.bind(this);\n                this.#boundOnScaleChanging = this.onScaleChanging.bind(this);\n                this.#boundOnRotationChanging = this.onRotationChanging.bind(this);\n                this.#previousStates = {\n                    isEditing: false,\n                    isEmpty: true,\n                    hasSomethingToUndo: false,\n                    hasSomethingToRedo: false,\n                    hasSelectedEditor: false\n                };\n                this.#translation = [\n                    0,\n                    0\n                ];\n                this.#translationTimeoutId = null;\n                this.#container = null;\n                this.#viewer = null;\n                this.#container = container;\n                this.#viewer = viewer;\n                this.#altTextManager = altTextManager;\n                this._eventBus = eventBus;\n                this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n                this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n                this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n                this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n                this.#annotationStorage = pdfDocument.annotationStorage;\n                this.#filterFactory = pdfDocument.filterFactory;\n                this.#pageColors = pageColors;\n                this.#highlightColors = highlightColors || null;\n                this.viewParameters = {\n                    realScale: _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.PixelsPerInch.PDF_TO_CSS_UNITS,\n                    rotation: 0\n                };\n            }\n            destroy() {\n                this.#removeKeyboardManager();\n                this.#removeFocusManager();\n                this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n                this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n                this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n                this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n                for (const layer of this.#allLayers.values()){\n                    layer.destroy();\n                }\n                this.#allLayers.clear();\n                this.#allEditors.clear();\n                this.#editorsToRescale.clear();\n                this.#activeEditor = null;\n                this.#selectedEditors.clear();\n                this.#commandManager.destroy();\n                this.#altTextManager?.destroy();\n                if (this.#focusMainContainerTimeoutId) {\n                    clearTimeout(this.#focusMainContainerTimeoutId);\n                    this.#focusMainContainerTimeoutId = null;\n                }\n                if (this.#translationTimeoutId) {\n                    clearTimeout(this.#translationTimeoutId);\n                    this.#translationTimeoutId = null;\n                }\n            }\n            get hcmFilter() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n            }\n            get direction() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n            }\n            get highlightColors() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>pair.split(\"=\").map((x)=>x.trim()))) : null);\n            }\n            setMainHighlightColorPicker(colorPicker) {\n                this.#mainHighlightColorPicker = colorPicker;\n            }\n            editAltText(editor) {\n                this.#altTextManager?.editAltText(this, editor);\n            }\n            onPageChanging({ pageNumber }) {\n                this.#currentPageIndex = pageNumber - 1;\n            }\n            focusMainContainer() {\n                this.#container.focus();\n            }\n            findParent(x, y) {\n                for (const layer of this.#allLayers.values()){\n                    const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n                    if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                        return layer;\n                    }\n                }\n                return null;\n            }\n            disableUserSelect(value = false) {\n                this.#viewer.classList.toggle(\"noUserSelect\", value);\n            }\n            addShouldRescale(editor) {\n                this.#editorsToRescale.add(editor);\n            }\n            removeShouldRescale(editor) {\n                this.#editorsToRescale.delete(editor);\n            }\n            onScaleChanging({ scale }) {\n                this.commitOrRemove();\n                this.viewParameters.realScale = scale * _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.PixelsPerInch.PDF_TO_CSS_UNITS;\n                for (const editor of this.#editorsToRescale){\n                    editor.onScaleChanging();\n                }\n            }\n            onRotationChanging({ pagesRotation }) {\n                this.commitOrRemove();\n                this.viewParameters.rotation = pagesRotation;\n            }\n            addToAnnotationStorage(editor) {\n                if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n                    this.#annotationStorage.setValue(editor.id, editor);\n                }\n            }\n            #addFocusManager() {\n                window.addEventListener(\"focus\", this.#boundFocus);\n                window.addEventListener(\"blur\", this.#boundBlur);\n            }\n            #removeFocusManager() {\n                window.removeEventListener(\"focus\", this.#boundFocus);\n                window.removeEventListener(\"blur\", this.#boundBlur);\n            }\n            blur() {\n                if (!this.hasSelection) {\n                    return;\n                }\n                const { activeElement } = document;\n                for (const editor of this.#selectedEditors){\n                    if (editor.div.contains(activeElement)) {\n                        this.#lastActiveElement = [\n                            editor,\n                            activeElement\n                        ];\n                        editor._focusEventsAllowed = false;\n                        break;\n                    }\n                }\n            }\n            focus() {\n                if (!this.#lastActiveElement) {\n                    return;\n                }\n                const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n                this.#lastActiveElement = null;\n                lastActiveElement.addEventListener(\"focusin\", ()=>{\n                    lastEditor._focusEventsAllowed = true;\n                }, {\n                    once: true\n                });\n                lastActiveElement.focus();\n            }\n            #addKeyboardManager() {\n                window.addEventListener(\"keydown\", this.#boundKeydown);\n            }\n            #removeKeyboardManager() {\n                window.removeEventListener(\"keydown\", this.#boundKeydown);\n            }\n            #addCopyPasteListeners() {\n                document.addEventListener(\"copy\", this.#boundCopy);\n                document.addEventListener(\"cut\", this.#boundCut);\n                document.addEventListener(\"paste\", this.#boundPaste);\n            }\n            #removeCopyPasteListeners() {\n                document.removeEventListener(\"copy\", this.#boundCopy);\n                document.removeEventListener(\"cut\", this.#boundCut);\n                document.removeEventListener(\"paste\", this.#boundPaste);\n            }\n            addEditListeners() {\n                this.#addKeyboardManager();\n                this.#addCopyPasteListeners();\n            }\n            removeEditListeners() {\n                this.#removeKeyboardManager();\n                this.#removeCopyPasteListeners();\n            }\n            copy(event) {\n                event.preventDefault();\n                this.#activeEditor?.commitOrRemove();\n                if (!this.hasSelection) {\n                    return;\n                }\n                const editors = [];\n                for (const editor of this.#selectedEditors){\n                    const serialized = editor.serialize(true);\n                    if (serialized) {\n                        editors.push(serialized);\n                    }\n                }\n                if (editors.length === 0) {\n                    return;\n                }\n                event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n            }\n            cut(event) {\n                this.copy(event);\n                this.delete();\n            }\n            paste(event) {\n                event.preventDefault();\n                const { clipboardData } = event;\n                for (const item of clipboardData.items){\n                    for (const editorType of this.#editorTypes){\n                        if (editorType.isHandlingMimeForPasting(item.type)) {\n                            editorType.paste(item, this.currentLayer);\n                            return;\n                        }\n                    }\n                }\n                let data = clipboardData.getData(\"application/pdfjs\");\n                if (!data) {\n                    return;\n                }\n                try {\n                    data = JSON.parse(data);\n                } catch (ex) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`paste: \"${ex.message}\".`);\n                    return;\n                }\n                if (!Array.isArray(data)) {\n                    return;\n                }\n                this.unselectAll();\n                const layer = this.currentLayer;\n                try {\n                    const newEditors = [];\n                    for (const editor of data){\n                        const deserializedEditor = layer.deserialize(editor);\n                        if (!deserializedEditor) {\n                            return;\n                        }\n                        newEditors.push(deserializedEditor);\n                    }\n                    const cmd = ()=>{\n                        for (const editor of newEditors){\n                            this.#addEditorToLayer(editor);\n                        }\n                        this.#selectEditors(newEditors);\n                    };\n                    const undo = ()=>{\n                        for (const editor of newEditors){\n                            editor.remove();\n                        }\n                    };\n                    this.addCommands({\n                        cmd,\n                        undo,\n                        mustExec: true\n                    });\n                } catch (ex) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`paste: \"${ex.message}\".`);\n                }\n            }\n            keydown(event) {\n                if (!this.isEditorHandlingKeyboard) {\n                    AnnotationEditorUIManager._keyboardManager.exec(this, event);\n                }\n            }\n            onEditingAction(details) {\n                if ([\n                    \"undo\",\n                    \"redo\",\n                    \"delete\",\n                    \"selectAll\"\n                ].includes(details.name)) {\n                    this[details.name]();\n                }\n            }\n            #dispatchUpdateStates(details) {\n                const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n                if (hasChanged) {\n                    this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                        source: this,\n                        details: Object.assign(this.#previousStates, details)\n                    });\n                }\n            }\n            #dispatchUpdateUI(details) {\n                this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n                    source: this,\n                    details\n                });\n            }\n            setEditingState(isEditing) {\n                if (isEditing) {\n                    this.#addFocusManager();\n                    this.#addKeyboardManager();\n                    this.#addCopyPasteListeners();\n                    this.#dispatchUpdateStates({\n                        isEditing: this.#mode !== _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorType.NONE,\n                        isEmpty: this.#isEmpty(),\n                        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                        hasSelectedEditor: false\n                    });\n                } else {\n                    this.#removeFocusManager();\n                    this.#removeKeyboardManager();\n                    this.#removeCopyPasteListeners();\n                    this.#dispatchUpdateStates({\n                        isEditing: false\n                    });\n                    this.disableUserSelect(false);\n                }\n            }\n            registerEditorTypes(types) {\n                if (this.#editorTypes) {\n                    return;\n                }\n                this.#editorTypes = types;\n                for (const editorType of this.#editorTypes){\n                    this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n                }\n            }\n            getId() {\n                return this.#idManager.getId();\n            }\n            get currentLayer() {\n                return this.#allLayers.get(this.#currentPageIndex);\n            }\n            getLayer(pageIndex) {\n                return this.#allLayers.get(pageIndex);\n            }\n            get currentPageIndex() {\n                return this.#currentPageIndex;\n            }\n            addLayer(layer) {\n                this.#allLayers.set(layer.pageIndex, layer);\n                if (this.#isEnabled) {\n                    layer.enable();\n                } else {\n                    layer.disable();\n                }\n            }\n            removeLayer(layer) {\n                this.#allLayers.delete(layer.pageIndex);\n            }\n            updateMode(mode, editId = null, isFromKeyboard = false) {\n                if (this.#mode === mode) {\n                    return;\n                }\n                this.#mode = mode;\n                if (mode === _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorType.NONE) {\n                    this.setEditingState(false);\n                    this.#disableAll();\n                    return;\n                }\n                this.setEditingState(true);\n                this.#enableAll();\n                this.unselectAll();\n                for (const layer of this.#allLayers.values()){\n                    layer.updateMode(mode);\n                }\n                if (!editId && isFromKeyboard) {\n                    this.addNewEditorFromKeyboard();\n                    return;\n                }\n                if (!editId) {\n                    return;\n                }\n                for (const editor of this.#allEditors.values()){\n                    if (editor.annotationElementId === editId) {\n                        this.setSelected(editor);\n                        editor.enterInEditMode();\n                        break;\n                    }\n                }\n            }\n            addNewEditorFromKeyboard() {\n                if (this.currentLayer.canCreateNewEmptyEditor()) {\n                    this.currentLayer.addNewEditor();\n                }\n            }\n            updateToolbar(mode) {\n                if (mode === this.#mode) {\n                    return;\n                }\n                this._eventBus.dispatch(\"switchannotationeditormode\", {\n                    source: this,\n                    mode\n                });\n            }\n            updateParams(type, value) {\n                if (!this.#editorTypes) {\n                    return;\n                }\n                switch(type){\n                    case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorParamsType.CREATE:\n                        this.currentLayer.addNewEditor();\n                        return;\n                    case _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                        this.#mainHighlightColorPicker?.updateColor(value);\n                        break;\n                }\n                for (const editor of this.#selectedEditors){\n                    editor.updateParams(type, value);\n                }\n                for (const editorType of this.#editorTypes){\n                    editorType.updateDefaultParams(type, value);\n                }\n            }\n            enableWaiting(mustWait = false) {\n                if (this.#isWaiting === mustWait) {\n                    return;\n                }\n                this.#isWaiting = mustWait;\n                for (const layer of this.#allLayers.values()){\n                    if (mustWait) {\n                        layer.disableClick();\n                    } else {\n                        layer.enableClick();\n                    }\n                    layer.div.classList.toggle(\"waiting\", mustWait);\n                }\n            }\n            #enableAll() {\n                if (!this.#isEnabled) {\n                    this.#isEnabled = true;\n                    for (const layer of this.#allLayers.values()){\n                        layer.enable();\n                    }\n                }\n            }\n            #disableAll() {\n                this.unselectAll();\n                if (this.#isEnabled) {\n                    this.#isEnabled = false;\n                    for (const layer of this.#allLayers.values()){\n                        layer.disable();\n                    }\n                }\n            }\n            getEditors(pageIndex) {\n                const editors = [];\n                for (const editor of this.#allEditors.values()){\n                    if (editor.pageIndex === pageIndex) {\n                        editors.push(editor);\n                    }\n                }\n                return editors;\n            }\n            getEditor(id) {\n                return this.#allEditors.get(id);\n            }\n            addEditor(editor) {\n                this.#allEditors.set(editor.id, editor);\n            }\n            removeEditor(editor) {\n                if (editor.div.contains(document.activeElement)) {\n                    if (this.#focusMainContainerTimeoutId) {\n                        clearTimeout(this.#focusMainContainerTimeoutId);\n                    }\n                    this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                        this.focusMainContainer();\n                        this.#focusMainContainerTimeoutId = null;\n                    }, 0);\n                }\n                this.#allEditors.delete(editor.id);\n                this.unselect(editor);\n                if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n                    this.#annotationStorage?.remove(editor.id);\n                }\n            }\n            addDeletedAnnotationElement(editor) {\n                this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n                editor.deleted = true;\n            }\n            isDeletedAnnotationElement(annotationElementId) {\n                return this.#deletedAnnotationsElementIds.has(annotationElementId);\n            }\n            removeDeletedAnnotationElement(editor) {\n                this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n                editor.deleted = false;\n            }\n            #addEditorToLayer(editor) {\n                const layer = this.#allLayers.get(editor.pageIndex);\n                if (layer) {\n                    layer.addOrRebuild(editor);\n                } else {\n                    this.addEditor(editor);\n                }\n            }\n            setActiveEditor(editor) {\n                if (this.#activeEditor === editor) {\n                    return;\n                }\n                this.#activeEditor = editor;\n                if (editor) {\n                    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                }\n            }\n            toggleSelected(editor) {\n                if (this.#selectedEditors.has(editor)) {\n                    this.#selectedEditors.delete(editor);\n                    editor.unselect();\n                    this.#dispatchUpdateStates({\n                        hasSelectedEditor: this.hasSelection\n                    });\n                    return;\n                }\n                this.#selectedEditors.add(editor);\n                editor.select();\n                this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                this.#dispatchUpdateStates({\n                    hasSelectedEditor: true\n                });\n            }\n            setSelected(editor) {\n                for (const ed of this.#selectedEditors){\n                    if (ed !== editor) {\n                        ed.unselect();\n                    }\n                }\n                this.#selectedEditors.clear();\n                this.#selectedEditors.add(editor);\n                editor.select();\n                this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                this.#dispatchUpdateStates({\n                    hasSelectedEditor: true\n                });\n            }\n            isSelected(editor) {\n                return this.#selectedEditors.has(editor);\n            }\n            get firstSelectedEditor() {\n                return this.#selectedEditors.values().next().value;\n            }\n            unselect(editor) {\n                editor.unselect();\n                this.#selectedEditors.delete(editor);\n                this.#dispatchUpdateStates({\n                    hasSelectedEditor: this.hasSelection\n                });\n            }\n            get hasSelection() {\n                return this.#selectedEditors.size !== 0;\n            }\n            get isEnterHandled() {\n                return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n            }\n            undo() {\n                this.#commandManager.undo();\n                this.#dispatchUpdateStates({\n                    hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                    hasSomethingToRedo: true,\n                    isEmpty: this.#isEmpty()\n                });\n            }\n            redo() {\n                this.#commandManager.redo();\n                this.#dispatchUpdateStates({\n                    hasSomethingToUndo: true,\n                    hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                    isEmpty: this.#isEmpty()\n                });\n            }\n            addCommands(params) {\n                this.#commandManager.add(params);\n                this.#dispatchUpdateStates({\n                    hasSomethingToUndo: true,\n                    hasSomethingToRedo: false,\n                    isEmpty: this.#isEmpty()\n                });\n            }\n            #isEmpty() {\n                if (this.#allEditors.size === 0) {\n                    return true;\n                }\n                if (this.#allEditors.size === 1) {\n                    for (const editor of this.#allEditors.values()){\n                        return editor.isEmpty();\n                    }\n                }\n                return false;\n            }\n            delete() {\n                this.commitOrRemove();\n                if (!this.hasSelection) {\n                    return;\n                }\n                const editors = [\n                    ...this.#selectedEditors\n                ];\n                const cmd = ()=>{\n                    for (const editor of editors){\n                        editor.remove();\n                    }\n                };\n                const undo = ()=>{\n                    for (const editor of editors){\n                        this.#addEditorToLayer(editor);\n                    }\n                };\n                this.addCommands({\n                    cmd,\n                    undo,\n                    mustExec: true\n                });\n            }\n            commitOrRemove() {\n                this.#activeEditor?.commitOrRemove();\n            }\n            hasSomethingToControl() {\n                return this.#activeEditor || this.hasSelection;\n            }\n            #selectEditors(editors) {\n                this.#selectedEditors.clear();\n                for (const editor of editors){\n                    if (editor.isEmpty()) {\n                        continue;\n                    }\n                    this.#selectedEditors.add(editor);\n                    editor.select();\n                }\n                this.#dispatchUpdateStates({\n                    hasSelectedEditor: true\n                });\n            }\n            selectAll() {\n                for (const editor of this.#selectedEditors){\n                    editor.commit();\n                }\n                this.#selectEditors(this.#allEditors.values());\n            }\n            unselectAll() {\n                if (this.#activeEditor) {\n                    this.#activeEditor.commitOrRemove();\n                    if (this.#mode !== _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorType.NONE) {\n                        return;\n                    }\n                }\n                if (!this.hasSelection) {\n                    return;\n                }\n                for (const editor of this.#selectedEditors){\n                    editor.unselect();\n                }\n                this.#selectedEditors.clear();\n                this.#dispatchUpdateStates({\n                    hasSelectedEditor: false\n                });\n            }\n            translateSelectedEditors(x, y, noCommit = false) {\n                if (!noCommit) {\n                    this.commitOrRemove();\n                }\n                if (!this.hasSelection) {\n                    return;\n                }\n                this.#translation[0] += x;\n                this.#translation[1] += y;\n                const [totalX, totalY] = this.#translation;\n                const editors = [\n                    ...this.#selectedEditors\n                ];\n                const TIME_TO_WAIT = 1000;\n                if (this.#translationTimeoutId) {\n                    clearTimeout(this.#translationTimeoutId);\n                }\n                this.#translationTimeoutId = setTimeout(()=>{\n                    this.#translationTimeoutId = null;\n                    this.#translation[0] = this.#translation[1] = 0;\n                    this.addCommands({\n                        cmd: ()=>{\n                            for (const editor of editors){\n                                if (this.#allEditors.has(editor.id)) {\n                                    editor.translateInPage(totalX, totalY);\n                                }\n                            }\n                        },\n                        undo: ()=>{\n                            for (const editor of editors){\n                                if (this.#allEditors.has(editor.id)) {\n                                    editor.translateInPage(-totalX, -totalY);\n                                }\n                            }\n                        },\n                        mustExec: false\n                    });\n                }, TIME_TO_WAIT);\n                for (const editor of editors){\n                    editor.translateInPage(x, y);\n                }\n            }\n            setUpDragSession() {\n                if (!this.hasSelection) {\n                    return;\n                }\n                this.disableUserSelect(true);\n                this.#draggingEditors = new Map();\n                for (const editor of this.#selectedEditors){\n                    this.#draggingEditors.set(editor, {\n                        savedX: editor.x,\n                        savedY: editor.y,\n                        savedPageIndex: editor.pageIndex,\n                        newX: 0,\n                        newY: 0,\n                        newPageIndex: -1\n                    });\n                }\n            }\n            endDragSession() {\n                if (!this.#draggingEditors) {\n                    return false;\n                }\n                this.disableUserSelect(false);\n                const map = this.#draggingEditors;\n                this.#draggingEditors = null;\n                let mustBeAddedInUndoStack = false;\n                for (const [{ x, y, pageIndex }, value] of map){\n                    value.newX = x;\n                    value.newY = y;\n                    value.newPageIndex = pageIndex;\n                    mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n                }\n                if (!mustBeAddedInUndoStack) {\n                    return false;\n                }\n                const move = (editor, x, y, pageIndex)=>{\n                    if (this.#allEditors.has(editor.id)) {\n                        const parent = this.#allLayers.get(pageIndex);\n                        if (parent) {\n                            editor._setParentAndPosition(parent, x, y);\n                        } else {\n                            editor.pageIndex = pageIndex;\n                            editor.x = x;\n                            editor.y = y;\n                        }\n                    }\n                };\n                this.addCommands({\n                    cmd: ()=>{\n                        for (const [editor, { newX, newY, newPageIndex }] of map){\n                            move(editor, newX, newY, newPageIndex);\n                        }\n                    },\n                    undo: ()=>{\n                        for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                            move(editor, savedX, savedY, savedPageIndex);\n                        }\n                    },\n                    mustExec: true\n                });\n                return true;\n            }\n            dragSelectedEditors(tx, ty) {\n                if (!this.#draggingEditors) {\n                    return;\n                }\n                for (const editor of this.#draggingEditors.keys()){\n                    editor.drag(tx, ty);\n                }\n            }\n            rebuild(editor) {\n                if (editor.parent === null) {\n                    const parent = this.getLayer(editor.pageIndex);\n                    if (parent) {\n                        parent.changeParent(editor);\n                        parent.addOrRebuild(editor);\n                    } else {\n                        this.addEditor(editor);\n                        this.addToAnnotationStorage(editor);\n                        editor.rebuild();\n                    }\n                } else {\n                    editor.parent.addOrRebuild(editor);\n                }\n            }\n            get isEditorHandlingKeyboard() {\n                return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n            }\n            isActive(editor) {\n                return this.#activeEditor === editor;\n            }\n            getActive() {\n                return this.#activeEditor;\n            }\n            getMode() {\n                return this.#mode;\n            }\n            get imageManager() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"imageManager\", new ImageManager());\n            }\n        }\n    /***/ },\n    /***/ 171: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_659471__)=>{\n        /* harmony export */ __nested_webpack_require_659471__.d(__nested_webpack_exports__, {\n            /* harmony export */ PDFFetchStream: ()=>/* binding */ PDFFetchStream\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_659471__(266);\n        /* harmony import */ var _network_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_659471__(253);\n        ;\n        function createFetchOptions(headers, withCredentials, abortController) {\n            return {\n                method: \"GET\",\n                headers,\n                signal: abortController.signal,\n                mode: \"cors\",\n                credentials: withCredentials ? \"include\" : \"same-origin\",\n                redirect: \"follow\"\n            };\n        }\n        function createHeaders(httpHeaders) {\n            const headers = new Headers();\n            for(const property in httpHeaders){\n                const value = httpHeaders[property];\n                if (value === undefined) {\n                    continue;\n                }\n                headers.append(property, value);\n            }\n            return headers;\n        }\n        function getArrayBuffer(val) {\n            if (val instanceof Uint8Array) {\n                return val.buffer;\n            }\n            if (val instanceof ArrayBuffer) {\n                return val;\n            }\n            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`getArrayBuffer - unexpected data format: ${val}`);\n            return new Uint8Array(val).buffer;\n        }\n        class PDFFetchStream {\n            constructor(source){\n                this.source = source;\n                this.isHttp = /^https?:/i.test(source.url);\n                this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                this._fullRequestReader = null;\n                this._rangeRequestReaders = [];\n            }\n            get _progressiveDataLength() {\n                return this._fullRequestReader?._loaded ?? 0;\n            }\n            getFullReader() {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n                this._fullRequestReader = new PDFFetchStreamReader(this);\n                return this._fullRequestReader;\n            }\n            getRangeReader(begin, end) {\n                if (end <= this._progressiveDataLength) {\n                    return null;\n                }\n                const reader = new PDFFetchStreamRangeReader(this, begin, end);\n                this._rangeRequestReaders.push(reader);\n                return reader;\n            }\n            cancelAllRequests(reason) {\n                this._fullRequestReader?.cancel(reason);\n                for (const reader of this._rangeRequestReaders.slice(0)){\n                    reader.cancel(reason);\n                }\n            }\n        }\n        class PDFFetchStreamReader {\n            constructor(stream){\n                this._stream = stream;\n                this._reader = null;\n                this._loaded = 0;\n                this._filename = null;\n                const source = stream.source;\n                this._withCredentials = source.withCredentials || false;\n                this._contentLength = source.length;\n                this._headersCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._disableRange = source.disableRange || false;\n                this._rangeChunkSize = source.rangeChunkSize;\n                if (!this._rangeChunkSize && !this._disableRange) {\n                    this._disableRange = true;\n                }\n                this._abortController = new AbortController();\n                this._isStreamingSupported = !source.disableStream;\n                this._isRangeSupported = !source.disableRange;\n                this._headers = createHeaders(this._stream.httpHeaders);\n                const url = source.url;\n                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                    if (!(0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateResponseStatus)(response.status)) {\n                        throw (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.createResponseStatusError)(response.status, url);\n                    }\n                    this._reader = response.body.getReader();\n                    this._headersCapability.resolve();\n                    const getResponseHeader = (name)=>{\n                        return response.headers.get(name);\n                    };\n                    const { allowRangeRequests, suggestedLength } = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateRangeRequestCapabilities)({\n                        getResponseHeader,\n                        isHttp: this._stream.isHttp,\n                        rangeChunkSize: this._rangeChunkSize,\n                        disableRange: this._disableRange\n                    });\n                    this._isRangeSupported = allowRangeRequests;\n                    this._contentLength = suggestedLength || this._contentLength;\n                    this._filename = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.extractFilenameFromHeader)(getResponseHeader);\n                    if (!this._isStreamingSupported && this._isRangeSupported) {\n                        this.cancel(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(\"Streaming is disabled.\"));\n                    }\n                }).catch(this._headersCapability.reject);\n                this.onProgress = null;\n            }\n            get headersReady() {\n                return this._headersCapability.promise;\n            }\n            get filename() {\n                return this._filename;\n            }\n            get contentLength() {\n                return this._contentLength;\n            }\n            get isRangeSupported() {\n                return this._isRangeSupported;\n            }\n            get isStreamingSupported() {\n                return this._isStreamingSupported;\n            }\n            async read() {\n                await this._headersCapability.promise;\n                const { value, done } = await this._reader.read();\n                if (done) {\n                    return {\n                        value,\n                        done\n                    };\n                }\n                this._loaded += value.byteLength;\n                this.onProgress?.({\n                    loaded: this._loaded,\n                    total: this._contentLength\n                });\n                return {\n                    value: getArrayBuffer(value),\n                    done: false\n                };\n            }\n            cancel(reason) {\n                this._reader?.cancel(reason);\n                this._abortController.abort();\n            }\n        }\n        class PDFFetchStreamRangeReader {\n            constructor(stream, begin, end){\n                this._stream = stream;\n                this._reader = null;\n                this._loaded = 0;\n                const source = stream.source;\n                this._withCredentials = source.withCredentials || false;\n                this._readCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._isStreamingSupported = !source.disableStream;\n                this._abortController = new AbortController();\n                this._headers = createHeaders(this._stream.httpHeaders);\n                this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n                const url = source.url;\n                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                    if (!(0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateResponseStatus)(response.status)) {\n                        throw (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.createResponseStatusError)(response.status, url);\n                    }\n                    this._readCapability.resolve();\n                    this._reader = response.body.getReader();\n                }).catch(this._readCapability.reject);\n                this.onProgress = null;\n            }\n            get isStreamingSupported() {\n                return this._isStreamingSupported;\n            }\n            async read() {\n                await this._readCapability.promise;\n                const { value, done } = await this._reader.read();\n                if (done) {\n                    return {\n                        value,\n                        done\n                    };\n                }\n                this._loaded += value.byteLength;\n                this.onProgress?.({\n                    loaded: this._loaded\n                });\n                return {\n                    value: getArrayBuffer(value),\n                    done: false\n                };\n            }\n            cancel(reason) {\n                this._reader?.cancel(reason);\n                this._abortController.abort();\n            }\n        }\n    /***/ },\n    /***/ 742: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_668732__)=>{\n        /* harmony export */ __nested_webpack_require_668732__.d(__nested_webpack_exports__, {\n            /* harmony export */ FontFaceObject: ()=>/* binding */ FontFaceObject,\n            /* harmony export */ FontLoader: ()=>/* binding */ FontLoader\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_668732__(266);\n        class FontLoader {\n            #systemFonts;\n            constructor({ ownerDocument = globalThis.document, styleElement = null }){\n                this.#systemFonts = new Set();\n                this._document = ownerDocument;\n                this.nativeFontFaces = new Set();\n                this.styleElement = null;\n                this.loadingRequests = [];\n                this.loadTestFontId = 0;\n            }\n            addNativeFontFace(nativeFontFace) {\n                this.nativeFontFaces.add(nativeFontFace);\n                this._document.fonts.add(nativeFontFace);\n            }\n            removeNativeFontFace(nativeFontFace) {\n                this.nativeFontFaces.delete(nativeFontFace);\n                this._document.fonts.delete(nativeFontFace);\n            }\n            insertRule(rule) {\n                if (!this.styleElement) {\n                    this.styleElement = this._document.createElement(\"style\");\n                    this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n                }\n                const styleSheet = this.styleElement.sheet;\n                styleSheet.insertRule(rule, styleSheet.cssRules.length);\n            }\n            clear() {\n                for (const nativeFontFace of this.nativeFontFaces){\n                    this._document.fonts.delete(nativeFontFace);\n                }\n                this.nativeFontFaces.clear();\n                this.#systemFonts.clear();\n                if (this.styleElement) {\n                    this.styleElement.remove();\n                    this.styleElement = null;\n                }\n            }\n            async loadSystemFont({ systemFontInfo: info, _inspectFont }) {\n                if (!info || this.#systemFonts.has(info.loadedName)) {\n                    return;\n                }\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n                if (this.isFontLoadingAPISupported) {\n                    const { loadedName, src, style } = info;\n                    const fontFace = new FontFace(loadedName, src, style);\n                    this.addNativeFontFace(fontFace);\n                    try {\n                        await fontFace.load();\n                        this.#systemFonts.add(loadedName);\n                        _inspectFont?.(info);\n                    } catch  {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                        this.removeNativeFontFace(fontFace);\n                    }\n                    return;\n                }\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n            }\n            async bind(font) {\n                if (font.attached || font.missingFile && !font.systemFontInfo) {\n                    return;\n                }\n                font.attached = true;\n                if (font.systemFontInfo) {\n                    await this.loadSystemFont(font);\n                    return;\n                }\n                if (this.isFontLoadingAPISupported) {\n                    const nativeFontFace = font.createNativeFontFace();\n                    if (nativeFontFace) {\n                        this.addNativeFontFace(nativeFontFace);\n                        try {\n                            await nativeFontFace.loaded;\n                        } catch (ex) {\n                            (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                            font.disableFontFace = true;\n                            throw ex;\n                        }\n                    }\n                    return;\n                }\n                const rule = font.createFontFaceRule();\n                if (rule) {\n                    this.insertRule(rule);\n                    if (this.isSyncFontLoadingSupported) {\n                        return;\n                    }\n                    await new Promise((resolve)=>{\n                        const request = this._queueLoadingCallback(resolve);\n                        this._prepareFontLoadEvent(font, request);\n                    });\n                }\n            }\n            get isFontLoadingAPISupported() {\n                const hasFonts = !!this._document?.fonts;\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n            }\n            get isSyncFontLoadingSupported() {\n                let supported = false;\n                if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS) {\n                    supported = true;\n                } else if (typeof navigator !== \"undefined\" && typeof navigator?.userAgent === \"string\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n                    supported = true;\n                }\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n            }\n            _queueLoadingCallback(callback) {\n                function completeRequest() {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n                    request.done = true;\n                    while(loadingRequests.length > 0 && loadingRequests[0].done){\n                        const otherRequest = loadingRequests.shift();\n                        setTimeout(otherRequest.callback, 0);\n                    }\n                }\n                const { loadingRequests } = this;\n                const request = {\n                    done: false,\n                    complete: completeRequest,\n                    callback\n                };\n                loadingRequests.push(request);\n                return request;\n            }\n            get _loadTestFont() {\n                const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow)(this, \"_loadTestFont\", testFont);\n            }\n            _prepareFontLoadEvent(font, request) {\n                function int32(data, offset) {\n                    return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n                }\n                function spliceString(s, offset, remove, insert) {\n                    const chunk1 = s.substring(0, offset);\n                    const chunk2 = s.substring(offset + remove);\n                    return chunk1 + insert + chunk2;\n                }\n                let i, ii;\n                const canvas = this._document.createElement(\"canvas\");\n                canvas.width = 1;\n                canvas.height = 1;\n                const ctx = canvas.getContext(\"2d\");\n                let called = 0;\n                function isFontReady(name, callback) {\n                    if (++called > 30) {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(\"Load test font never loaded.\");\n                        callback();\n                        return;\n                    }\n                    ctx.font = \"30px \" + name;\n                    ctx.fillText(\".\", 0, 20);\n                    const imageData = ctx.getImageData(0, 0, 1, 1);\n                    if (imageData.data[3] > 0) {\n                        callback();\n                        return;\n                    }\n                    setTimeout(isFontReady.bind(null, name, callback));\n                }\n                const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n                let data = this._loadTestFont;\n                const COMMENT_OFFSET = 976;\n                data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n                const CFF_CHECKSUM_OFFSET = 16;\n                const XXXX_VALUE = 0x58585858;\n                let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n                for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n                }\n                if (i < loadTestFontId.length) {\n                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n                }\n                data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.string32)(checksum));\n                const url = `url(data:font/opentype;base64,${btoa(data)});`;\n                const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n                this.insertRule(rule);\n                const div = this._document.createElement(\"div\");\n                div.style.visibility = \"hidden\";\n                div.style.width = div.style.height = \"10px\";\n                div.style.position = \"absolute\";\n                div.style.top = div.style.left = \"0px\";\n                for (const name of [\n                    font.loadedName,\n                    loadTestFontId\n                ]){\n                    const span = this._document.createElement(\"span\");\n                    span.textContent = \"Hi\";\n                    span.style.fontFamily = name;\n                    div.append(span);\n                }\n                this._document.body.append(div);\n                isFontReady(loadTestFontId, ()=>{\n                    div.remove();\n                    request.complete();\n                });\n            }\n        }\n        class FontFaceObject {\n            constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, inspectFont = null }){\n                this.compiledGlyphs = Object.create(null);\n                for(const i in translatedData){\n                    this[i] = translatedData[i];\n                }\n                this.isEvalSupported = isEvalSupported !== false;\n                this.disableFontFace = disableFontFace === true;\n                this.ignoreErrors = ignoreErrors === true;\n                this._inspectFont = inspectFont;\n            }\n            createNativeFontFace() {\n                if (!this.data || this.disableFontFace) {\n                    return null;\n                }\n                let nativeFontFace;\n                if (!this.cssFontInfo) {\n                    nativeFontFace = new FontFace(this.loadedName, this.data, {});\n                } else {\n                    const css = {\n                        weight: this.cssFontInfo.fontWeight\n                    };\n                    if (this.cssFontInfo.italicAngle) {\n                        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n                    }\n                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n                }\n                this._inspectFont?.(this);\n                return nativeFontFace;\n            }\n            createFontFaceRule() {\n                if (!this.data || this.disableFontFace) {\n                    return null;\n                }\n                const data = (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString)(this.data);\n                const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n                let rule;\n                if (!this.cssFontInfo) {\n                    rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n                } else {\n                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n                    if (this.cssFontInfo.italicAngle) {\n                        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n                    }\n                    rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n                }\n                this._inspectFont?.(this, url);\n                return rule;\n            }\n            getPathGenerator(objs, character) {\n                if (this.compiledGlyphs[character] !== undefined) {\n                    return this.compiledGlyphs[character];\n                }\n                let cmds;\n                try {\n                    cmds = objs.get(this.loadedName + \"_path_\" + character);\n                } catch (ex) {\n                    if (!this.ignoreErrors) {\n                        throw ex;\n                    }\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n                    return this.compiledGlyphs[character] = function(c, size) {};\n                }\n                if (this.isEvalSupported && _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.FeatureTest.isEvalSupported) {\n                    const jsBuf = [];\n                    for (const current of cmds){\n                        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n                        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n                    }\n                    return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n                }\n                return this.compiledGlyphs[character] = function(c, size) {\n                    for (const current of cmds){\n                        if (current.cmd === \"scale\") {\n                            current.args = [\n                                size,\n                                -size\n                            ];\n                        }\n                        c[current.cmd].apply(c, current.args);\n                    }\n                };\n            }\n        }\n    /***/ },\n    /***/ 472: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_684596__)=>{\n        /* harmony export */ __nested_webpack_require_684596__.d(__nested_webpack_exports__, {\n            /* harmony export */ Metadata: ()=>/* binding */ Metadata\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_684596__(266);\n        class Metadata {\n            #metadataMap;\n            #data;\n            constructor({ parsedData, rawData }){\n                this.#metadataMap = parsedData;\n                this.#data = rawData;\n            }\n            getRaw() {\n                return this.#data;\n            }\n            get(name) {\n                return this.#metadataMap.get(name) ?? null;\n            }\n            getAll() {\n                return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.objectFromMap)(this.#metadataMap);\n            }\n            has(name) {\n                return this.#metadataMap.has(name);\n            }\n        }\n    /***/ },\n    /***/ 474: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_685609__)=>{\n        /* harmony export */ __nested_webpack_require_685609__.d(__nested_webpack_exports__, {\n            /* harmony export */ PDFNetworkStream: ()=>/* binding */ PDFNetworkStream\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_685609__(266);\n        /* harmony import */ var _network_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_685609__(253);\n        ;\n        const OK_RESPONSE = 200;\n        const PARTIAL_CONTENT_RESPONSE = 206;\n        function getArrayBuffer(xhr) {\n            const data = xhr.response;\n            if (typeof data !== \"string\") {\n                return data;\n            }\n            return (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(data).buffer;\n        }\n        class NetworkManager {\n            constructor(url, args = {}){\n                this.url = url;\n                this.isHttp = /^https?:/i.test(url);\n                this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n                this.withCredentials = args.withCredentials || false;\n                this.currXhrId = 0;\n                this.pendingRequests = Object.create(null);\n            }\n            requestRange(begin, end, listeners) {\n                const args = {\n                    begin,\n                    end\n                };\n                for(const prop in listeners){\n                    args[prop] = listeners[prop];\n                }\n                return this.request(args);\n            }\n            requestFull(listeners) {\n                return this.request(listeners);\n            }\n            request(args) {\n                const xhr = new XMLHttpRequest();\n                const xhrId = this.currXhrId++;\n                const pendingRequest = this.pendingRequests[xhrId] = {\n                    xhr\n                };\n                xhr.open(\"GET\", this.url);\n                xhr.withCredentials = this.withCredentials;\n                for(const property in this.httpHeaders){\n                    const value = this.httpHeaders[property];\n                    if (value === undefined) {\n                        continue;\n                    }\n                    xhr.setRequestHeader(property, value);\n                }\n                if (this.isHttp && \"begin\" in args && \"end\" in args) {\n                    xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n                } else {\n                    pendingRequest.expectedStatus = OK_RESPONSE;\n                }\n                xhr.responseType = \"arraybuffer\";\n                if (args.onError) {\n                    xhr.onerror = function(evt) {\n                        args.onError(xhr.status);\n                    };\n                }\n                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n                xhr.onprogress = this.onProgress.bind(this, xhrId);\n                pendingRequest.onHeadersReceived = args.onHeadersReceived;\n                pendingRequest.onDone = args.onDone;\n                pendingRequest.onError = args.onError;\n                pendingRequest.onProgress = args.onProgress;\n                xhr.send(null);\n                return xhrId;\n            }\n            onProgress(xhrId, evt) {\n                const pendingRequest = this.pendingRequests[xhrId];\n                if (!pendingRequest) {\n                    return;\n                }\n                pendingRequest.onProgress?.(evt);\n            }\n            onStateChange(xhrId, evt) {\n                const pendingRequest = this.pendingRequests[xhrId];\n                if (!pendingRequest) {\n                    return;\n                }\n                const xhr = pendingRequest.xhr;\n                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n                    pendingRequest.onHeadersReceived();\n                    delete pendingRequest.onHeadersReceived;\n                }\n                if (xhr.readyState !== 4) {\n                    return;\n                }\n                if (!(xhrId in this.pendingRequests)) {\n                    return;\n                }\n                delete this.pendingRequests[xhrId];\n                if (xhr.status === 0 && this.isHttp) {\n                    pendingRequest.onError?.(xhr.status);\n                    return;\n                }\n                const xhrStatus = xhr.status || OK_RESPONSE;\n                const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n                    pendingRequest.onError?.(xhr.status);\n                    return;\n                }\n                const chunk = getArrayBuffer(xhr);\n                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n                    const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n                    const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n                    pendingRequest.onDone({\n                        begin: parseInt(matches[1], 10),\n                        chunk\n                    });\n                } else if (chunk) {\n                    pendingRequest.onDone({\n                        begin: 0,\n                        chunk\n                    });\n                } else {\n                    pendingRequest.onError?.(xhr.status);\n                }\n            }\n            getRequestXhr(xhrId) {\n                return this.pendingRequests[xhrId].xhr;\n            }\n            isPendingRequest(xhrId) {\n                return xhrId in this.pendingRequests;\n            }\n            abortRequest(xhrId) {\n                const xhr = this.pendingRequests[xhrId].xhr;\n                delete this.pendingRequests[xhrId];\n                xhr.abort();\n            }\n        }\n        class PDFNetworkStream {\n            constructor(source){\n                this._source = source;\n                this._manager = new NetworkManager(source.url, {\n                    httpHeaders: source.httpHeaders,\n                    withCredentials: source.withCredentials\n                });\n                this._rangeChunkSize = source.rangeChunkSize;\n                this._fullRequestReader = null;\n                this._rangeRequestReaders = [];\n            }\n            _onRangeRequestReaderClosed(reader) {\n                const i = this._rangeRequestReaders.indexOf(reader);\n                if (i >= 0) {\n                    this._rangeRequestReaders.splice(i, 1);\n                }\n            }\n            getFullReader() {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n                return this._fullRequestReader;\n            }\n            getRangeReader(begin, end) {\n                const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n                this._rangeRequestReaders.push(reader);\n                return reader;\n            }\n            cancelAllRequests(reason) {\n                this._fullRequestReader?.cancel(reason);\n                for (const reader of this._rangeRequestReaders.slice(0)){\n                    reader.cancel(reason);\n                }\n            }\n        }\n        class PDFNetworkStreamFullRequestReader {\n            constructor(manager, source){\n                this._manager = manager;\n                const args = {\n                    onHeadersReceived: this._onHeadersReceived.bind(this),\n                    onDone: this._onDone.bind(this),\n                    onError: this._onError.bind(this),\n                    onProgress: this._onProgress.bind(this)\n                };\n                this._url = source.url;\n                this._fullRequestId = manager.requestFull(args);\n                this._headersReceivedCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._disableRange = source.disableRange || false;\n                this._contentLength = source.length;\n                this._rangeChunkSize = source.rangeChunkSize;\n                if (!this._rangeChunkSize && !this._disableRange) {\n                    this._disableRange = true;\n                }\n                this._isStreamingSupported = false;\n                this._isRangeSupported = false;\n                this._cachedChunks = [];\n                this._requests = [];\n                this._done = false;\n                this._storedError = undefined;\n                this._filename = null;\n                this.onProgress = null;\n            }\n            _onHeadersReceived() {\n                const fullRequestXhrId = this._fullRequestId;\n                const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n                const getResponseHeader = (name)=>{\n                    return fullRequestXhr.getResponseHeader(name);\n                };\n                const { allowRangeRequests, suggestedLength } = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateRangeRequestCapabilities)({\n                    getResponseHeader,\n                    isHttp: this._manager.isHttp,\n                    rangeChunkSize: this._rangeChunkSize,\n                    disableRange: this._disableRange\n                });\n                if (allowRangeRequests) {\n                    this._isRangeSupported = true;\n                }\n                this._contentLength = suggestedLength || this._contentLength;\n                this._filename = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.extractFilenameFromHeader)(getResponseHeader);\n                if (this._isRangeSupported) {\n                    this._manager.abortRequest(fullRequestXhrId);\n                }\n                this._headersReceivedCapability.resolve();\n            }\n            _onDone(data) {\n                if (data) {\n                    if (this._requests.length > 0) {\n                        const requestCapability = this._requests.shift();\n                        requestCapability.resolve({\n                            value: data.chunk,\n                            done: false\n                        });\n                    } else {\n                        this._cachedChunks.push(data.chunk);\n                    }\n                }\n                this._done = true;\n                if (this._cachedChunks.length > 0) {\n                    return;\n                }\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n            }\n            _onError(status) {\n                this._storedError = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.createResponseStatusError)(status, this._url);\n                this._headersReceivedCapability.reject(this._storedError);\n                for (const requestCapability of this._requests){\n                    requestCapability.reject(this._storedError);\n                }\n                this._requests.length = 0;\n                this._cachedChunks.length = 0;\n            }\n            _onProgress(evt) {\n                this.onProgress?.({\n                    loaded: evt.loaded,\n                    total: evt.lengthComputable ? evt.total : this._contentLength\n                });\n            }\n            get filename() {\n                return this._filename;\n            }\n            get isRangeSupported() {\n                return this._isRangeSupported;\n            }\n            get isStreamingSupported() {\n                return this._isStreamingSupported;\n            }\n            get contentLength() {\n                return this._contentLength;\n            }\n            get headersReady() {\n                return this._headersReceivedCapability.promise;\n            }\n            async read() {\n                if (this._storedError) {\n                    throw this._storedError;\n                }\n                if (this._cachedChunks.length > 0) {\n                    const chunk = this._cachedChunks.shift();\n                    return {\n                        value: chunk,\n                        done: false\n                    };\n                }\n                if (this._done) {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n                const requestCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._requests.push(requestCapability);\n                return requestCapability.promise;\n            }\n            cancel(reason) {\n                this._done = true;\n                this._headersReceivedCapability.reject(reason);\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n                if (this._manager.isPendingRequest(this._fullRequestId)) {\n                    this._manager.abortRequest(this._fullRequestId);\n                }\n                this._fullRequestReader = null;\n            }\n        }\n        class PDFNetworkStreamRangeRequestReader {\n            constructor(manager, begin, end){\n                this._manager = manager;\n                const args = {\n                    onDone: this._onDone.bind(this),\n                    onError: this._onError.bind(this),\n                    onProgress: this._onProgress.bind(this)\n                };\n                this._url = manager.url;\n                this._requestId = manager.requestRange(begin, end, args);\n                this._requests = [];\n                this._queuedChunk = null;\n                this._done = false;\n                this._storedError = undefined;\n                this.onProgress = null;\n                this.onClosed = null;\n            }\n            _close() {\n                this.onClosed?.(this);\n            }\n            _onDone(data) {\n                const chunk = data.chunk;\n                if (this._requests.length > 0) {\n                    const requestCapability = this._requests.shift();\n                    requestCapability.resolve({\n                        value: chunk,\n                        done: false\n                    });\n                } else {\n                    this._queuedChunk = chunk;\n                }\n                this._done = true;\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n                this._close();\n            }\n            _onError(status) {\n                this._storedError = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.createResponseStatusError)(status, this._url);\n                for (const requestCapability of this._requests){\n                    requestCapability.reject(this._storedError);\n                }\n                this._requests.length = 0;\n                this._queuedChunk = null;\n            }\n            _onProgress(evt) {\n                if (!this.isStreamingSupported) {\n                    this.onProgress?.({\n                        loaded: evt.loaded\n                    });\n                }\n            }\n            get isStreamingSupported() {\n                return false;\n            }\n            async read() {\n                if (this._storedError) {\n                    throw this._storedError;\n                }\n                if (this._queuedChunk !== null) {\n                    const chunk = this._queuedChunk;\n                    this._queuedChunk = null;\n                    return {\n                        value: chunk,\n                        done: false\n                    };\n                }\n                if (this._done) {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n                const requestCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._requests.push(requestCapability);\n                return requestCapability.promise;\n            }\n            cancel(reason) {\n                this._done = true;\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n                if (this._manager.isPendingRequest(this._requestId)) {\n                    this._manager.abortRequest(this._requestId);\n                }\n                this._close();\n            }\n        }\n    /***/ },\n    /***/ 253: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_703065__)=>{\n        // EXPORTS\n        __nested_webpack_require_703065__.d(__nested_webpack_exports__, {\n            createResponseStatusError: ()=>/* binding */ createResponseStatusError,\n            extractFilenameFromHeader: ()=>/* binding */ extractFilenameFromHeader,\n            validateRangeRequestCapabilities: ()=>/* binding */ validateRangeRequestCapabilities,\n            validateResponseStatus: ()=>/* binding */ validateResponseStatus\n        });\n        // EXTERNAL MODULE: ./src/shared/util.js\n        var util = __nested_webpack_require_703065__(266);\n        ; // CONCATENATED MODULE: ./src/display/content_disposition.js\n        function getFilenameFromContentDispositionHeader(contentDisposition) {\n            let needsEncodingFixup = true;\n            let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n            if (tmp) {\n                tmp = tmp[1];\n                let filename = rfc2616unquote(tmp);\n                filename = unescape(filename);\n                filename = rfc5987decode(filename);\n                filename = rfc2047decode(filename);\n                return fixupEncoding(filename);\n            }\n            tmp = rfc2231getparam(contentDisposition);\n            if (tmp) {\n                const filename = rfc2047decode(tmp);\n                return fixupEncoding(filename);\n            }\n            tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n            if (tmp) {\n                tmp = tmp[1];\n                let filename = rfc2616unquote(tmp);\n                filename = rfc2047decode(filename);\n                return fixupEncoding(filename);\n            }\n            function toParamRegExp(attributePattern, flags) {\n                return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n            }\n            function textdecode(encoding, value) {\n                if (encoding) {\n                    if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                        return value;\n                    }\n                    try {\n                        const decoder = new TextDecoder(encoding, {\n                            fatal: true\n                        });\n                        const buffer = (0, util.stringToBytes)(value);\n                        value = decoder.decode(buffer);\n                        needsEncodingFixup = false;\n                    } catch  {}\n                }\n                return value;\n            }\n            function fixupEncoding(value) {\n                if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n                    value = textdecode(\"utf-8\", value);\n                    if (needsEncodingFixup) {\n                        value = textdecode(\"iso-8859-1\", value);\n                    }\n                }\n                return value;\n            }\n            function rfc2231getparam(contentDispositionStr) {\n                const matches = [];\n                let match;\n                const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n                while((match = iter.exec(contentDispositionStr)) !== null){\n                    let [, n, quot, part] = match;\n                    n = parseInt(n, 10);\n                    if (n in matches) {\n                        if (n === 0) {\n                            break;\n                        }\n                        continue;\n                    }\n                    matches[n] = [\n                        quot,\n                        part\n                    ];\n                }\n                const parts = [];\n                for(let n = 0; n < matches.length; ++n){\n                    if (!(n in matches)) {\n                        break;\n                    }\n                    let [quot, part] = matches[n];\n                    part = rfc2616unquote(part);\n                    if (quot) {\n                        part = unescape(part);\n                        if (n === 0) {\n                            part = rfc5987decode(part);\n                        }\n                    }\n                    parts.push(part);\n                }\n                return parts.join(\"\");\n            }\n            function rfc2616unquote(value) {\n                if (value.startsWith('\"')) {\n                    const parts = value.slice(1).split('\\\\\"');\n                    for(let i = 0; i < parts.length; ++i){\n                        const quotindex = parts[i].indexOf('\"');\n                        if (quotindex !== -1) {\n                            parts[i] = parts[i].slice(0, quotindex);\n                            parts.length = i + 1;\n                        }\n                        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n                    }\n                    value = parts.join('\"');\n                }\n                return value;\n            }\n            function rfc5987decode(extvalue) {\n                const encodingend = extvalue.indexOf(\"'\");\n                if (encodingend === -1) {\n                    return extvalue;\n                }\n                const encoding = extvalue.slice(0, encodingend);\n                const langvalue = extvalue.slice(encodingend + 1);\n                const value = langvalue.replace(/^[^']*'/, \"\");\n                return textdecode(encoding, value);\n            }\n            function rfc2047decode(value) {\n                if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n                    return value;\n                }\n                return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n                    if (encoding === \"q\" || encoding === \"Q\") {\n                        text = text.replaceAll(\"_\", \" \");\n                        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                            return String.fromCharCode(parseInt(hex, 16));\n                        });\n                        return textdecode(charset, text);\n                    }\n                    try {\n                        text = atob(text);\n                    } catch  {}\n                    return textdecode(charset, text);\n                });\n            }\n            return \"\";\n        }\n        // EXTERNAL MODULE: ./src/display/display_utils.js\n        var display_utils = __nested_webpack_require_703065__(473);\n        ; // CONCATENATED MODULE: ./src/display/network_utils.js\n        function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) {\n            const returnValues = {\n                allowRangeRequests: false,\n                suggestedLength: undefined\n            };\n            const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n            if (!Number.isInteger(length)) {\n                return returnValues;\n            }\n            returnValues.suggestedLength = length;\n            if (length <= 2 * rangeChunkSize) {\n                return returnValues;\n            }\n            if (disableRange || !isHttp) {\n                return returnValues;\n            }\n            if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n                return returnValues;\n            }\n            const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n            if (contentEncoding !== \"identity\") {\n                return returnValues;\n            }\n            returnValues.allowRangeRequests = true;\n            return returnValues;\n        }\n        function extractFilenameFromHeader(getResponseHeader) {\n            const contentDisposition = getResponseHeader(\"Content-Disposition\");\n            if (contentDisposition) {\n                let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n                if (filename.includes(\"%\")) {\n                    try {\n                        filename = decodeURIComponent(filename);\n                    } catch  {}\n                }\n                if ((0, display_utils.isPdfFile)(filename)) {\n                    return filename;\n                }\n            }\n            return null;\n        }\n        function createResponseStatusError(status, url) {\n            if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n                return new util.MissingPDFException('Missing PDF \"' + url + '\".');\n            }\n            return new util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n        }\n        function validateResponseStatus(status) {\n            return status === 200 || status === 206;\n        }\n    /***/ },\n    /***/ 498: /***/ (__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_711766__)=>{\n        __nested_webpack_require_711766__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__)=>{\n            try {\n                /* harmony export */ __nested_webpack_require_711766__.d(__nested_webpack_exports__, {\n                    /* harmony export */ PDFNodeStream: ()=>/* binding */ PDFNodeStream\n                });\n                /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_711766__(266);\n                /* harmony import */ var _network_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_711766__(253);\n                ;\n                let fs, http, https, url;\n                if (_shared_util_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJS) {\n                    fs = await import(/* webpackIgnore: true */ \"fs\");\n                    http = await import(/* webpackIgnore: true */ \"http\");\n                    https = await import(/* webpackIgnore: true */ \"https\");\n                    url = await import(/* webpackIgnore: true */ \"url\");\n                }\n                const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n                function parseUrl(sourceUrl) {\n                    const parsedUrl = url.parse(sourceUrl);\n                    if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n                        return parsedUrl;\n                    }\n                    if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n                        return url.parse(`file:///${sourceUrl}`);\n                    }\n                    if (!parsedUrl.host) {\n                        parsedUrl.protocol = \"file:\";\n                    }\n                    return parsedUrl;\n                }\n                class PDFNodeStream {\n                    constructor(source){\n                        this.source = source;\n                        this.url = parseUrl(source.url);\n                        this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n                        this.isFsUrl = this.url.protocol === \"file:\";\n                        this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(start, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n                        this._rangeRequestReaders.push(rangeReader);\n                        return rangeReader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                class BaseFullReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        const source = stream.source;\n                        this._contentLength = source.length;\n                        this._loaded = 0;\n                        this._filename = null;\n                        this._disableRange = source.disableRange || false;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = !source.disableStream;\n                        this._isRangeSupported = !source.disableRange;\n                        this._readableStream = null;\n                        this._readCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this._headersCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (!this._isStreamingSupported && this._isRangeSupported) {\n                            this._error(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(\"streaming is disabled\"));\n                        }\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                class BaseRangeReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        this._loaded = 0;\n                        this._readableStream = null;\n                        this._readCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        const source = stream.source;\n                        this._isStreamingSupported = !source.disableStream;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                function createRequestOptions(parsedUrl, headers) {\n                    return {\n                        protocol: parsedUrl.protocol,\n                        auth: parsedUrl.auth,\n                        host: parsedUrl.hostname,\n                        port: parsedUrl.port,\n                        path: parsedUrl.path,\n                        method: \"GET\",\n                        headers\n                    };\n                }\n                class PDFNodeStreamFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._headersCapability.resolve();\n                            this._setReadableStream(response);\n                            const getResponseHeader = (name)=>{\n                                return this._readableStream.headers[name.toLowerCase()];\n                            };\n                            const { allowRangeRequests, suggestedLength } = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateRangeRequestCapabilities)({\n                                getResponseHeader,\n                                isHttp: stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests;\n                            this._contentLength = suggestedLength || this._contentLength;\n                            this._filename = (0, _network_utils_js__WEBPACK_IMPORTED_MODULE_1__.extractFilenameFromHeader)(getResponseHeader);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        } else {\n                            this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                            this._headersCapability.reject(reason);\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        this._httpHeaders = {};\n                        for(const property in stream.httpHeaders){\n                            const value = stream.httpHeaders[property];\n                            if (value === undefined) {\n                                continue;\n                            }\n                            this._httpHeaders[property] = value;\n                        }\n                        this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                return;\n                            }\n                            this._setReadableStream(response);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        } else {\n                            this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamFsFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        fs.lstat(path, (error, stat)=>{\n                            if (error) {\n                                if (error.code === \"ENOENT\") {\n                                    error = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException(`Missing PDF \"${path}\".`);\n                                }\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._contentLength = stat.size;\n                            this._setReadableStream(fs.createReadStream(path));\n                            this._headersCapability.resolve();\n                        });\n                    }\n                }\n                class PDFNodeStreamFsRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        this._setReadableStream(fs.createReadStream(path, {\n                            start,\n                            end: end - 1\n                        }));\n                    }\n                }\n                __webpack_async_result__();\n            } catch (e) {\n                __webpack_async_result__(e);\n            }\n        }, 1);\n    /***/ },\n    /***/ 738: /***/ (__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_729861__)=>{\n        __nested_webpack_require_729861__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__)=>{\n            try {\n                /* harmony export */ __nested_webpack_require_729861__.d(__nested_webpack_exports__, {\n                    /* harmony export */ NodeCMapReaderFactory: ()=>/* binding */ NodeCMapReaderFactory,\n                    /* harmony export */ NodeCanvasFactory: ()=>/* binding */ NodeCanvasFactory,\n                    /* harmony export */ NodeFilterFactory: ()=>/* binding */ NodeFilterFactory,\n                    /* harmony export */ NodeStandardFontDataFactory: ()=>/* binding */ NodeStandardFontDataFactory\n                });\n                /* harmony import */ var _base_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_729861__(822);\n                /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_729861__(266);\n                ;\n                let fs, canvas, path2d_polyfill;\n                if (_shared_util_js__WEBPACK_IMPORTED_MODULE_1__.isNodeJS) {\n                    fs = await import(/* webpackIgnore: true */ \"fs\");\n                    try {\n                        canvas = await import(/* webpackIgnore: true */ \"canvas\");\n                    } catch  {}\n                    try {\n                        path2d_polyfill = await import(/* webpackIgnore: true */ \"path2d-polyfill\");\n                    } catch  {}\n                }\n                ;\n                const fetchData = function(url) {\n                    return new Promise((resolve, reject)=>{\n                        fs.readFile(url, (error, data)=>{\n                            if (error || !data) {\n                                reject(new Error(error));\n                                return;\n                            }\n                            resolve(new Uint8Array(data));\n                        });\n                    });\n                };\n                class NodeFilterFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseFilterFactory {\n                }\n                class NodeCanvasFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseCanvasFactory {\n                    _createCanvas(width, height) {\n                        return canvas.createCanvas(width, height);\n                    }\n                }\n                class NodeCMapReaderFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseCMapReaderFactory {\n                    _fetchData(url, compressionType) {\n                        return fetchData(url).then((data)=>{\n                            return {\n                                cMapData: data,\n                                compressionType\n                            };\n                        });\n                    }\n                }\n                class NodeStandardFontDataFactory extends _base_factory_js__WEBPACK_IMPORTED_MODULE_0__.BaseStandardFontDataFactory {\n                    _fetchData(url) {\n                        return fetchData(url);\n                    }\n                }\n                __webpack_async_result__();\n            } catch (e) {\n                __webpack_async_result__(e);\n            }\n        }, 1);\n    /***/ },\n    /***/ 890: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_733171__)=>{\n        /* harmony export */ __nested_webpack_require_733171__.d(__nested_webpack_exports__, {\n            /* harmony export */ OptionalContentConfig: ()=>/* binding */ OptionalContentConfig\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_733171__(266);\n        /* harmony import */ var _shared_murmurhash3_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_733171__(825);\n        const INTERNAL = Symbol(\"INTERNAL\");\n        class OptionalContentGroup {\n            #visible;\n            constructor(name, intent){\n                this.#visible = true;\n                this.name = name;\n                this.intent = intent;\n            }\n            get visible() {\n                return this.#visible;\n            }\n            _setVisible(internal, visible) {\n                if (internal !== INTERNAL) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)(\"Internal method `_setVisible` called.\");\n                }\n                this.#visible = visible;\n            }\n        }\n        class OptionalContentConfig {\n            #cachedGetHash;\n            #groups;\n            #initialHash;\n            #order;\n            constructor(data){\n                this.#cachedGetHash = null;\n                this.#groups = new Map();\n                this.#initialHash = null;\n                this.#order = null;\n                this.name = null;\n                this.creator = null;\n                if (data === null) {\n                    return;\n                }\n                this.name = data.name;\n                this.creator = data.creator;\n                this.#order = data.order;\n                for (const group of data.groups){\n                    this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n                }\n                if (data.baseState === \"OFF\") {\n                    for (const group of this.#groups.values()){\n                        group._setVisible(INTERNAL, false);\n                    }\n                }\n                for (const on of data.on){\n                    this.#groups.get(on)._setVisible(INTERNAL, true);\n                }\n                for (const off of data.off){\n                    this.#groups.get(off)._setVisible(INTERNAL, false);\n                }\n                this.#initialHash = this.getHash();\n            }\n            #evaluateVisibilityExpression(array) {\n                const length = array.length;\n                if (length < 2) {\n                    return true;\n                }\n                const operator = array[0];\n                for(let i = 1; i < length; i++){\n                    const element = array[i];\n                    let state;\n                    if (Array.isArray(element)) {\n                        state = this.#evaluateVisibilityExpression(element);\n                    } else if (this.#groups.has(element)) {\n                        state = this.#groups.get(element).visible;\n                    } else {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${element}`);\n                        return true;\n                    }\n                    switch(operator){\n                        case \"And\":\n                            if (!state) {\n                                return false;\n                            }\n                            break;\n                        case \"Or\":\n                            if (state) {\n                                return true;\n                            }\n                            break;\n                        case \"Not\":\n                            return !state;\n                        default:\n                            return true;\n                    }\n                }\n                return operator === \"And\";\n            }\n            isVisible(group) {\n                if (this.#groups.size === 0) {\n                    return true;\n                }\n                if (!group) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(\"Optional content group not defined.\");\n                    return true;\n                }\n                if (group.type === \"OCG\") {\n                    if (!this.#groups.has(group.id)) {\n                        (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${group.id}`);\n                        return true;\n                    }\n                    return this.#groups.get(group.id).visible;\n                } else if (group.type === \"OCMD\") {\n                    if (group.expression) {\n                        return this.#evaluateVisibilityExpression(group.expression);\n                    }\n                    if (!group.policy || group.policy === \"AnyOn\") {\n                        for (const id of group.ids){\n                            if (!this.#groups.has(id)) {\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${id}`);\n                                return true;\n                            }\n                            if (this.#groups.get(id).visible) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    } else if (group.policy === \"AllOn\") {\n                        for (const id of group.ids){\n                            if (!this.#groups.has(id)) {\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${id}`);\n                                return true;\n                            }\n                            if (!this.#groups.get(id).visible) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else if (group.policy === \"AnyOff\") {\n                        for (const id of group.ids){\n                            if (!this.#groups.has(id)) {\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${id}`);\n                                return true;\n                            }\n                            if (!this.#groups.get(id).visible) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    } else if (group.policy === \"AllOff\") {\n                        for (const id of group.ids){\n                            if (!this.#groups.has(id)) {\n                                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${id}`);\n                                return true;\n                            }\n                            if (this.#groups.get(id).visible) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unknown optional content policy ${group.policy}.`);\n                    return true;\n                }\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unknown group type ${group.type}.`);\n                return true;\n            }\n            setVisibility(id, visible = true) {\n                if (!this.#groups.has(id)) {\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.warn)(`Optional content group not found: ${id}`);\n                    return;\n                }\n                this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n                this.#cachedGetHash = null;\n            }\n            get hasInitialVisibility() {\n                return this.#initialHash === null || this.getHash() === this.#initialHash;\n            }\n            getOrder() {\n                if (!this.#groups.size) {\n                    return null;\n                }\n                if (this.#order) {\n                    return this.#order.slice();\n                }\n                return [\n                    ...this.#groups.keys()\n                ];\n            }\n            getGroups() {\n                return this.#groups.size > 0 ? (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.objectFromMap)(this.#groups) : null;\n            }\n            getGroup(id) {\n                return this.#groups.get(id) || null;\n            }\n            getHash() {\n                if (this.#cachedGetHash !== null) {\n                    return this.#cachedGetHash;\n                }\n                const hash = new _shared_murmurhash3_js__WEBPACK_IMPORTED_MODULE_1__.MurmurHash3_64();\n                for (const [id, group] of this.#groups){\n                    hash.update(`${id}:${group.visible}`);\n                }\n                return this.#cachedGetHash = hash.hexdigest();\n            }\n        }\n    /***/ },\n    /***/ 739: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_742279__)=>{\n        /* harmony export */ __nested_webpack_require_742279__.d(__nested_webpack_exports__, {\n            /* harmony export */ renderTextLayer: ()=>/* binding */ renderTextLayer,\n            /* harmony export */ updateTextLayer: ()=>/* binding */ updateTextLayer\n        });\n        /* unused harmony export TextLayerRenderTask */ /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_742279__(266);\n        /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_742279__(473);\n        const MAX_TEXT_DIVS_TO_RENDER = 100000;\n        const DEFAULT_FONT_SIZE = 30;\n        const DEFAULT_FONT_ASCENT = 0.8;\n        const ascentCache = new Map();\n        function getCtx(size, isOffscreenCanvasSupported) {\n            let ctx;\n            if (isOffscreenCanvasSupported && _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.FeatureTest.isOffscreenCanvasSupported) {\n                ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n                    alpha: false\n                });\n            } else {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = canvas.height = size;\n                ctx = canvas.getContext(\"2d\", {\n                    alpha: false\n                });\n            }\n            return ctx;\n        }\n        function getAscent(fontFamily, isOffscreenCanvasSupported) {\n            const cachedAscent = ascentCache.get(fontFamily);\n            if (cachedAscent) {\n                return cachedAscent;\n            }\n            const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n            ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n            const metrics = ctx.measureText(\"\");\n            let ascent = metrics.fontBoundingBoxAscent;\n            let descent = Math.abs(metrics.fontBoundingBoxDescent);\n            if (ascent) {\n                const ratio = ascent / (ascent + descent);\n                ascentCache.set(fontFamily, ratio);\n                ctx.canvas.width = ctx.canvas.height = 0;\n                return ratio;\n            }\n            ctx.strokeStyle = \"red\";\n            ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n            ctx.strokeText(\"g\", 0, 0);\n            let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n            descent = 0;\n            for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n                if (pixels[i] > 0) {\n                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                    break;\n                }\n            }\n            ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n            ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n            pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n            ascent = 0;\n            for(let i = 0, ii = pixels.length; i < ii; i += 4){\n                if (pixels[i] > 0) {\n                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                    break;\n                }\n            }\n            ctx.canvas.width = ctx.canvas.height = 0;\n            if (ascent) {\n                const ratio = ascent / (ascent + descent);\n                ascentCache.set(fontFamily, ratio);\n                return ratio;\n            }\n            ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n            return DEFAULT_FONT_ASCENT;\n        }\n        function appendText(task, geom, styles) {\n            const textDiv = document.createElement(\"span\");\n            const textDivProperties = {\n                angle: 0,\n                canvasWidth: 0,\n                hasText: geom.str !== \"\",\n                hasEOL: geom.hasEOL,\n                fontSize: 0\n            };\n            task._textDivs.push(textDiv);\n            const tx = _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.Util.transform(task._transform, geom.transform);\n            let angle = Math.atan2(tx[1], tx[0]);\n            const style = styles[geom.fontName];\n            if (style.vertical) {\n                angle += Math.PI / 2;\n            }\n            const fontFamily = task._fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n            const fontHeight = Math.hypot(tx[2], tx[3]);\n            const fontAscent = fontHeight * getAscent(fontFamily, task._isOffscreenCanvasSupported);\n            let left, top;\n            if (angle === 0) {\n                left = tx[4];\n                top = tx[5] - fontAscent;\n            } else {\n                left = tx[4] + fontAscent * Math.sin(angle);\n                top = tx[5] - fontAscent * Math.cos(angle);\n            }\n            const scaleFactorStr = \"calc(var(--scale-factor)*\";\n            const divStyle = textDiv.style;\n            if (task._container === task._rootContainer) {\n                divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;\n                divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;\n            } else {\n                divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n                divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n            }\n            divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;\n            divStyle.fontFamily = fontFamily;\n            textDivProperties.fontSize = fontHeight;\n            textDiv.setAttribute(\"role\", \"presentation\");\n            textDiv.textContent = geom.str;\n            textDiv.dir = geom.dir;\n            if (task._fontInspectorEnabled) {\n                textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n            }\n            if (angle !== 0) {\n                textDivProperties.angle = angle * (180 / Math.PI);\n            }\n            let shouldScaleText = false;\n            if (geom.str.length > 1) {\n                shouldScaleText = true;\n            } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n                const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n                if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                    shouldScaleText = true;\n                }\n            }\n            if (shouldScaleText) {\n                textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n            }\n            task._textDivProperties.set(textDiv, textDivProperties);\n            if (task._isReadableStream) {\n                task._layoutText(textDiv);\n            }\n        }\n        function layout(params) {\n            const { div, scale, properties, ctx, prevFontSize, prevFontFamily } = params;\n            const { style } = div;\n            let transform = \"\";\n            if (properties.canvasWidth !== 0 && properties.hasText) {\n                const { fontFamily } = style;\n                const { canvasWidth, fontSize } = properties;\n                if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n                    ctx.font = `${fontSize * scale}px ${fontFamily}`;\n                    params.prevFontSize = fontSize;\n                    params.prevFontFamily = fontFamily;\n                }\n                const { width } = ctx.measureText(div.textContent);\n                if (width > 0) {\n                    transform = `scaleX(${canvasWidth * scale / width})`;\n                }\n            }\n            if (properties.angle !== 0) {\n                transform = `rotate(${properties.angle}deg) ${transform}`;\n            }\n            if (transform.length > 0) {\n                style.transform = transform;\n            }\n        }\n        function render(task) {\n            if (task._canceled) {\n                return;\n            }\n            const textDivs = task._textDivs;\n            const capability = task._capability;\n            const textDivsLength = textDivs.length;\n            if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n                capability.resolve();\n                return;\n            }\n            if (!task._isReadableStream) {\n                for (const textDiv of textDivs){\n                    task._layoutText(textDiv);\n                }\n            }\n            capability.resolve();\n        }\n        class TextLayerRenderTask {\n            constructor({ textContentSource, container, viewport, textDivs, textDivProperties, textContentItemsStr, isOffscreenCanvasSupported }){\n                this._textContentSource = textContentSource;\n                this._isReadableStream = textContentSource instanceof ReadableStream;\n                this._container = this._rootContainer = container;\n                this._textDivs = textDivs || [];\n                this._textContentItemsStr = textContentItemsStr || [];\n                this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n                this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n                this._reader = null;\n                this._textDivProperties = textDivProperties || new WeakMap();\n                this._canceled = false;\n                this._capability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._layoutTextParams = {\n                    prevFontSize: null,\n                    prevFontFamily: null,\n                    div: null,\n                    scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n                    properties: null,\n                    ctx: getCtx(0, isOffscreenCanvasSupported)\n                };\n                const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                this._transform = [\n                    1,\n                    0,\n                    0,\n                    -1,\n                    -pageX,\n                    pageY + pageHeight\n                ];\n                this._pageWidth = pageWidth;\n                this._pageHeight = pageHeight;\n                (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.setLayerDimensions)(container, viewport);\n                this._capability.promise.finally(()=>{\n                    this._layoutTextParams = null;\n                }).catch(()=>{});\n            }\n            get promise() {\n                return this._capability.promise;\n            }\n            cancel() {\n                this._canceled = true;\n                if (this._reader) {\n                    this._reader.cancel(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(\"TextLayer task cancelled.\")).catch(()=>{});\n                    this._reader = null;\n                }\n                this._capability.reject(new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(\"TextLayer task cancelled.\"));\n            }\n            _processItems(items, styleCache) {\n                for (const item of items){\n                    if (item.str === undefined) {\n                        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                            const parent = this._container;\n                            this._container = document.createElement(\"span\");\n                            this._container.classList.add(\"markedContent\");\n                            if (item.id !== null) {\n                                this._container.setAttribute(\"id\", `${item.id}`);\n                            }\n                            parent.append(this._container);\n                        } else if (item.type === \"endMarkedContent\") {\n                            this._container = this._container.parentNode;\n                        }\n                        continue;\n                    }\n                    this._textContentItemsStr.push(item.str);\n                    appendText(this, item, styleCache);\n                }\n            }\n            _layoutText(textDiv) {\n                const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n                this._layoutTextParams.div = textDiv;\n                layout(this._layoutTextParams);\n                if (textDivProperties.hasText) {\n                    this._container.append(textDiv);\n                }\n                if (textDivProperties.hasEOL) {\n                    const br = document.createElement(\"br\");\n                    br.setAttribute(\"role\", \"presentation\");\n                    this._container.append(br);\n                }\n            }\n            _render() {\n                const capability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                let styleCache = Object.create(null);\n                if (this._isReadableStream) {\n                    const pump = ()=>{\n                        this._reader.read().then(({ value, done })=>{\n                            if (done) {\n                                capability.resolve();\n                                return;\n                            }\n                            Object.assign(styleCache, value.styles);\n                            this._processItems(value.items, styleCache);\n                            pump();\n                        }, capability.reject);\n                    };\n                    this._reader = this._textContentSource.getReader();\n                    pump();\n                } else if (this._textContentSource) {\n                    const { items, styles } = this._textContentSource;\n                    this._processItems(items, styles);\n                    capability.resolve();\n                } else {\n                    throw new Error('No \"textContentSource\" parameter specified.');\n                }\n                capability.promise.then(()=>{\n                    styleCache = null;\n                    render(this);\n                }, this._capability.reject);\n            }\n        }\n        function renderTextLayer(params) {\n            const task = new TextLayerRenderTask(params);\n            task._render();\n            return task;\n        }\n        function updateTextLayer({ container, viewport, textDivs, textDivProperties, isOffscreenCanvasSupported, mustRotate = true, mustRescale = true }) {\n            if (mustRotate) {\n                (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.setLayerDimensions)(container, {\n                    rotation: viewport.rotation\n                });\n            }\n            if (mustRescale) {\n                const ctx = getCtx(0, isOffscreenCanvasSupported);\n                const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n                const params = {\n                    prevFontSize: null,\n                    prevFontFamily: null,\n                    div: null,\n                    scale,\n                    properties: null,\n                    ctx\n                };\n                for (const div of textDivs){\n                    params.properties = textDivProperties.get(div);\n                    params.div = div;\n                    layout(params);\n                }\n            }\n        }\n    /***/ },\n    /***/ 92: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_757395__)=>{\n        /* harmony export */ __nested_webpack_require_757395__.d(__nested_webpack_exports__, {\n            /* harmony export */ PDFDataTransportStream: ()=>/* binding */ PDFDataTransportStream\n        });\n        /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_757395__(266);\n        /* harmony import */ var _display_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_757395__(473);\n        class PDFDataTransportStream {\n            constructor({ length, initialData, progressiveDone = false, contentDispositionFilename = null, disableRange = false, disableStream = false }, pdfDataRangeTransport){\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n                this._queuedChunks = [];\n                this._progressiveDone = progressiveDone;\n                this._contentDispositionFilename = contentDispositionFilename;\n                if (initialData?.length > 0) {\n                    const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n                    this._queuedChunks.push(buffer);\n                }\n                this._pdfDataRangeTransport = pdfDataRangeTransport;\n                this._isStreamingSupported = !disableStream;\n                this._isRangeSupported = !disableRange;\n                this._contentLength = length;\n                this._fullRequestReader = null;\n                this._rangeReaders = [];\n                this._pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n                    this._onReceiveData({\n                        begin,\n                        chunk\n                    });\n                });\n                this._pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n                    this._onProgress({\n                        loaded,\n                        total\n                    });\n                });\n                this._pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n                    this._onReceiveData({\n                        chunk\n                    });\n                });\n                this._pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n                    this._onProgressiveDone();\n                });\n                this._pdfDataRangeTransport.transportReady();\n            }\n            _onReceiveData({ begin, chunk }) {\n                const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n                if (begin === undefined) {\n                    if (this._fullRequestReader) {\n                        this._fullRequestReader._enqueue(buffer);\n                    } else {\n                        this._queuedChunks.push(buffer);\n                    }\n                } else {\n                    const found = this._rangeReaders.some(function(rangeReader) {\n                        if (rangeReader._begin !== begin) {\n                            return false;\n                        }\n                        rangeReader._enqueue(buffer);\n                        return true;\n                    });\n                    (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n                }\n            }\n            get _progressiveDataLength() {\n                return this._fullRequestReader?._loaded ?? 0;\n            }\n            _onProgress(evt) {\n                if (evt.total === undefined) {\n                    this._rangeReaders[0]?.onProgress?.({\n                        loaded: evt.loaded\n                    });\n                } else {\n                    this._fullRequestReader?.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                }\n            }\n            _onProgressiveDone() {\n                this._fullRequestReader?.progressiveDone();\n                this._progressiveDone = true;\n            }\n            _removeRangeReader(reader) {\n                const i = this._rangeReaders.indexOf(reader);\n                if (i >= 0) {\n                    this._rangeReaders.splice(i, 1);\n                }\n            }\n            getFullReader() {\n                (0, _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n                const queuedChunks = this._queuedChunks;\n                this._queuedChunks = null;\n                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n            }\n            getRangeReader(begin, end) {\n                if (end <= this._progressiveDataLength) {\n                    return null;\n                }\n                const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n                this._pdfDataRangeTransport.requestDataRange(begin, end);\n                this._rangeReaders.push(reader);\n                return reader;\n            }\n            cancelAllRequests(reason) {\n                this._fullRequestReader?.cancel(reason);\n                for (const reader of this._rangeReaders.slice(0)){\n                    reader.cancel(reason);\n                }\n                this._pdfDataRangeTransport.abort();\n            }\n        }\n        class PDFDataTransportStreamReader {\n            constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n                this._stream = stream;\n                this._done = progressiveDone || false;\n                this._filename = (0, _display_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n                this._queuedChunks = queuedChunks || [];\n                this._loaded = 0;\n                for (const chunk of this._queuedChunks){\n                    this._loaded += chunk.byteLength;\n                }\n                this._requests = [];\n                this._headersReady = Promise.resolve();\n                stream._fullRequestReader = this;\n                this.onProgress = null;\n            }\n            _enqueue(chunk) {\n                if (this._done) {\n                    return;\n                }\n                if (this._requests.length > 0) {\n                    const requestCapability = this._requests.shift();\n                    requestCapability.resolve({\n                        value: chunk,\n                        done: false\n                    });\n                } else {\n                    this._queuedChunks.push(chunk);\n                }\n                this._loaded += chunk.byteLength;\n            }\n            get headersReady() {\n                return this._headersReady;\n            }\n            get filename() {\n                return this._filename;\n            }\n            get isRangeSupported() {\n                return this._stream._isRangeSupported;\n            }\n            get isStreamingSupported() {\n                return this._stream._isStreamingSupported;\n            }\n            get contentLength() {\n                return this._stream._contentLength;\n            }\n            async read() {\n                if (this._queuedChunks.length > 0) {\n                    const chunk = this._queuedChunks.shift();\n                    return {\n                        value: chunk,\n                        done: false\n                    };\n                }\n                if (this._done) {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n                const requestCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._requests.push(requestCapability);\n                return requestCapability.promise;\n            }\n            cancel(reason) {\n                this._done = true;\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n            }\n            progressiveDone() {\n                if (this._done) {\n                    return;\n                }\n                this._done = true;\n            }\n        }\n        class PDFDataTransportStreamRangeReader {\n            constructor(stream, begin, end){\n                this._stream = stream;\n                this._begin = begin;\n                this._end = end;\n                this._queuedChunk = null;\n                this._requests = [];\n                this._done = false;\n                this.onProgress = null;\n            }\n            _enqueue(chunk) {\n                if (this._done) {\n                    return;\n                }\n                if (this._requests.length === 0) {\n                    this._queuedChunk = chunk;\n                } else {\n                    const requestsCapability = this._requests.shift();\n                    requestsCapability.resolve({\n                        value: chunk,\n                        done: false\n                    });\n                    for (const requestCapability of this._requests){\n                        requestCapability.resolve({\n                            value: undefined,\n                            done: true\n                        });\n                    }\n                    this._requests.length = 0;\n                }\n                this._done = true;\n                this._stream._removeRangeReader(this);\n            }\n            get isStreamingSupported() {\n                return false;\n            }\n            async read() {\n                if (this._queuedChunk) {\n                    const chunk = this._queuedChunk;\n                    this._queuedChunk = null;\n                    return {\n                        value: chunk,\n                        done: false\n                    };\n                }\n                if (this._done) {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n                const requestCapability = new _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this._requests.push(requestCapability);\n                return requestCapability.promise;\n            }\n            cancel(reason) {\n                this._done = true;\n                for (const requestCapability of this._requests){\n                    requestCapability.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n                this._requests.length = 0;\n                this._stream._removeRangeReader(this);\n            }\n        }\n    /***/ },\n    /***/ 368: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_768610__)=>{\n        /* harmony export */ __nested_webpack_require_768610__.d(__nested_webpack_exports__, {\n            /* harmony export */ GlobalWorkerOptions: ()=>/* binding */ GlobalWorkerOptions\n        });\n        const GlobalWorkerOptions = Object.create(null);\n        GlobalWorkerOptions.workerPort = null;\n        GlobalWorkerOptions.workerSrc = \"\";\n    /***/ },\n    /***/ 160: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_769053__)=>{\n        /* harmony export */ __nested_webpack_require_769053__.d(__nested_webpack_exports__, {\n            /* harmony export */ XfaLayer: ()=>/* binding */ XfaLayer\n        });\n        /* harmony import */ var _xfa_text_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_769053__(521);\n        class XfaLayer {\n            static setupStorage(html, id, element, storage, intent) {\n                const storedData = storage.getValue(id, {\n                    value: null\n                });\n                switch(element.name){\n                    case \"textarea\":\n                        if (storedData.value !== null) {\n                            html.textContent = storedData.value;\n                        }\n                        if (intent === \"print\") {\n                            break;\n                        }\n                        html.addEventListener(\"input\", (event)=>{\n                            storage.setValue(id, {\n                                value: event.target.value\n                            });\n                        });\n                        break;\n                    case \"input\":\n                        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                            if (storedData.value === element.attributes.xfaOn) {\n                                html.setAttribute(\"checked\", true);\n                            } else if (storedData.value === element.attributes.xfaOff) {\n                                html.removeAttribute(\"checked\");\n                            }\n                            if (intent === \"print\") {\n                                break;\n                            }\n                            html.addEventListener(\"change\", (event)=>{\n                                storage.setValue(id, {\n                                    value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                                });\n                            });\n                        } else {\n                            if (storedData.value !== null) {\n                                html.setAttribute(\"value\", storedData.value);\n                            }\n                            if (intent === \"print\") {\n                                break;\n                            }\n                            html.addEventListener(\"input\", (event)=>{\n                                storage.setValue(id, {\n                                    value: event.target.value\n                                });\n                            });\n                        }\n                        break;\n                    case \"select\":\n                        if (storedData.value !== null) {\n                            html.setAttribute(\"value\", storedData.value);\n                            for (const option of element.children){\n                                if (option.attributes.value === storedData.value) {\n                                    option.attributes.selected = true;\n                                } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                                    delete option.attributes.selected;\n                                }\n                            }\n                        }\n                        html.addEventListener(\"input\", (event)=>{\n                            const options = event.target.options;\n                            const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                            storage.setValue(id, {\n                                value\n                            });\n                        });\n                        break;\n                }\n            }\n            static setAttributes({ html, element, storage = null, intent, linkService }) {\n                const { attributes } = element;\n                const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n                if (attributes.type === \"radio\") {\n                    attributes.name = `${attributes.name}-${intent}`;\n                }\n                for (const [key, value] of Object.entries(attributes)){\n                    if (value === null || value === undefined) {\n                        continue;\n                    }\n                    switch(key){\n                        case \"class\":\n                            if (value.length) {\n                                html.setAttribute(key, value.join(\" \"));\n                            }\n                            break;\n                        case \"dataId\":\n                            break;\n                        case \"id\":\n                            html.setAttribute(\"data-element-id\", value);\n                            break;\n                        case \"style\":\n                            Object.assign(html.style, value);\n                            break;\n                        case \"textContent\":\n                            html.textContent = value;\n                            break;\n                        default:\n                            if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                                html.setAttribute(key, value);\n                            }\n                    }\n                }\n                if (isHTMLAnchorElement) {\n                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n                }\n                if (storage && attributes.dataId) {\n                    this.setupStorage(html, attributes.dataId, element, storage);\n                }\n            }\n            static render(parameters) {\n                const storage = parameters.annotationStorage;\n                const linkService = parameters.linkService;\n                const root = parameters.xfaHtml;\n                const intent = parameters.intent || \"display\";\n                const rootHtml = document.createElement(root.name);\n                if (root.attributes) {\n                    this.setAttributes({\n                        html: rootHtml,\n                        element: root,\n                        intent,\n                        linkService\n                    });\n                }\n                const isNotForRichText = intent !== \"richText\";\n                const rootDiv = parameters.div;\n                rootDiv.append(rootHtml);\n                if (parameters.viewport) {\n                    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                    rootDiv.style.transform = transform;\n                }\n                if (isNotForRichText) {\n                    rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n                }\n                const textDivs = [];\n                if (root.children.length === 0) {\n                    if (root.value) {\n                        const node = document.createTextNode(root.value);\n                        rootHtml.append(node);\n                        if (isNotForRichText && _xfa_text_js__WEBPACK_IMPORTED_MODULE_0__.XfaText.shouldBuildText(root.name)) {\n                            textDivs.push(node);\n                        }\n                    }\n                    return {\n                        textDivs\n                    };\n                }\n                const stack = [\n                    [\n                        root,\n                        -1,\n                        rootHtml\n                    ]\n                ];\n                while(stack.length > 0){\n                    const [parent, i, html] = stack.at(-1);\n                    if (i + 1 === parent.children.length) {\n                        stack.pop();\n                        continue;\n                    }\n                    const child = parent.children[++stack.at(-1)[1]];\n                    if (child === null) {\n                        continue;\n                    }\n                    const { name } = child;\n                    if (name === \"#text\") {\n                        const node = document.createTextNode(child.value);\n                        textDivs.push(node);\n                        html.append(node);\n                        continue;\n                    }\n                    const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n                    html.append(childHtml);\n                    if (child.attributes) {\n                        this.setAttributes({\n                            html: childHtml,\n                            element: child,\n                            storage,\n                            intent,\n                            linkService\n                        });\n                    }\n                    if (child.children?.length > 0) {\n                        stack.push([\n                            child,\n                            -1,\n                            childHtml\n                        ]);\n                    } else if (child.value) {\n                        const node = document.createTextNode(child.value);\n                        if (isNotForRichText && _xfa_text_js__WEBPACK_IMPORTED_MODULE_0__.XfaText.shouldBuildText(name)) {\n                            textDivs.push(node);\n                        }\n                        childHtml.append(node);\n                    }\n                }\n                for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n                    el.setAttribute(\"readOnly\", true);\n                }\n                return {\n                    textDivs\n                };\n            }\n            static update(parameters) {\n                const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                parameters.div.style.transform = transform;\n                parameters.div.hidden = false;\n            }\n        }\n    /***/ },\n    /***/ 521: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_779079__)=>{\n        /* harmony export */ __nested_webpack_require_779079__.d(__nested_webpack_exports__, {\n            /* harmony export */ XfaText: ()=>/* binding */ XfaText\n        });\n        class XfaText {\n            static textContent(xfa) {\n                const items = [];\n                const output = {\n                    items,\n                    styles: Object.create(null)\n                };\n                function walk(node) {\n                    if (!node) {\n                        return;\n                    }\n                    let str = null;\n                    const name = node.name;\n                    if (name === \"#text\") {\n                        str = node.value;\n                    } else if (!XfaText.shouldBuildText(name)) {\n                        return;\n                    } else if (node?.attributes?.textContent) {\n                        str = node.attributes.textContent;\n                    } else if (node.value) {\n                        str = node.value;\n                    }\n                    if (str !== null) {\n                        items.push({\n                            str\n                        });\n                    }\n                    if (!node.children) {\n                        return;\n                    }\n                    for (const child of node.children){\n                        walk(child);\n                    }\n                }\n                walk(xfa);\n                return output;\n            }\n            static shouldBuildText(name) {\n                return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n            }\n        }\n    /***/ },\n    /***/ 907: /***/ (__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_780812__)=>{\n        __nested_webpack_require_780812__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__)=>{\n            try {\n                /* harmony export */ __nested_webpack_require_780812__.d(__nested_webpack_exports__, {\n                    /* harmony export */ AbortException: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException,\n                    /* harmony export */ AnnotationEditorLayer: ()=>/* reexport safe */ _display_editor_annotation_editor_layer_js__WEBPACK_IMPORTED_MODULE_4__.AnnotationEditorLayer,\n                    /* harmony export */ AnnotationEditorParamsType: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorParamsType,\n                    /* harmony export */ AnnotationEditorType: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationEditorType,\n                    /* harmony export */ AnnotationEditorUIManager: ()=>/* reexport safe */ _display_editor_tools_js__WEBPACK_IMPORTED_MODULE_5__.AnnotationEditorUIManager,\n                    /* harmony export */ AnnotationLayer: ()=>/* reexport safe */ _display_annotation_layer_js__WEBPACK_IMPORTED_MODULE_6__.AnnotationLayer,\n                    /* harmony export */ AnnotationMode: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationMode,\n                    /* harmony export */ CMapCompressionType: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.CMapCompressionType,\n                    /* harmony export */ ColorPicker: ()=>/* reexport safe */ _display_editor_color_picker_js__WEBPACK_IMPORTED_MODULE_7__.ColorPicker,\n                    /* harmony export */ DOMSVGFactory: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.DOMSVGFactory,\n                    /* harmony export */ DrawLayer: ()=>/* reexport safe */ _display_draw_layer_js__WEBPACK_IMPORTED_MODULE_8__.DrawLayer,\n                    /* harmony export */ FeatureTest: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.FeatureTest,\n                    /* harmony export */ GlobalWorkerOptions: ()=>/* reexport safe */ _display_worker_options_js__WEBPACK_IMPORTED_MODULE_9__.GlobalWorkerOptions,\n                    /* harmony export */ ImageKind: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.ImageKind,\n                    /* harmony export */ InvalidPDFException: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.InvalidPDFException,\n                    /* harmony export */ MissingPDFException: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException,\n                    /* harmony export */ OPS: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.OPS,\n                    /* harmony export */ Outliner: ()=>/* reexport safe */ _display_editor_outliner_js__WEBPACK_IMPORTED_MODULE_10__.Outliner,\n                    /* harmony export */ PDFDataRangeTransport: ()=>/* reexport safe */ _display_api_js__WEBPACK_IMPORTED_MODULE_1__.PDFDataRangeTransport,\n                    /* harmony export */ PDFDateString: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.PDFDateString,\n                    /* harmony export */ PDFWorker: ()=>/* reexport safe */ _display_api_js__WEBPACK_IMPORTED_MODULE_1__.PDFWorker,\n                    /* harmony export */ PasswordResponses: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PasswordResponses,\n                    /* harmony export */ PermissionFlag: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PermissionFlag,\n                    /* harmony export */ PixelsPerInch: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.PixelsPerInch,\n                    /* harmony export */ PromiseCapability: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability,\n                    /* harmony export */ RenderingCancelledException: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.RenderingCancelledException,\n                    /* harmony export */ UnexpectedResponseException: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.UnexpectedResponseException,\n                    /* harmony export */ Util: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.Util,\n                    /* harmony export */ VerbosityLevel: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.VerbosityLevel,\n                    /* harmony export */ XfaLayer: ()=>/* reexport safe */ _display_xfa_layer_js__WEBPACK_IMPORTED_MODULE_11__.XfaLayer,\n                    /* harmony export */ build: ()=>/* reexport safe */ _display_api_js__WEBPACK_IMPORTED_MODULE_1__.build,\n                    /* harmony export */ createValidAbsoluteUrl: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.createValidAbsoluteUrl,\n                    /* harmony export */ fetchData: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.fetchData,\n                    /* harmony export */ getDocument: ()=>/* reexport safe */ _display_api_js__WEBPACK_IMPORTED_MODULE_1__.getDocument,\n                    /* harmony export */ getFilenameFromUrl: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.getFilenameFromUrl,\n                    /* harmony export */ getPdfFilenameFromUrl: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.getPdfFilenameFromUrl,\n                    /* harmony export */ getXfaPageViewport: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.getXfaPageViewport,\n                    /* harmony export */ isDataScheme: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isDataScheme,\n                    /* harmony export */ isPdfFile: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.isPdfFile,\n                    /* harmony export */ noContextMenu: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.noContextMenu,\n                    /* harmony export */ normalizeUnicode: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeUnicode,\n                    /* harmony export */ renderTextLayer: ()=>/* reexport safe */ _display_text_layer_js__WEBPACK_IMPORTED_MODULE_3__.renderTextLayer,\n                    /* harmony export */ setLayerDimensions: ()=>/* reexport safe */ _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__.setLayerDimensions,\n                    /* harmony export */ shadow: ()=>/* reexport safe */ _shared_util_js__WEBPACK_IMPORTED_MODULE_0__.shadow,\n                    /* harmony export */ updateTextLayer: ()=>/* reexport safe */ _display_text_layer_js__WEBPACK_IMPORTED_MODULE_3__.updateTextLayer,\n                    /* harmony export */ version: ()=>/* reexport safe */ _display_api_js__WEBPACK_IMPORTED_MODULE_1__.version\n                });\n                /* harmony import */ var _shared_util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_780812__(266);\n                /* harmony import */ var _display_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_780812__(406);\n                /* harmony import */ var _display_display_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_780812__(473);\n                /* harmony import */ var _display_text_layer_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_780812__(739);\n                /* harmony import */ var _display_editor_annotation_editor_layer_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_780812__(629);\n                /* harmony import */ var _display_editor_tools_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_780812__(812);\n                /* harmony import */ var _display_annotation_layer_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_780812__(640);\n                /* harmony import */ var _display_editor_color_picker_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_780812__(97);\n                /* harmony import */ var _display_draw_layer_js__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_780812__(423);\n                /* harmony import */ var _display_worker_options_js__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_780812__(368);\n                /* harmony import */ var _display_editor_outliner_js__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_780812__(405);\n                /* harmony import */ var _display_xfa_layer_js__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_780812__(160);\n                var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([\n                    _display_api_js__WEBPACK_IMPORTED_MODULE_1__\n                ]);\n                _display_api_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n                const pdfjsVersion = \"4.0.379\";\n                const pdfjsBuild = \"9e14d04fd\";\n                __webpack_async_result__();\n            } catch (e) {\n                __webpack_async_result__(e);\n            }\n        });\n    /***/ },\n    /***/ 694: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_790085__)=>{\n        /* harmony export */ __nested_webpack_require_790085__.d(__nested_webpack_exports__, {\n            /* harmony export */ MessageHandler: ()=>/* binding */ MessageHandler\n        });\n        /* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_790085__(266);\n        const CallbackKind = {\n            UNKNOWN: 0,\n            DATA: 1,\n            ERROR: 2\n        };\n        const StreamKind = {\n            UNKNOWN: 0,\n            CANCEL: 1,\n            CANCEL_COMPLETE: 2,\n            CLOSE: 3,\n            ENQUEUE: 4,\n            ERROR: 5,\n            PULL: 6,\n            PULL_COMPLETE: 7,\n            START_COMPLETE: 8\n        };\n        function wrapReason(reason) {\n            if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n                (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n            }\n            switch(reason.name){\n                case \"AbortException\":\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.AbortException(reason.message);\n                case \"MissingPDFException\":\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.MissingPDFException(reason.message);\n                case \"PasswordException\":\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.PasswordException(reason.message, reason.code);\n                case \"UnexpectedResponseException\":\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.UnexpectedResponseException(reason.message, reason.status);\n                case \"UnknownErrorException\":\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.UnknownErrorException(reason.message, reason.details);\n                default:\n                    return new _util_js__WEBPACK_IMPORTED_MODULE_0__.UnknownErrorException(reason.message, reason.toString());\n            }\n        }\n        class MessageHandler {\n            constructor(sourceName, targetName, comObj){\n                this.sourceName = sourceName;\n                this.targetName = targetName;\n                this.comObj = comObj;\n                this.callbackId = 1;\n                this.streamId = 1;\n                this.streamSinks = Object.create(null);\n                this.streamControllers = Object.create(null);\n                this.callbackCapabilities = Object.create(null);\n                this.actionHandler = Object.create(null);\n                this._onComObjOnMessage = (event)=>{\n                    const data = event.data;\n                    if (data.targetName !== this.sourceName) {\n                        return;\n                    }\n                    if (data.stream) {\n                        this.#processStreamMessage(data);\n                        return;\n                    }\n                    if (data.callback) {\n                        const callbackId = data.callbackId;\n                        const capability = this.callbackCapabilities[callbackId];\n                        if (!capability) {\n                            throw new Error(`Cannot resolve callback ${callbackId}`);\n                        }\n                        delete this.callbackCapabilities[callbackId];\n                        if (data.callback === CallbackKind.DATA) {\n                            capability.resolve(data.data);\n                        } else if (data.callback === CallbackKind.ERROR) {\n                            capability.reject(wrapReason(data.reason));\n                        } else {\n                            throw new Error(\"Unexpected callback case\");\n                        }\n                        return;\n                    }\n                    const action = this.actionHandler[data.action];\n                    if (!action) {\n                        throw new Error(`Unknown action from worker: ${data.action}`);\n                    }\n                    if (data.callbackId) {\n                        const cbSourceName = this.sourceName;\n                        const cbTargetName = data.sourceName;\n                        new Promise(function(resolve) {\n                            resolve(action(data.data));\n                        }).then(function(result) {\n                            comObj.postMessage({\n                                sourceName: cbSourceName,\n                                targetName: cbTargetName,\n                                callback: CallbackKind.DATA,\n                                callbackId: data.callbackId,\n                                data: result\n                            });\n                        }, function(reason) {\n                            comObj.postMessage({\n                                sourceName: cbSourceName,\n                                targetName: cbTargetName,\n                                callback: CallbackKind.ERROR,\n                                callbackId: data.callbackId,\n                                reason: wrapReason(reason)\n                            });\n                        });\n                        return;\n                    }\n                    if (data.streamId) {\n                        this.#createStreamSink(data);\n                        return;\n                    }\n                    action(data.data);\n                };\n                comObj.addEventListener(\"message\", this._onComObjOnMessage);\n            }\n            on(actionName, handler) {\n                const ah = this.actionHandler;\n                if (ah[actionName]) {\n                    throw new Error(`There is already an actionName called \"${actionName}\"`);\n                }\n                ah[actionName] = handler;\n            }\n            send(actionName, data, transfers) {\n                this.comObj.postMessage({\n                    sourceName: this.sourceName,\n                    targetName: this.targetName,\n                    action: actionName,\n                    data\n                }, transfers);\n            }\n            sendWithPromise(actionName, data, transfers) {\n                const callbackId = this.callbackId++;\n                const capability = new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                this.callbackCapabilities[callbackId] = capability;\n                try {\n                    this.comObj.postMessage({\n                        sourceName: this.sourceName,\n                        targetName: this.targetName,\n                        action: actionName,\n                        callbackId,\n                        data\n                    }, transfers);\n                } catch (ex) {\n                    capability.reject(ex);\n                }\n                return capability.promise;\n            }\n            sendWithStream(actionName, data, queueingStrategy, transfers) {\n                const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n                return new ReadableStream({\n                    start: (controller)=>{\n                        const startCapability = new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.streamControllers[streamId] = {\n                            controller,\n                            startCall: startCapability,\n                            pullCall: null,\n                            cancelCall: null,\n                            isClosed: false\n                        };\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            action: actionName,\n                            streamId,\n                            data,\n                            desiredSize: controller.desiredSize\n                        }, transfers);\n                        return startCapability.promise;\n                    },\n                    pull: (controller)=>{\n                        const pullCapability = new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.streamControllers[streamId].pullCall = pullCapability;\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            stream: StreamKind.PULL,\n                            streamId,\n                            desiredSize: controller.desiredSize\n                        });\n                        return pullCapability.promise;\n                    },\n                    cancel: (reason)=>{\n                        (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n                        const cancelCapability = new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                        this.streamControllers[streamId].cancelCall = cancelCapability;\n                        this.streamControllers[streamId].isClosed = true;\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            stream: StreamKind.CANCEL,\n                            streamId,\n                            reason: wrapReason(reason)\n                        });\n                        return cancelCapability.promise;\n                    }\n                }, queueingStrategy);\n            }\n            #createStreamSink(data) {\n                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                const self = this, action = this.actionHandler[data.action];\n                const streamSink = {\n                    enqueue (chunk, size = 1, transfers) {\n                        if (this.isCancelled) {\n                            return;\n                        }\n                        const lastDesiredSize = this.desiredSize;\n                        this.desiredSize -= size;\n                        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                            this.sinkCapability = new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability();\n                            this.ready = this.sinkCapability.promise;\n                        }\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            stream: StreamKind.ENQUEUE,\n                            streamId,\n                            chunk\n                        }, transfers);\n                    },\n                    close () {\n                        if (this.isCancelled) {\n                            return;\n                        }\n                        this.isCancelled = true;\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            stream: StreamKind.CLOSE,\n                            streamId\n                        });\n                        delete self.streamSinks[streamId];\n                    },\n                    error (reason) {\n                        (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(reason instanceof Error, \"error must have a valid reason\");\n                        if (this.isCancelled) {\n                            return;\n                        }\n                        this.isCancelled = true;\n                        comObj.postMessage({\n                            sourceName,\n                            targetName,\n                            stream: StreamKind.ERROR,\n                            streamId,\n                            reason: wrapReason(reason)\n                        });\n                    },\n                    sinkCapability: new _util_js__WEBPACK_IMPORTED_MODULE_0__.PromiseCapability(),\n                    onPull: null,\n                    onCancel: null,\n                    isCancelled: false,\n                    desiredSize: data.desiredSize,\n                    ready: null\n                };\n                streamSink.sinkCapability.resolve();\n                streamSink.ready = streamSink.sinkCapability.promise;\n                this.streamSinks[streamId] = streamSink;\n                new Promise(function(resolve) {\n                    resolve(action(data.data, streamSink));\n                }).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.START_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.START_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n            }\n            #processStreamMessage(data) {\n                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n                switch(data.stream){\n                    case StreamKind.START_COMPLETE:\n                        if (data.success) {\n                            streamController.startCall.resolve();\n                        } else {\n                            streamController.startCall.reject(wrapReason(data.reason));\n                        }\n                        break;\n                    case StreamKind.PULL_COMPLETE:\n                        if (data.success) {\n                            streamController.pullCall.resolve();\n                        } else {\n                            streamController.pullCall.reject(wrapReason(data.reason));\n                        }\n                        break;\n                    case StreamKind.PULL:\n                        if (!streamSink) {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.PULL_COMPLETE,\n                                streamId,\n                                success: true\n                            });\n                            break;\n                        }\n                        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                            streamSink.sinkCapability.resolve();\n                        }\n                        streamSink.desiredSize = data.desiredSize;\n                        new Promise(function(resolve) {\n                            resolve(streamSink.onPull?.());\n                        }).then(function() {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.PULL_COMPLETE,\n                                streamId,\n                                success: true\n                            });\n                        }, function(reason) {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.PULL_COMPLETE,\n                                streamId,\n                                reason: wrapReason(reason)\n                            });\n                        });\n                        break;\n                    case StreamKind.ENQUEUE:\n                        (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(streamController, \"enqueue should have stream controller\");\n                        if (streamController.isClosed) {\n                            break;\n                        }\n                        streamController.controller.enqueue(data.chunk);\n                        break;\n                    case StreamKind.CLOSE:\n                        (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(streamController, \"close should have stream controller\");\n                        if (streamController.isClosed) {\n                            break;\n                        }\n                        streamController.isClosed = true;\n                        streamController.controller.close();\n                        this.#deleteStreamController(streamController, streamId);\n                        break;\n                    case StreamKind.ERROR:\n                        (0, _util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(streamController, \"error should have stream controller\");\n                        streamController.controller.error(wrapReason(data.reason));\n                        this.#deleteStreamController(streamController, streamId);\n                        break;\n                    case StreamKind.CANCEL_COMPLETE:\n                        if (data.success) {\n                            streamController.cancelCall.resolve();\n                        } else {\n                            streamController.cancelCall.reject(wrapReason(data.reason));\n                        }\n                        this.#deleteStreamController(streamController, streamId);\n                        break;\n                    case StreamKind.CANCEL:\n                        if (!streamSink) {\n                            break;\n                        }\n                        new Promise(function(resolve) {\n                            resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n                        }).then(function() {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.CANCEL_COMPLETE,\n                                streamId,\n                                success: true\n                            });\n                        }, function(reason) {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.CANCEL_COMPLETE,\n                                streamId,\n                                reason: wrapReason(reason)\n                            });\n                        });\n                        streamSink.sinkCapability.reject(wrapReason(data.reason));\n                        streamSink.isCancelled = true;\n                        delete this.streamSinks[streamId];\n                        break;\n                    default:\n                        throw new Error(\"Unexpected stream case\");\n                }\n            }\n            async #deleteStreamController(streamController, streamId) {\n                await Promise.allSettled([\n                    streamController.startCall?.promise,\n                    streamController.pullCall?.promise,\n                    streamController.cancelCall?.promise\n                ]);\n                delete this.streamControllers[streamId];\n            }\n            destroy() {\n                this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n            }\n        }\n    /***/ },\n    /***/ 825: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_809492__)=>{\n        /* harmony export */ __nested_webpack_require_809492__.d(__nested_webpack_exports__, {\n            /* harmony export */ MurmurHash3_64: ()=>/* binding */ MurmurHash3_64\n        });\n        /* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_809492__(266);\n        const SEED = 0xc3d2e1f0;\n        const MASK_HIGH = 0xffff0000;\n        const MASK_LOW = 0xffff;\n        class MurmurHash3_64 {\n            constructor(seed){\n                this.h1 = seed ? seed & 0xffffffff : SEED;\n                this.h2 = seed ? seed & 0xffffffff : SEED;\n            }\n            update(input) {\n                let data, length;\n                if (typeof input === \"string\") {\n                    data = new Uint8Array(input.length * 2);\n                    length = 0;\n                    for(let i = 0, ii = input.length; i < ii; i++){\n                        const code = input.charCodeAt(i);\n                        if (code <= 0xff) {\n                            data[length++] = code;\n                        } else {\n                            data[length++] = code >>> 8;\n                            data[length++] = code & 0xff;\n                        }\n                    }\n                } else if ((0, _util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayBuffer)(input)) {\n                    data = input.slice();\n                    length = data.byteLength;\n                } else {\n                    throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n                }\n                const blockCounts = length >> 2;\n                const tailLength = length - blockCounts * 4;\n                const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n                let k1 = 0, k2 = 0;\n                let h1 = this.h1, h2 = this.h2;\n                const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n                const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n                for(let i = 0; i < blockCounts; i++){\n                    if (i & 1) {\n                        k1 = dataUint32[i];\n                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                        k1 = k1 << 15 | k1 >>> 17;\n                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                        h1 ^= k1;\n                        h1 = h1 << 13 | h1 >>> 19;\n                        h1 = h1 * 5 + 0xe6546b64;\n                    } else {\n                        k2 = dataUint32[i];\n                        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                        k2 = k2 << 15 | k2 >>> 17;\n                        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                        h2 ^= k2;\n                        h2 = h2 << 13 | h2 >>> 19;\n                        h2 = h2 * 5 + 0xe6546b64;\n                    }\n                }\n                k1 = 0;\n                switch(tailLength){\n                    case 3:\n                        k1 ^= data[blockCounts * 4 + 2] << 16;\n                    case 2:\n                        k1 ^= data[blockCounts * 4 + 1] << 8;\n                    case 1:\n                        k1 ^= data[blockCounts * 4];\n                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                        k1 = k1 << 15 | k1 >>> 17;\n                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                        if (blockCounts & 1) {\n                            h1 ^= k1;\n                        } else {\n                            h2 ^= k1;\n                        }\n                }\n                this.h1 = h1;\n                this.h2 = h2;\n            }\n            hexdigest() {\n                let h1 = this.h1, h2 = this.h2;\n                h1 ^= h2 >>> 1;\n                h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n                h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n                h1 ^= h2 >>> 1;\n                h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n                h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n                h1 ^= h2 >>> 1;\n                return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n            }\n        }\n    /***/ },\n    /***/ 266: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_813926__)=>{\n        /* harmony export */ __nested_webpack_require_813926__.d(__nested_webpack_exports__, {\n            /* harmony export */ AbortException: ()=>/* binding */ AbortException,\n            /* harmony export */ AnnotationBorderStyleType: ()=>/* binding */ AnnotationBorderStyleType,\n            /* harmony export */ AnnotationEditorParamsType: ()=>/* binding */ AnnotationEditorParamsType,\n            /* harmony export */ AnnotationEditorPrefix: ()=>/* binding */ AnnotationEditorPrefix,\n            /* harmony export */ AnnotationEditorType: ()=>/* binding */ AnnotationEditorType,\n            /* harmony export */ AnnotationMode: ()=>/* binding */ AnnotationMode,\n            /* harmony export */ AnnotationPrefix: ()=>/* binding */ AnnotationPrefix,\n            /* harmony export */ AnnotationType: ()=>/* binding */ AnnotationType,\n            /* harmony export */ BaseException: ()=>/* binding */ BaseException,\n            /* harmony export */ CMapCompressionType: ()=>/* binding */ CMapCompressionType,\n            /* harmony export */ FONT_IDENTITY_MATRIX: ()=>/* binding */ FONT_IDENTITY_MATRIX,\n            /* harmony export */ FeatureTest: ()=>/* binding */ FeatureTest1,\n            /* harmony export */ FormatError: ()=>/* binding */ FormatError,\n            /* harmony export */ IDENTITY_MATRIX: ()=>/* binding */ IDENTITY_MATRIX,\n            /* harmony export */ ImageKind: ()=>/* binding */ ImageKind1,\n            /* harmony export */ InvalidPDFException: ()=>/* binding */ InvalidPDFException,\n            /* harmony export */ LINE_FACTOR: ()=>/* binding */ LINE_FACTOR,\n            /* harmony export */ MAX_IMAGE_SIZE_TO_CACHE: ()=>/* binding */ MAX_IMAGE_SIZE_TO_CACHE,\n            /* harmony export */ MissingPDFException: ()=>/* binding */ MissingPDFException,\n            /* harmony export */ OPS: ()=>/* binding */ OPS,\n            /* harmony export */ PasswordException: ()=>/* binding */ PasswordException,\n            /* harmony export */ PasswordResponses: ()=>/* binding */ PasswordResponses,\n            /* harmony export */ PermissionFlag: ()=>/* binding */ PermissionFlag,\n            /* harmony export */ PromiseCapability: ()=>/* binding */ PromiseCapability,\n            /* harmony export */ RenderingIntentFlag: ()=>/* binding */ RenderingIntentFlag,\n            /* harmony export */ TextRenderingMode: ()=>/* binding */ TextRenderingMode,\n            /* harmony export */ UnexpectedResponseException: ()=>/* binding */ UnexpectedResponseException,\n            /* harmony export */ UnknownErrorException: ()=>/* binding */ UnknownErrorException,\n            /* harmony export */ Util: ()=>/* binding */ Util,\n            /* harmony export */ VerbosityLevel: ()=>/* binding */ VerbosityLevel,\n            /* harmony export */ assert: ()=>/* binding */ assert,\n            /* harmony export */ bytesToString: ()=>/* binding */ bytesToString,\n            /* harmony export */ createValidAbsoluteUrl: ()=>/* binding */ createValidAbsoluteUrl,\n            /* harmony export */ getUuid: ()=>/* binding */ getUuid,\n            /* harmony export */ getVerbosityLevel: ()=>/* binding */ getVerbosityLevel,\n            /* harmony export */ info: ()=>/* binding */ info,\n            /* harmony export */ isArrayBuffer: ()=>/* binding */ isArrayBuffer,\n            /* harmony export */ isNodeJS: ()=>/* binding */ isNodeJS,\n            /* harmony export */ normalizeUnicode: ()=>/* binding */ normalizeUnicode,\n            /* harmony export */ objectFromMap: ()=>/* binding */ objectFromMap,\n            /* harmony export */ setVerbosityLevel: ()=>/* binding */ setVerbosityLevel,\n            /* harmony export */ shadow: ()=>/* binding */ shadow,\n            /* harmony export */ string32: ()=>/* binding */ string32,\n            /* harmony export */ stringToBytes: ()=>/* binding */ stringToBytes,\n            /* harmony export */ unreachable: ()=>/* binding */ unreachable,\n            /* harmony export */ warn: ()=>/* binding */ warn\n        });\n        /* unused harmony exports AnnotationActionEventType, AnnotationFieldFlag, AnnotationFlag, AnnotationReplyType, BASELINE_FACTOR, DocumentActionEventType, getModificationDate, isArrayEqual, LINE_DESCENT_FACTOR, objectSize, PageActionEventType, stringToPDFString, stringToUTF8String, utf8StringToString */ const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n        const IDENTITY_MATRIX = [\n            1,\n            0,\n            0,\n            1,\n            0,\n            0\n        ];\n        const FONT_IDENTITY_MATRIX = [\n            0.001,\n            0,\n            0,\n            0.001,\n            0,\n            0\n        ];\n        const MAX_IMAGE_SIZE_TO_CACHE = 10e6;\n        const LINE_FACTOR = 1.35;\n        const LINE_DESCENT_FACTOR = 0.35;\n        const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\n        const RenderingIntentFlag = {\n            ANY: 0x01,\n            DISPLAY: 0x02,\n            PRINT: 0x04,\n            SAVE: 0x08,\n            ANNOTATIONS_FORMS: 0x10,\n            ANNOTATIONS_STORAGE: 0x20,\n            ANNOTATIONS_DISABLE: 0x40,\n            OPLIST: 0x100\n        };\n        const AnnotationMode = {\n            DISABLE: 0,\n            ENABLE: 1,\n            ENABLE_FORMS: 2,\n            ENABLE_STORAGE: 3\n        };\n        const AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\n        const AnnotationEditorType = {\n            DISABLE: -1,\n            NONE: 0,\n            FREETEXT: 3,\n            HIGHLIGHT: 9,\n            STAMP: 13,\n            INK: 15\n        };\n        const AnnotationEditorParamsType = {\n            RESIZE: 1,\n            CREATE: 2,\n            FREETEXT_SIZE: 11,\n            FREETEXT_COLOR: 12,\n            FREETEXT_OPACITY: 13,\n            INK_COLOR: 21,\n            INK_THICKNESS: 22,\n            INK_OPACITY: 23,\n            HIGHLIGHT_COLOR: 31,\n            HIGHLIGHT_DEFAULT_COLOR: 32\n        };\n        const PermissionFlag = {\n            PRINT: 0x04,\n            MODIFY_CONTENTS: 0x08,\n            COPY: 0x10,\n            MODIFY_ANNOTATIONS: 0x20,\n            FILL_INTERACTIVE_FORMS: 0x100,\n            COPY_FOR_ACCESSIBILITY: 0x200,\n            ASSEMBLE: 0x400,\n            PRINT_HIGH_QUALITY: 0x800\n        };\n        const TextRenderingMode = {\n            FILL: 0,\n            STROKE: 1,\n            FILL_STROKE: 2,\n            INVISIBLE: 3,\n            FILL_ADD_TO_PATH: 4,\n            STROKE_ADD_TO_PATH: 5,\n            FILL_STROKE_ADD_TO_PATH: 6,\n            ADD_TO_PATH: 7,\n            FILL_STROKE_MASK: 3,\n            ADD_TO_PATH_FLAG: 4\n        };\n        const ImageKind1 = {\n            GRAYSCALE_1BPP: 1,\n            RGB_24BPP: 2,\n            RGBA_32BPP: 3\n        };\n        const AnnotationType = {\n            TEXT: 1,\n            LINK: 2,\n            FREETEXT: 3,\n            LINE: 4,\n            SQUARE: 5,\n            CIRCLE: 6,\n            POLYGON: 7,\n            POLYLINE: 8,\n            HIGHLIGHT: 9,\n            UNDERLINE: 10,\n            SQUIGGLY: 11,\n            STRIKEOUT: 12,\n            STAMP: 13,\n            CARET: 14,\n            INK: 15,\n            POPUP: 16,\n            FILEATTACHMENT: 17,\n            SOUND: 18,\n            MOVIE: 19,\n            WIDGET: 20,\n            SCREEN: 21,\n            PRINTERMARK: 22,\n            TRAPNET: 23,\n            WATERMARK: 24,\n            THREED: 25,\n            REDACT: 26\n        };\n        const AnnotationReplyType = {\n            GROUP: \"Group\",\n            REPLY: \"R\"\n        };\n        const AnnotationFlag = {\n            INVISIBLE: 0x01,\n            HIDDEN: 0x02,\n            PRINT: 0x04,\n            NOZOOM: 0x08,\n            NOROTATE: 0x10,\n            NOVIEW: 0x20,\n            READONLY: 0x40,\n            LOCKED: 0x80,\n            TOGGLENOVIEW: 0x100,\n            LOCKEDCONTENTS: 0x200\n        };\n        const AnnotationFieldFlag = {\n            READONLY: 0x0000001,\n            REQUIRED: 0x0000002,\n            NOEXPORT: 0x0000004,\n            MULTILINE: 0x0001000,\n            PASSWORD: 0x0002000,\n            NOTOGGLETOOFF: 0x0004000,\n            RADIO: 0x0008000,\n            PUSHBUTTON: 0x0010000,\n            COMBO: 0x0020000,\n            EDIT: 0x0040000,\n            SORT: 0x0080000,\n            FILESELECT: 0x0100000,\n            MULTISELECT: 0x0200000,\n            DONOTSPELLCHECK: 0x0400000,\n            DONOTSCROLL: 0x0800000,\n            COMB: 0x1000000,\n            RICHTEXT: 0x2000000,\n            RADIOSINUNISON: 0x2000000,\n            COMMITONSELCHANGE: 0x4000000\n        };\n        const AnnotationBorderStyleType = {\n            SOLID: 1,\n            DASHED: 2,\n            BEVELED: 3,\n            INSET: 4,\n            UNDERLINE: 5\n        };\n        const AnnotationActionEventType = {\n            E: \"Mouse Enter\",\n            X: \"Mouse Exit\",\n            D: \"Mouse Down\",\n            U: \"Mouse Up\",\n            Fo: \"Focus\",\n            Bl: \"Blur\",\n            PO: \"PageOpen\",\n            PC: \"PageClose\",\n            PV: \"PageVisible\",\n            PI: \"PageInvisible\",\n            K: \"Keystroke\",\n            F: \"Format\",\n            V: \"Validate\",\n            C: \"Calculate\"\n        };\n        const DocumentActionEventType = {\n            WC: \"WillClose\",\n            WS: \"WillSave\",\n            DS: \"DidSave\",\n            WP: \"WillPrint\",\n            DP: \"DidPrint\"\n        };\n        const PageActionEventType = {\n            O: \"PageOpen\",\n            C: \"PageClose\"\n        };\n        const VerbosityLevel = {\n            ERRORS: 0,\n            WARNINGS: 1,\n            INFOS: 5\n        };\n        const CMapCompressionType = {\n            NONE: 0,\n            BINARY: 1\n        };\n        const OPS = {\n            dependency: 1,\n            setLineWidth: 2,\n            setLineCap: 3,\n            setLineJoin: 4,\n            setMiterLimit: 5,\n            setDash: 6,\n            setRenderingIntent: 7,\n            setFlatness: 8,\n            setGState: 9,\n            save: 10,\n            restore: 11,\n            transform: 12,\n            moveTo: 13,\n            lineTo: 14,\n            curveTo: 15,\n            curveTo2: 16,\n            curveTo3: 17,\n            closePath: 18,\n            rectangle: 19,\n            stroke: 20,\n            closeStroke: 21,\n            fill: 22,\n            eoFill: 23,\n            fillStroke: 24,\n            eoFillStroke: 25,\n            closeFillStroke: 26,\n            closeEOFillStroke: 27,\n            endPath: 28,\n            clip: 29,\n            eoClip: 30,\n            beginText: 31,\n            endText: 32,\n            setCharSpacing: 33,\n            setWordSpacing: 34,\n            setHScale: 35,\n            setLeading: 36,\n            setFont: 37,\n            setTextRenderingMode: 38,\n            setTextRise: 39,\n            moveText: 40,\n            setLeadingMoveText: 41,\n            setTextMatrix: 42,\n            nextLine: 43,\n            showText: 44,\n            showSpacedText: 45,\n            nextLineShowText: 46,\n            nextLineSetSpacingShowText: 47,\n            setCharWidth: 48,\n            setCharWidthAndBounds: 49,\n            setStrokeColorSpace: 50,\n            setFillColorSpace: 51,\n            setStrokeColor: 52,\n            setStrokeColorN: 53,\n            setFillColor: 54,\n            setFillColorN: 55,\n            setStrokeGray: 56,\n            setFillGray: 57,\n            setStrokeRGBColor: 58,\n            setFillRGBColor: 59,\n            setStrokeCMYKColor: 60,\n            setFillCMYKColor: 61,\n            shadingFill: 62,\n            beginInlineImage: 63,\n            beginImageData: 64,\n            endInlineImage: 65,\n            paintXObject: 66,\n            markPoint: 67,\n            markPointProps: 68,\n            beginMarkedContent: 69,\n            beginMarkedContentProps: 70,\n            endMarkedContent: 71,\n            beginCompat: 72,\n            endCompat: 73,\n            paintFormXObjectBegin: 74,\n            paintFormXObjectEnd: 75,\n            beginGroup: 76,\n            endGroup: 77,\n            beginAnnotation: 80,\n            endAnnotation: 81,\n            paintImageMaskXObject: 83,\n            paintImageMaskXObjectGroup: 84,\n            paintImageXObject: 85,\n            paintInlineImageXObject: 86,\n            paintInlineImageXObjectGroup: 87,\n            paintImageXObjectRepeat: 88,\n            paintImageMaskXObjectRepeat: 89,\n            paintSolidColorImageMask: 90,\n            constructPath: 91\n        };\n        const PasswordResponses = {\n            NEED_PASSWORD: 1,\n            INCORRECT_PASSWORD: 2\n        };\n        let verbosity = VerbosityLevel.WARNINGS;\n        function setVerbosityLevel(level) {\n            if (Number.isInteger(level)) {\n                verbosity = level;\n            }\n        }\n        function getVerbosityLevel() {\n            return verbosity;\n        }\n        function info(msg) {\n            if (verbosity >= VerbosityLevel.INFOS) {\n                console.log(`Info: ${msg}`);\n            }\n        }\n        function warn(msg) {\n            if (verbosity >= VerbosityLevel.WARNINGS) {\n                console.log(`Warning: ${msg}`);\n            }\n        }\n        function unreachable(msg) {\n            throw new Error(msg);\n        }\n        function assert(cond, msg) {\n            if (!cond) {\n                unreachable(msg);\n            }\n        }\n        function _isValidProtocol(url) {\n            switch(url?.protocol){\n                case \"http:\":\n                case \"https:\":\n                case \"ftp:\":\n                case \"mailto:\":\n                case \"tel:\":\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        function createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n            if (!url) {\n                return null;\n            }\n            try {\n                if (options && typeof url === \"string\") {\n                    if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                        const dots = url.match(/\\./g);\n                        if (dots?.length >= 2) {\n                            url = `http://${url}`;\n                        }\n                    }\n                    if (options.tryConvertEncoding) {\n                        try {\n                            url = stringToUTF8String(url);\n                        } catch  {}\n                    }\n                }\n                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                if (_isValidProtocol(absoluteUrl)) {\n                    return absoluteUrl;\n                }\n            } catch  {}\n            return null;\n        }\n        function shadow(obj, prop, value, nonSerializable = false) {\n            Object.defineProperty(obj, prop, {\n                value,\n                enumerable: !nonSerializable,\n                configurable: true,\n                writable: false\n            });\n            return value;\n        }\n        const BaseException = function BaseExceptionClosure() {\n            function BaseException(message, name) {\n                if (this.constructor === BaseException) {\n                    unreachable(\"Cannot initialize BaseException.\");\n                }\n                this.message = message;\n                this.name = name;\n            }\n            BaseException.prototype = new Error();\n            BaseException.constructor = BaseException;\n            return BaseException;\n        }();\n        class PasswordException extends BaseException {\n            constructor(msg, code){\n                super(msg, \"PasswordException\");\n                this.code = code;\n            }\n        }\n        class UnknownErrorException extends BaseException {\n            constructor(msg, details){\n                super(msg, \"UnknownErrorException\");\n                this.details = details;\n            }\n        }\n        class InvalidPDFException extends BaseException {\n            constructor(msg){\n                super(msg, \"InvalidPDFException\");\n            }\n        }\n        class MissingPDFException extends BaseException {\n            constructor(msg){\n                super(msg, \"MissingPDFException\");\n            }\n        }\n        class UnexpectedResponseException extends BaseException {\n            constructor(msg, status){\n                super(msg, \"UnexpectedResponseException\");\n                this.status = status;\n            }\n        }\n        class FormatError extends BaseException {\n            constructor(msg){\n                super(msg, \"FormatError\");\n            }\n        }\n        class AbortException extends BaseException {\n            constructor(msg){\n                super(msg, \"AbortException\");\n            }\n        }\n        function bytesToString(bytes) {\n            if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n                unreachable(\"Invalid argument for bytesToString\");\n            }\n            const length = bytes.length;\n            const MAX_ARGUMENT_COUNT = 8192;\n            if (length < MAX_ARGUMENT_COUNT) {\n                return String.fromCharCode.apply(null, bytes);\n            }\n            const strBuf = [];\n            for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n                const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n                const chunk = bytes.subarray(i, chunkEnd);\n                strBuf.push(String.fromCharCode.apply(null, chunk));\n            }\n            return strBuf.join(\"\");\n        }\n        function stringToBytes(str) {\n            if (typeof str !== \"string\") {\n                unreachable(\"Invalid argument for stringToBytes\");\n            }\n            const length = str.length;\n            const bytes = new Uint8Array(length);\n            for(let i = 0; i < length; ++i){\n                bytes[i] = str.charCodeAt(i) & 0xff;\n            }\n            return bytes;\n        }\n        function string32(value) {\n            return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n        }\n        function objectSize(obj) {\n            return Object.keys(obj).length;\n        }\n        function objectFromMap(map) {\n            const obj = Object.create(null);\n            for (const [key, value] of map){\n                obj[key] = value;\n            }\n            return obj;\n        }\n        function isLittleEndian() {\n            const buffer8 = new Uint8Array(4);\n            buffer8[0] = 1;\n            const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n            return view32[0] === 1;\n        }\n        function isEvalSupported() {\n            try {\n                new Function(\"\");\n                return true;\n            } catch  {\n                return false;\n            }\n        }\n        class FeatureTest1 {\n            static get isLittleEndian() {\n                return shadow(this, \"isLittleEndian\", isLittleEndian());\n            }\n            static get isEvalSupported() {\n                return shadow(this, \"isEvalSupported\", isEvalSupported());\n            }\n            static get isOffscreenCanvasSupported() {\n                return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n            }\n            static get platform() {\n                if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n                    return shadow(this, \"platform\", {\n                        isMac: navigator.platform.includes(\"Mac\")\n                    });\n                }\n                return shadow(this, \"platform\", {\n                    isMac: false\n                });\n            }\n            static get isCSSRoundSupported() {\n                return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n            }\n        }\n        const hexNumbers = [\n            ...Array(256).keys()\n        ].map((n)=>n.toString(16).padStart(2, \"0\"));\n        class Util {\n            static makeHexColor(r, g, b) {\n                return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n            }\n            static scaleMinMax(transform, minMax) {\n                let temp;\n                if (transform[0]) {\n                    if (transform[0] < 0) {\n                        temp = minMax[0];\n                        minMax[0] = minMax[1];\n                        minMax[1] = temp;\n                    }\n                    minMax[0] *= transform[0];\n                    minMax[1] *= transform[0];\n                    if (transform[3] < 0) {\n                        temp = minMax[2];\n                        minMax[2] = minMax[3];\n                        minMax[3] = temp;\n                    }\n                    minMax[2] *= transform[3];\n                    minMax[3] *= transform[3];\n                } else {\n                    temp = minMax[0];\n                    minMax[0] = minMax[2];\n                    minMax[2] = temp;\n                    temp = minMax[1];\n                    minMax[1] = minMax[3];\n                    minMax[3] = temp;\n                    if (transform[1] < 0) {\n                        temp = minMax[2];\n                        minMax[2] = minMax[3];\n                        minMax[3] = temp;\n                    }\n                    minMax[2] *= transform[1];\n                    minMax[3] *= transform[1];\n                    if (transform[2] < 0) {\n                        temp = minMax[0];\n                        minMax[0] = minMax[1];\n                        minMax[1] = temp;\n                    }\n                    minMax[0] *= transform[2];\n                    minMax[1] *= transform[2];\n                }\n                minMax[0] += transform[4];\n                minMax[1] += transform[4];\n                minMax[2] += transform[5];\n                minMax[3] += transform[5];\n            }\n            static transform(m1, m2) {\n                return [\n                    m1[0] * m2[0] + m1[2] * m2[1],\n                    m1[1] * m2[0] + m1[3] * m2[1],\n                    m1[0] * m2[2] + m1[2] * m2[3],\n                    m1[1] * m2[2] + m1[3] * m2[3],\n                    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n                    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n                ];\n            }\n            static applyTransform(p, m) {\n                const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n                const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n                return [\n                    xt,\n                    yt\n                ];\n            }\n            static applyInverseTransform(p, m) {\n                const d = m[0] * m[3] - m[1] * m[2];\n                const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n                const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n                return [\n                    xt,\n                    yt\n                ];\n            }\n            static getAxialAlignedBoundingBox(r, m) {\n                const p1 = this.applyTransform(r, m);\n                const p2 = this.applyTransform(r.slice(2, 4), m);\n                const p3 = this.applyTransform([\n                    r[0],\n                    r[3]\n                ], m);\n                const p4 = this.applyTransform([\n                    r[2],\n                    r[1]\n                ], m);\n                return [\n                    Math.min(p1[0], p2[0], p3[0], p4[0]),\n                    Math.min(p1[1], p2[1], p3[1], p4[1]),\n                    Math.max(p1[0], p2[0], p3[0], p4[0]),\n                    Math.max(p1[1], p2[1], p3[1], p4[1])\n                ];\n            }\n            static inverseTransform(m) {\n                const d = m[0] * m[3] - m[1] * m[2];\n                return [\n                    m[3] / d,\n                    -m[1] / d,\n                    -m[2] / d,\n                    m[0] / d,\n                    (m[2] * m[5] - m[4] * m[3]) / d,\n                    (m[4] * m[1] - m[5] * m[0]) / d\n                ];\n            }\n            static singularValueDecompose2dScale(m) {\n                const transpose = [\n                    m[0],\n                    m[2],\n                    m[1],\n                    m[3]\n                ];\n                const a = m[0] * transpose[0] + m[1] * transpose[2];\n                const b = m[0] * transpose[1] + m[1] * transpose[3];\n                const c = m[2] * transpose[0] + m[3] * transpose[2];\n                const d = m[2] * transpose[1] + m[3] * transpose[3];\n                const first = (a + d) / 2;\n                const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n                const sx = first + second || 1;\n                const sy = first - second || 1;\n                return [\n                    Math.sqrt(sx),\n                    Math.sqrt(sy)\n                ];\n            }\n            static normalizeRect(rect) {\n                const r = rect.slice(0);\n                if (rect[0] > rect[2]) {\n                    r[0] = rect[2];\n                    r[2] = rect[0];\n                }\n                if (rect[1] > rect[3]) {\n                    r[1] = rect[3];\n                    r[3] = rect[1];\n                }\n                return r;\n            }\n            static intersect(rect1, rect2) {\n                const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n                const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n                if (xLow > xHigh) {\n                    return null;\n                }\n                const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n                const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n                if (yLow > yHigh) {\n                    return null;\n                }\n                return [\n                    xLow,\n                    yLow,\n                    xHigh,\n                    yHigh\n                ];\n            }\n            static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n                const tvalues = [], bounds = [\n                    [],\n                    []\n                ];\n                let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n                for(let i = 0; i < 2; ++i){\n                    if (i === 0) {\n                        b = 6 * x0 - 12 * x1 + 6 * x2;\n                        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                        c = 3 * x1 - 3 * x0;\n                    } else {\n                        b = 6 * y0 - 12 * y1 + 6 * y2;\n                        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                        c = 3 * y1 - 3 * y0;\n                    }\n                    if (Math.abs(a) < 1e-12) {\n                        if (Math.abs(b) < 1e-12) {\n                            continue;\n                        }\n                        t = -c / b;\n                        if (0 < t && t < 1) {\n                            tvalues.push(t);\n                        }\n                        continue;\n                    }\n                    b2ac = b * b - 4 * c * a;\n                    sqrtb2ac = Math.sqrt(b2ac);\n                    if (b2ac < 0) {\n                        continue;\n                    }\n                    t1 = (-b + sqrtb2ac) / (2 * a);\n                    if (0 < t1 && t1 < 1) {\n                        tvalues.push(t1);\n                    }\n                    t2 = (-b - sqrtb2ac) / (2 * a);\n                    if (0 < t2 && t2 < 1) {\n                        tvalues.push(t2);\n                    }\n                }\n                let j = tvalues.length, mt;\n                const jlen = j;\n                while(j--){\n                    t = tvalues[j];\n                    mt = 1 - t;\n                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n                }\n                bounds[0][jlen] = x0;\n                bounds[1][jlen] = y0;\n                bounds[0][jlen + 1] = x3;\n                bounds[1][jlen + 1] = y3;\n                bounds[0].length = bounds[1].length = jlen + 2;\n                return [\n                    Math.min(...bounds[0]),\n                    Math.min(...bounds[1]),\n                    Math.max(...bounds[0]),\n                    Math.max(...bounds[1])\n                ];\n            }\n        }\n        const PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\n        function stringToPDFString(str) {\n            if (str[0] >= \"\\xef\") {\n                let encoding;\n                if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n                    encoding = \"utf-16be\";\n                    if (str.length % 2 === 1) {\n                        str = str.slice(0, -1);\n                    }\n                } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n                    encoding = \"utf-16le\";\n                    if (str.length % 2 === 1) {\n                        str = str.slice(0, -1);\n                    }\n                } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n                    encoding = \"utf-8\";\n                }\n                if (encoding) {\n                    try {\n                        const decoder = new TextDecoder(encoding, {\n                            fatal: true\n                        });\n                        const buffer = stringToBytes(str);\n                        const decoded = decoder.decode(buffer);\n                        if (!decoded.includes(\"\\x1b\")) {\n                            return decoded;\n                        }\n                        return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n                    } catch (ex) {\n                        warn(`stringToPDFString: \"${ex}\".`);\n                    }\n                }\n            }\n            const strBuf = [];\n            for(let i = 0, ii = str.length; i < ii; i++){\n                const charCode = str.charCodeAt(i);\n                if (charCode === 0x1b) {\n                    while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n                    continue;\n                }\n                const code = PDFStringTranslateTable[charCode];\n                strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n            }\n            return strBuf.join(\"\");\n        }\n        function stringToUTF8String(str) {\n            return decodeURIComponent(escape(str));\n        }\n        function utf8StringToString(str) {\n            return unescape(encodeURIComponent(str));\n        }\n        function isArrayBuffer(v) {\n            return typeof v === \"object\" && v?.byteLength !== undefined;\n        }\n        function isArrayEqual(arr1, arr2) {\n            if (arr1.length !== arr2.length) {\n                return false;\n            }\n            for(let i = 0, ii = arr1.length; i < ii; i++){\n                if (arr1[i] !== arr2[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function getModificationDate(date = new Date()) {\n            const buffer = [\n                date.getUTCFullYear().toString(),\n                (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n                date.getUTCDate().toString().padStart(2, \"0\"),\n                date.getUTCHours().toString().padStart(2, \"0\"),\n                date.getUTCMinutes().toString().padStart(2, \"0\"),\n                date.getUTCSeconds().toString().padStart(2, \"0\")\n            ];\n            return buffer.join(\"\");\n        }\n        class PromiseCapability {\n            #settled;\n            constructor(){\n                this.#settled = false;\n                this.promise = new Promise((resolve, reject)=>{\n                    this.resolve = (data)=>{\n                        this.#settled = true;\n                        resolve(data);\n                    };\n                    this.reject = (reason)=>{\n                        this.#settled = true;\n                        reject(reason);\n                    };\n                });\n            }\n            get settled() {\n                return this.#settled;\n            }\n        }\n        let NormalizeRegex = null;\n        let NormalizationMap = null;\n        function normalizeUnicode(str) {\n            if (!NormalizeRegex) {\n                NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n                NormalizationMap = new Map([\n                    [\n                        \"ﬅ\",\n                        \"ſt\"\n                    ]\n                ]);\n            }\n            return str.replaceAll(NormalizeRegex, (_, p1, p2)=>{\n                return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n            });\n        }\n        function getUuid() {\n            if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n                return crypto.randomUUID();\n            }\n            const buf = new Uint8Array(32);\n            if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n                crypto.getRandomValues(buf);\n            } else {\n                for(let i = 0; i < 32; i++){\n                    buf[i] = Math.floor(Math.random() * 255);\n                }\n            }\n            return bytesToString(buf);\n        }\n        const AnnotationPrefix = \"pdfjs_internal_id_\";\n    /***/ }\n};\n/************************************************************************/ /******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ /******/ // The require function\n/******/ function __nested_webpack_require_850537__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/ var cachedModule = __webpack_module_cache__[moduleId];\n    /******/ if (cachedModule !== undefined) {\n        /******/ return cachedModule.exports;\n    /******/ }\n    /******/ // Create a new module (and put it into the cache)\n    /******/ var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/ exports: {}\n    };\n    /******/ /******/ // Execute the module function\n    /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_850537__);\n    /******/ /******/ // Return the exports of the module\n    /******/ return module.exports;\n/******/ }\n/******/ /************************************************************************/ /******/ /* webpack/runtime/async module */ /******/ (()=>{\n    /******/ var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\n    /******/ var webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\n    /******/ var webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\n    /******/ var resolveQueue = (queue)=>{\n        /******/ if (queue && queue.d < 1) {\n            /******/ queue.d = 1;\n            /******/ queue.forEach((fn)=>fn.r--);\n            /******/ queue.forEach((fn)=>fn.r-- ? fn.r++ : fn());\n        /******/ }\n    /******/ };\n    /******/ var wrapDeps = (deps)=>deps.map((dep)=>{\n            /******/ if (dep !== null && typeof dep === \"object\") {\n                /******/ if (dep[webpackQueues]) return dep;\n                /******/ if (dep.then) {\n                    /******/ var queue = [];\n                    /******/ queue.d = 0;\n                    /******/ dep.then((r)=>{\n                        /******/ obj[webpackExports] = r;\n                        /******/ resolveQueue(queue);\n                    /******/ }, (e)=>{\n                        /******/ obj[webpackError] = e;\n                        /******/ resolveQueue(queue);\n                    /******/ });\n                    /******/ var obj = {};\n                    /******/ obj[webpackQueues] = (fn)=>fn(queue);\n                    /******/ return obj;\n                /******/ }\n            /******/ }\n            /******/ var ret = {};\n            /******/ ret[webpackQueues] = (x)=>{};\n            /******/ ret[webpackExports] = dep;\n            /******/ return ret;\n        /******/ });\n    /******/ __nested_webpack_require_850537__.a = (module, body, hasAwait)=>{\n        /******/ var queue;\n        /******/ hasAwait && ((queue = []).d = -1);\n        /******/ var depQueues = new Set();\n        /******/ var exports = module.exports;\n        /******/ var currentDeps;\n        /******/ var outerResolve;\n        /******/ var reject;\n        /******/ var promise = new Promise((resolve, rej)=>{\n            /******/ reject = rej;\n            /******/ outerResolve = resolve;\n        /******/ });\n        /******/ promise[webpackExports] = exports;\n        /******/ promise[webpackQueues] = (fn)=>(queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"]((x)=>{}));\n        /******/ module.exports = promise;\n        /******/ body((deps)=>{\n            /******/ currentDeps = wrapDeps(deps);\n            /******/ var fn;\n            /******/ var getResult = ()=>currentDeps.map((d)=>{\n                    /******/ if (d[webpackError]) throw d[webpackError];\n                    /******/ return d[webpackExports];\n                /******/ });\n            /******/ var promise = new Promise((resolve)=>{\n                /******/ fn = ()=>resolve(getResult);\n                /******/ fn.r = 0;\n                /******/ var fnQueue = (q)=>q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn)));\n                /******/ currentDeps.map((dep)=>dep[webpackQueues](fnQueue));\n            /******/ });\n            /******/ return fn.r ? promise : getResult();\n        /******/ }, (err)=>(err ? reject(promise[webpackError] = err) : outerResolve(exports), resolveQueue(queue)));\n        /******/ queue && queue.d < 0 && (queue.d = 0);\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_850537__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_850537__.o(definition, key) && !__nested_webpack_require_850537__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_850537__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ /******/ /******/ // startup\n/******/ // Load entry module and return exports\n/******/ // This entry module used 'module' so it can't be inlined\n/******/ var __nested_webpack_exports__ = __nested_webpack_require_850537__(907);\n/******/ __nested_webpack_exports__ = globalThis.pdfjsLib = await (globalThis.pdfjsLibPromise = __nested_webpack_exports__);\n/******/ var __webpack_exports__AbortException = __nested_webpack_exports__.AbortException;\n/******/ var __webpack_exports__AnnotationEditorLayer = __nested_webpack_exports__.AnnotationEditorLayer;\n/******/ var __webpack_exports__AnnotationEditorParamsType = __nested_webpack_exports__.AnnotationEditorParamsType;\n/******/ var __webpack_exports__AnnotationEditorType = __nested_webpack_exports__.AnnotationEditorType;\n/******/ var __webpack_exports__AnnotationEditorUIManager = __nested_webpack_exports__.AnnotationEditorUIManager;\n/******/ var __webpack_exports__AnnotationLayer = __nested_webpack_exports__.AnnotationLayer;\n/******/ var __webpack_exports__AnnotationMode = __nested_webpack_exports__.AnnotationMode;\n/******/ var __webpack_exports__CMapCompressionType = __nested_webpack_exports__.CMapCompressionType;\n/******/ var __webpack_exports__ColorPicker = __nested_webpack_exports__.ColorPicker;\n/******/ var __webpack_exports__DOMSVGFactory = __nested_webpack_exports__.DOMSVGFactory;\n/******/ var __webpack_exports__DrawLayer = __nested_webpack_exports__.DrawLayer;\n/******/ var __webpack_exports__FeatureTest = __nested_webpack_exports__.FeatureTest;\n/******/ var __webpack_exports__GlobalWorkerOptions = __nested_webpack_exports__.GlobalWorkerOptions;\n/******/ var __webpack_exports__ImageKind = __nested_webpack_exports__.ImageKind;\n/******/ var __webpack_exports__InvalidPDFException = __nested_webpack_exports__.InvalidPDFException;\n/******/ var __webpack_exports__MissingPDFException = __nested_webpack_exports__.MissingPDFException;\n/******/ var __webpack_exports__OPS = __nested_webpack_exports__.OPS;\n/******/ var __webpack_exports__Outliner = __nested_webpack_exports__.Outliner;\n/******/ var __webpack_exports__PDFDataRangeTransport = __nested_webpack_exports__.PDFDataRangeTransport;\n/******/ var __webpack_exports__PDFDateString = __nested_webpack_exports__.PDFDateString;\n/******/ var __webpack_exports__PDFWorker = __nested_webpack_exports__.PDFWorker;\n/******/ var __webpack_exports__PasswordResponses = __nested_webpack_exports__.PasswordResponses;\n/******/ var __webpack_exports__PermissionFlag = __nested_webpack_exports__.PermissionFlag;\n/******/ var __webpack_exports__PixelsPerInch = __nested_webpack_exports__.PixelsPerInch;\n/******/ var __webpack_exports__PromiseCapability = __nested_webpack_exports__.PromiseCapability;\n/******/ var __webpack_exports__RenderingCancelledException = __nested_webpack_exports__.RenderingCancelledException;\n/******/ var __webpack_exports__UnexpectedResponseException = __nested_webpack_exports__.UnexpectedResponseException;\n/******/ var __webpack_exports__Util = __nested_webpack_exports__.Util;\n/******/ var __webpack_exports__VerbosityLevel = __nested_webpack_exports__.VerbosityLevel;\n/******/ var __webpack_exports__XfaLayer = __nested_webpack_exports__.XfaLayer;\n/******/ var __webpack_exports__build = __nested_webpack_exports__.build;\n/******/ var __webpack_exports__createValidAbsoluteUrl = __nested_webpack_exports__.createValidAbsoluteUrl;\n/******/ var __webpack_exports__fetchData = __nested_webpack_exports__.fetchData;\n/******/ var __webpack_exports__getDocument = __nested_webpack_exports__.getDocument;\n/******/ var __webpack_exports__getFilenameFromUrl = __nested_webpack_exports__.getFilenameFromUrl;\n/******/ var __webpack_exports__getPdfFilenameFromUrl = __nested_webpack_exports__.getPdfFilenameFromUrl;\n/******/ var __webpack_exports__getXfaPageViewport = __nested_webpack_exports__.getXfaPageViewport;\n/******/ var __webpack_exports__isDataScheme = __nested_webpack_exports__.isDataScheme;\n/******/ var __webpack_exports__isPdfFile = __nested_webpack_exports__.isPdfFile;\n/******/ var __webpack_exports__noContextMenu = __nested_webpack_exports__.noContextMenu;\n/******/ var __webpack_exports__normalizeUnicode = __nested_webpack_exports__.normalizeUnicode;\n/******/ var __webpack_exports__renderTextLayer = __nested_webpack_exports__.renderTextLayer;\n/******/ var __webpack_exports__setLayerDimensions = __nested_webpack_exports__.setLayerDimensions;\n/******/ var __webpack_exports__shadow = __nested_webpack_exports__.shadow;\n/******/ var __webpack_exports__updateTextLayer = __nested_webpack_exports__.updateTextLayer;\n/******/ var __webpack_exports__version = __nested_webpack_exports__.version;\n/******/  /******/  //# sourceMappingURL=pdf.mjs.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQsTUFBTSxHQUFHLElBQUlBLHNCQUF1QjtJQUVwQyxHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ0MscUNBQXFDQywwQkFBbUJBLEVBQUVDLDhCQUFtQkE7UUFHckYsVUFBVTtRQUNWQSw4QkFBbUJBLENBQUNDLENBQUMsQ0FBQ0YsMEJBQW1CQSxFQUFFO1lBQ3pDRyxpQkFBaUIsSUFBTyxXQUFXLEdBQUdBO1lBQ3RDQywyQkFBMkIsSUFBTyxXQUFXLEdBQUdBO1lBQ2hEQyxzQkFBc0IsSUFBTyxXQUFXLEdBQUdBO1lBQzNDQyx3QkFBd0IsSUFBTyxXQUFXLEdBQUdBO1FBQy9DO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUlDLE9BQU9OLDhCQUFtQkEsQ0FBQztRQUMvQixrREFBa0Q7UUFDbEQsSUFBSU8sZ0JBQWdCUCw4QkFBbUJBLENBQUM7UUFDeEMsdURBQXVEO1FBQ3ZELElBQUlRLHFCQUFxQlIsOEJBQW1CQSxDQUFDO1VBQzVDLHVEQUF1RDtRQUN4RCxTQUFTUyxjQUFjQyxDQUFDO1lBQ3RCLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtHLEdBQUcsQ0FBQyxHQUFHSixNQUFNLEtBQUtLLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztRQUNoRjtRQUNBLFNBQVNDLGNBQWNDLENBQUM7WUFDdEIsT0FBT1AsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtHLEdBQUcsQ0FBQyxLQUFLLE1BQU1JO1FBQ3pDO1FBQ0EsTUFBTUM7WUFDSixPQUFPQyxPQUFPLENBQUNDLEdBQUdDLEdBQUdDLEdBQUdDLEVBQUUsRUFBRTtnQkFDMUIsT0FBTztvQkFBQztvQkFB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aXFGLHdDQUF3Q3Z3RywwQkFBbUJBLENBQUMraEIsa0JBQWtCO0FBQzNGLE1BQU0sR0FBRyxJQUFJeXVGLDJDQUEyQ3h3RywwQkFBbUJBLENBQUNtdkQscUJBQXFCO0FBQ2pHLE1BQU0sR0FBRyxJQUFJc2hELHdDQUF3Q3p3RywwQkFBbUJBLENBQUNxdkQsa0JBQWtCO0FBQzNGLE1BQU0sR0FBRyxJQUFJcWhELGtDQUFrQzF3RywwQkFBbUJBLENBQUMycEIsWUFBWTtBQUMvRSxNQUFNLEdBQUcsSUFBSWduRiwrQkFBK0Izd0csMEJBQW1CQSxDQUFDc3ZELFNBQVM7QUFDekUsTUFBTSxHQUFHLElBQUlzaEQsbUNBQW1DNXdHLDBCQUFtQkEsQ0FBQ3V2RCxhQUFhO0FBQ2pGLE1BQU0sR0FBRyxJQUFJc2hELHNDQUFzQzd3RywwQkFBbUJBLENBQUM0OUYsZ0JBQWdCO0FBQ3ZGLE1BQU0sR0FBRyxJQUFJa1QscUNBQXFDOXdHLDBCQUFtQkEsQ0FBQ3cyRixlQUFlO0FBQ3JGLE1BQU0sR0FBRyxJQUFJdWEsd0NBQXdDL3dHLDBCQUFtQkEsQ0FBQzZpQixrQkFBa0I7QUFDM0YsTUFBTSxHQUFHLElBQUltdUYsNEJBQTRCaHhHLDBCQUFtQkEsQ0FBQzhMLE1BQU07QUFDbkUsTUFBTSxHQUFHLElBQUltbEcscUNBQXFDanhHLDBCQUFtQkEsQ0FBQ3kyRixlQUFlO0FBQ3JGLE1BQU0sR0FBRyxJQUFJeWEsNkJBQTZCbHhHLDBCQUFtQkEsQ0FBQ3VtQixPQUFPO0FBQ3JFLE1BQU0sR0FBKzhFLENBQ3I5RSxNQUFNLElBRU4sZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmJ5LXNrdS1zZXR1cC1wb3J0YWwvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzPzgzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMyBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqKioqKi8gdmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA2NDA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgQW5ub3RhdGlvbkxheWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0aW9uTGF5ZXIpLFxuICBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KSxcbiAgSW5rQW5ub3RhdGlvbkVsZW1lbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElua0Fubm90YXRpb25FbGVtZW50KSxcbiAgU3RhbXBBbm5vdGF0aW9uRWxlbWVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3RhbXBBbm5vdGF0aW9uRWxlbWVudClcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NoYXJlZC91dGlsLmpzXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG52YXIgZGlzcGxheV91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDczKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX3N0b3JhZ2UuanNcbnZhciBhbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4MCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2hhcmVkL3NjcmlwdGluZ191dGlscy5qc1xuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDEgLSBNYXRoLm1pbigxLCAwLjMgKiBjICsgMC41OSAqIG0gKyAwLjExICogeSArIGspXTtcbiAgfVxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuICBzdGF0aWMgR19SR0IoW2ddKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCBnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19yZ2IoW2ddKSB7XG4gICAgZyA9IHNjYWxlQW5kQ2xhbXAoZyk7XG4gICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19IVE1MKFtnXSkge1xuICAgIGNvbnN0IEcgPSBtYWtlQ29sb3JDb21wKGcpO1xuICAgIHJldHVybiBgIyR7R30ke0d9JHtHfWA7XG4gIH1cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuICBzdGF0aWMgUkdCX3JnYihjb2xvcikge1xuICAgIHJldHVybiBjb2xvci5tYXAoc2NhbGVBbmRDbGFtcCk7XG4gIH1cbiAgc3RhdGljIFJHQl9IVE1MKGNvbG9yKSB7XG4gICAgcmV0dXJuIGAjJHtjb2xvci5tYXAobWFrZUNvbG9yQ29tcCkuam9pbihcIlwiKX1gO1xuICB9XG4gIHN0YXRpYyBUX0hUTUwoKSB7XG4gICAgcmV0dXJuIFwiIzAwMDAwMDAwXCI7XG4gIH1cbiAgc3RhdGljIFRfcmdiKCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH1cbiAgc3RhdGljIENNWUtfUkdCKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIENNWUtfcmdiKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgYyArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgbSArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgeSArIGspKV07XG4gIH1cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG4gIHN0YXRpYyBSR0JfQ01ZSyhbciwgZywgYl0pIHtcbiAgICBjb25zdCBjID0gMSAtIHI7XG4gICAgY29uc3QgbSA9IDEgLSBnO1xuICAgIGNvbnN0IHkgPSAxIC0gYjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgYywgbSwgeSwga107XG4gIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L3hmYV9sYXllci5qc1xudmFyIHhmYV9sYXllciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanNcblxuXG5cblxuXG5jb25zdCBERUZBVUxUX1RBQl9JTkRFWCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDk7XG5jb25zdCBHZXRFbGVtZW50c0J5TmFtZVNldCA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBnZXRSZWN0RGltcyhyZWN0KSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgfTtcbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkJ0blwiOlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGF0YS5yYWRpb0J1dHRvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZGF0YS5jaGVja0JveCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIlNpZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHtcbiAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICBpZ25vcmVCb3JkZXIgPSBmYWxzZSxcbiAgICBjcmVhdGVRdWFkcmlsYXRlcmFscyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlciA9IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gcGFyYW1ldGVycy5pbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9oYXNQb3B1cERhdGEoe1xuICAgIHRpdGxlT2JqLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICByZXR1cm4gISEodGl0bGVPYmo/LnN0ciB8fCBjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4Kys7XG4gICAgaWYgKHRoaXMuZGF0YS5wb3B1cFJlZikge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJkaWFsb2dcIik7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3QgcmVjdCA9IHV0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHt3aWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke2hlaWdodH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgICgwLHV0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgKDAsdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJDb2xvciA9IHV0aWwuVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHsxMDAgKiAocmVjdFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGF0YS5oYXNPd25DYW52YXMgfHwgcm90YXRpb24gPT09IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXModGhpcy5kYXRhLnJlY3QpO1xuICAgIGxldCBlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKGFuZ2xlICUgMTgwID09PSAwKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiBoZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogd2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKDAsdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0O1xuICAgIGlmIChxdWFkUG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgWywge1xuICAgICAgICB4OiB0clgsXG4gICAgICAgIHk6IHRyWVxuICAgICAgfSwge1xuICAgICAgICB4OiBibFgsXG4gICAgICAgIHk6IGJsWVxuICAgICAgfV0gPSBxdWFkUG9pbnRzWzBdO1xuICAgICAgaWYgKHJlY3RUclggPT09IHRyWCAmJiByZWN0VHJZID09PSB0clkgJiYgcmVjdEJsWCA9PT0gYmxYICYmIHJlY3RCbFkgPT09IGJsWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuY29udGFpbmVyO1xuICAgIGxldCBzdmdCdWZmZXI7XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBib3JkZXJDb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGhcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIHN2Z0J1ZmZlciA9IFtcInVybCgnZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIsIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcImAsIGAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDEgMVwiPmAsIGA8ZyBmaWxsPVwidHJhbnNwYXJlbnRcIiBzdHJva2U9XCIke2JvcmRlckNvbG9yfVwiIHN0cm9rZS13aWR0aD1cIiR7Ym9yZGVyV2lkdGh9XCI+YF07XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzQm9yZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IHJlY3RUclggLSByZWN0QmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlY3RUclkgLSByZWN0QmxZO1xuICAgIGNvbnN0IHtcbiAgICAgIHN2Z0ZhY3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIik7XG4gICAgc3ZnLmNsYXNzTGlzdC5hZGQoXCJxdWFkcmlsYXRlcmFsc0NvbnRhaW5lclwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGNvbnN0IFssIHtcbiAgICAgIHg6IHRyWCxcbiAgICAgIHk6IHRyWVxuICAgIH0sIHtcbiAgICAgIHg6IGJsWCxcbiAgICAgIHk6IGJsWVxuICAgIH1dIG9mIHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgY29uc3QgeCA9IChibFggLSByZWN0QmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgeSA9IChyZWN0VHJZIC0gdHJZKSAvIGhlaWdodDtcbiAgICAgIGNvbnN0IHJlY3RXaWR0aCA9ICh0clggLSBibFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCByZWN0SGVpZ2h0ID0gKHRyWSAtIGJsWSkgLyBoZWlnaHQ7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJlY3RXaWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCByZWN0SGVpZ2h0KTtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChyZWN0KTtcbiAgICAgIHN2Z0J1ZmZlcj8ucHVzaChgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIiR7cmVjdFdpZHRofVwiIGhlaWdodD1cIiR7cmVjdEhlaWdodH1cIi8+YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIHN2Z0J1ZmZlci5wdXNoKGA8L2c+PC9zdmc+JylgKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHN2Z0J1ZmZlci5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5jbGlwUGF0aCA9IGB1cmwoIyR7aWR9KWA7XG4gIH1cbiAgX2NyZWF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcImRpYWxvZ1wiKTtcbiAgICBjb25zdCBwb3B1cCA9IG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlT2JqOiBkYXRhLnRpdGxlT2JqLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAoMCx1dGlsLndhcm4pKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIGdldCBfaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy4jYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50LCBkYXRhLmF0dGFjaG1lbnREZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgKDAsdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgKDAsdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXRleHQtYW5ub3RhdGlvbi10eXBlXCIpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSkpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgdGhpcy5jb250YWluZXIudGl0bGUgPSB0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIHV0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNNYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IHV0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKHV0aWwuTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIHV0aWwuTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gdXRpbC5MSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHV0aWwuVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc3BsYXlWYWx1ZTogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29uc3QgcG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudElkcy5wdXNoKGVsZW1lbnQuZGF0YS5pZCk7XG4gICAgICBlbGVtZW50LmFkZEhpZ2hsaWdodEFyZWEoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLm1hcChpZCA9PiBgJHt1dGlsLkFubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNkYXRlT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN3YXNWaXNpYmxlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW5cbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN0aXRsZU9iaiA9IHRpdGxlT2JqO1xuICAgIHRoaXMuI2NvbnRlbnRzT2JqID0gY29udGVudHNPYmo7XG4gICAgdGhpcy4jcmljaFRleHQgPSByaWNoVGV4dDtcbiAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy4jY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLiNyZWN0ID0gcmVjdDtcbiAgICB0aGlzLiNwYXJlbnRSZWN0ID0gcGFyZW50UmVjdDtcbiAgICB0aGlzLiNlbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMuI2RhdGVPYmogPSBkaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3cpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuI3BhcmVudDtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgaWYgKHRoaXMuI2NvbG9yKSB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBwb3B1cC5zdHlsZS5vdXRsaW5lQ29sb3IgPSB1dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yKTtcbiAgICAgIGlmIChDU1Muc3VwcG9ydHMoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiY29sb3ItbWl4KGluIHNyZ2IsIHJlZCAzMCUsIHdoaXRlKVwiKSkge1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBCQUNLR1JPVU5EX0VOTElHSFQgPSAwLjc7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHV0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IubWFwKGMgPT4gTWF0aC5mbG9vcihCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gYykgKyBjKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZU9iaikge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc0xpc3QuYWRkKFwicG9wdXBEYXRlXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1hbm5vdGF0aW9uLWRhdGUtc3RyaW5nXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGU6IHRoaXMuI2RhdGVPYmoudG9Mb2NhbGVEYXRlU3RyaW5nKCksXG4gICAgICAgIHRpbWU6IHRoaXMuI2RhdGVPYmoudG9Mb2NhbGVUaW1lU3RyaW5nKClcbiAgICAgIH0pKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBpZiAocmljaFRleHQ/LnN0ciAmJiAoIWNvbnRlbnRzT2JqPy5zdHIgfHwgY29udGVudHNPYmouc3RyID09PSByaWNoVGV4dC5zdHIpKSB7XG4gICAgICB4ZmFfbGF5ZXIuWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgICAgeGZhSHRtbDogcmljaFRleHQuaHRtbCxcbiAgICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCIsXG4gICAgICAgIGRpdjogcG9wdXBcbiAgICAgIH0pO1xuICAgICAgcG9wdXAubGFzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJyaWNoVGV4dFwiLCBcInBvcHVwQ29udGVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyhjb250ZW50c09iaik7XG4gICAgICBwb3B1cC5hcHBlbmQoY29udGVudHMpO1xuICAgIH1cbiAgICBsZXQgdXNlUGFyZW50UmVjdCA9ICEhdGhpcy4jcGFyZW50UmVjdDtcbiAgICBsZXQgcmVjdCA9IHVzZVBhcmVudFJlY3QgPyB0aGlzLiNwYXJlbnRSZWN0IDogdGhpcy4jcmVjdDtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGlmICghcmVjdCB8fCB1dGlsLlV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSB1dGlsLlV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChwb3B1cCk7XG4gIH1cbiAgX2Zvcm1hdENvbnRlbnRzKHtcbiAgICBzdHIsXG4gICAgZGlyXG4gIH0pIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5jbGFzc0xpc3QuYWRkKFwicG9wdXBDb250ZW50XCIpO1xuICAgIHAuZGlyID0gZGlyO1xuICAgIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICAja2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0IF9pc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaGFzT3duQ2FudmFzO1xuICB9XG59XG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGluZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy4jY2lyY2xlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZWxsaXBzZVwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgaGVpZ2h0IC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ4XCIsIHdpZHRoIC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChjaXJjbGUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NpcmNsZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgZm9yIChjb25zdCBjb29yZGluYXRlIG9mIGRhdGEudmVydGljZXMpIHtcbiAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gZGF0YS5yZWN0WzNdIC0gY29vcmRpbmF0ZS55O1xuICAgICAgcG9pbnRzLnB1c2goeCArIFwiLFwiICsgeSk7XG4gICAgfVxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuI3BvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmVzID0gW107XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGRhdGEuaW5rTGlzdHMpIHtcbiAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBpbmtMaXN0KSB7XG4gICAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLiNwb2x5bGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICAgIH1cbiAgICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9ID0gdGhpcy5kYXRhLmZpbGU7XG4gICAgdGhpcy5maWxlbmFtZSA9ICgwLGRpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsKShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyaWdnZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICAjZG93bmxvYWQoKSB7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGw7XG4gICNlZGl0YWJsZUFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgcGFnZSxcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gIH1cbiAgI2FwcGVuZEVsZW1lbnQoZWxlbWVudCwgaWQpIHtcbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZCB8fCBlbGVtZW50O1xuICAgIGNvbnRlbnRFbGVtZW50LmlkID0gYCR7dXRpbC5Bbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgICgwLGRpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBkaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwYXJhbXMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IGFubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSB1dGlsLkFubm90YXRpb25UeXBlLlBPUFVQO1xuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hbm5vdGF0aW9uRWRpdG9yVHlwZSA+IDApIHtcbiAgICAgICAgdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zZXQoZWxlbWVudC5kYXRhLmlkLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBmaXJzdENoaWxkXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGlmICghZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoaWxkLm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZVdpdGgoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0aW9uU3RvcmFnZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGlvblN0b3JhZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQcmludEFubm90YXRpb25TdG9yYWdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBQcmludEFubm90YXRpb25TdG9yYWdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VyaWFsaXphYmxlRW1wdHk6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlcmlhbGl6YWJsZUVtcHR5KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VkaXRvcl9lZGl0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2hhcmVkX211cm11cmhhc2gzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyNSk7XG5cblxuXG5jb25zdCBTZXJpYWxpemFibGVFbXB0eSA9IE9iamVjdC5mcmVlemUoe1xuICBtYXA6IG51bGwsXG4gIGhhc2g6IFwiXCIsXG4gIHRyYW5zZmVyOiB1bmRlZmluZWRcbn0pO1xuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjbW9kaWZpZWQgPSBmYWxzZTtcbiAgI3N0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub25TZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vblJlc2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID0gbnVsbDtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9lZGl0b3JfZWRpdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yX2VkaXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkFubm90YXRpb25FZGl0b3IgJiYgdHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplID4gMCA/ICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9iamVjdEZyb21NYXApKHRoaXMuI3N0b3JhZ2UpIDogbnVsbDtcbiAgfVxuICBzZXRBbGwob2JqKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IF9zaGFyZWRfbXVybXVyaGFzaDNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5NdXJtdXJIYXNoM182NCgpLFxuICAgICAgdHJhbnNmZXIgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaGFzQml0bWFwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBfZWRpdG9yX2VkaXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6YWJsZTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDY6XG4vKioqLyAoKF9fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmEoX193ZWJwYWNrX21vZHVsZV9fLCBhc3luYyAoX193ZWJwYWNrX2hhbmRsZV9hc3luY19kZXBlbmRlbmNpZXNfXywgX193ZWJwYWNrX2FzeW5jX3Jlc3VsdF9fKSA9PiB7IHRyeSB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFBERkRhdGFSYW5nZVRyYW5zcG9ydCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBERldvcmtlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUERGV29ya2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYnVpbGQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGJ1aWxkKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0RG9jdW1lbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldERvY3VtZW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdmVyc2lvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmVyc2lvbilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0cyBEZWZhdWx0Q2FudmFzRmFjdG9yeSwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5LCBEZWZhdWx0RmlsdGVyRmFjdG9yeSwgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5LCBMb29wYmFja1BvcnQsIFBERkRvY3VtZW50TG9hZGluZ1Rhc2ssIFBERkRvY3VtZW50UHJveHksIFBERlBhZ2VQcm94eSwgUERGV29ya2VyVXRpbCwgUmVuZGVyVGFzayAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb250X2xvYWRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGRpc3BsYXlfbm9kZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MzgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jYW52YXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd29ya2VyX29wdGlvbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzY4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2hhcmVkX21lc3NhZ2VfaGFuZGxlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXRhZGF0YV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcHRpb25hbF9jb250ZW50X2NvbmZpZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfc3RyZWFtX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZGlzcGxheV9mZXRjaF9zdHJlYW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZGlzcGxheV9uZXR3b3JrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGRpc3BsYXlfbm9kZV9zdHJlYW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5OCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3hmYV90ZXh0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjEpO1xudmFyIF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXyA9IF9fd2VicGFja19oYW5kbGVfYXN5bmNfZGVwZW5kZW5jaWVzX18oW2Rpc3BsYXlfbm9kZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLCBkaXNwbGF5X25vZGVfc3RyZWFtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fXSk7XG4oW2Rpc3BsYXlfbm9kZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLCBkaXNwbGF5X25vZGVfc3RyZWFtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fXSA9IF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXy50aGVuID8gKGF3YWl0IF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXykoKSA6IF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXyk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmNvbnN0IERFTEFZRURfQ0xFQU5VUF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNOb2RlSlMgPyBkaXNwbGF5X25vZGVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5Ob2RlQ2FudmFzRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRE9NQ2FudmFzRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzTm9kZUpTID8gZGlzcGxheV9ub2RlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5ET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNOb2RlSlMgPyBkaXNwbGF5X25vZGVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5Ob2RlRmlsdGVyRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRE9NRmlsdGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzTm9kZUpTID8gZGlzcGxheV9ub2RlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNBcnJheUJ1ZmZlcikoc3JjKSkge1xuICAgIHNyYyA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBpbiBnZXREb2N1bWVudCwgbmVlZCBwYXJhbWV0ZXIgb2JqZWN0LlwiKTtcbiAgfVxuICBpZiAoIXNyYy51cmwgJiYgIXNyYy5kYXRhICYmICFzcmMucmFuZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBvYmplY3Q6IG5lZWQgZWl0aGVyIC5kYXRhLCAucmFuZ2Ugb3IgLnVybFwiKTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhKDAsX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5pc0RhdGFTY2hlbWUpKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc05vZGVKUztcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogQ01hcFJlYWRlckZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmICgwLF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uaXNWYWxpZEZldGNoVXJsKShjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiAoMCxfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmlzVmFsaWRGZXRjaFVybCkoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSBzcmMuY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IGZpbHRlckZhY3RvcnkgPSBzcmMuZmlsdGVyRmFjdG9yeSB8fCBuZXcgRGVmYXVsdEZpbHRlckZhY3Rvcnkoe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNldFZlcmJvc2l0eUxldmVsKSh2ZXJib3NpdHkpO1xuICBjb25zdCB0cmFuc3BvcnRGYWN0b3J5ID0ge1xuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeVxuICB9O1xuICBpZiAoIXVzZVdvcmtlckZldGNoKSB7XG4gICAgdHJhbnNwb3J0RmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeSA9IG5ldyBDTWFwUmVhZGVyRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBjTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBjTWFwUGFja2VkXG4gICAgfSk7XG4gICAgdHJhbnNwb3J0RmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IG5ldyBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBzdGFuZGFyZEZvbnREYXRhVXJsXG4gICAgfSk7XG4gIH1cbiAgaWYgKCF3b3JrZXIpIHtcbiAgICBjb25zdCB3b3JrZXJQYXJhbXMgPSB7XG4gICAgICB2ZXJib3NpdHksXG4gICAgICBwb3J0OiBfd29ya2VyX29wdGlvbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9O1xuICAgIHdvcmtlciA9IHdvcmtlclBhcmFtcy5wb3J0ID8gUERGV29ya2VyLmZyb21Qb3J0KHdvcmtlclBhcmFtcykgOiBuZXcgUERGV29ya2VyKHdvcmtlclBhcmFtcyk7XG4gICAgdGFzay5fd29ya2VyID0gd29ya2VyO1xuICB9XG4gIGNvbnN0IGZldGNoRG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246ICc0LjAuMzc5JyxcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGlnbm9yZUVycm9ycyxcbiAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgZW5hYmxlWGZhLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIGZldGNoRG9jUGFyYW1zKTtcbiAgICBjb25zdCBuZXR3b3JrU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcmFuZ2VUcmFuc3BvcnQuaW5pdGlhbERhdGEsXG4gICAgICAgICAgcHJvZ3Jlc3NpdmVEb25lOiByYW5nZVRyYW5zcG9ydC5wcm9ncmVzc2l2ZURvbmUsXG4gICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHJhbmdlVHJhbnNwb3J0LmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0sIHJhbmdlVHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlUERGTmV0d29ya1N0cmVhbSA9IHBhcmFtcyA9PiB7XG4gICAgICAgICAgaWYgKF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzTm9kZUpTKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRpc3BsYXlfbm9kZV9zdHJlYW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18uUERGTm9kZVN0cmVhbShwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKDAsX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5pc1ZhbGlkRmV0Y2hVcmwpKHBhcmFtcy51cmwpID8gbmV3IGRpc3BsYXlfZmV0Y2hfc3RyZWFtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fLlBERkZldGNoU3RyZWFtKHBhcmFtcykgOiBuZXcgZGlzcGxheV9uZXR3b3JrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLlBERk5ldHdvcmtTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0oe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXR3b3JrU3RyZWFtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3dvcmtlcklkUHJvbWlzZSwgbmV0d29ya1N0cmVhbVByb21pc2VdKS50aGVuKGZ1bmN0aW9uIChbd29ya2VySWQsIG5ldHdvcmtTdHJlYW1dKSB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX3NoYXJlZF9tZXNzYWdlX2hhbmRsZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5NZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSk7XG4gICAgICB0YXNrLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiUmVhZHlcIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKHRhc2suX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgcmV0dXJuIHRhc2s7XG59XG5hc3luYyBmdW5jdGlvbiBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIHNvdXJjZSkge1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICB9XG4gIGNvbnN0IHdvcmtlcklkID0gYXdhaXQgd29ya2VyLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY1JlcXVlc3RcIiwgc291cmNlLCBzb3VyY2UuZGF0YSA/IFtzb3VyY2UuZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHdvcmtlcklkO1xufVxuZnVuY3Rpb24gZ2V0VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB2YWwuaHJlZjtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHZhbCwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICBpZiAoX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNOb2RlSlMgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc3RyaW5nVG9CeXRlcykodmFsKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpIHx8ICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzQXJyYXlCdWZmZXIpKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB0aGlzLmRvY0lkID0gYGQke1BERkRvY3VtZW50TG9hZGluZ1Rhc2suI2RvY0lkKyt9YDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3kgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3k7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fd29ya2VyKSB7XG4gICAgICB0aGlzLl93b3JrZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc2hhZG93KSh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5TdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcGFnZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZGV4ICsgMTtcbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucmVmO1xuICB9XG4gIGdldCB1c2VyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udXNlclVuaXQ7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoe1xuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGUsXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIGludGVudEFyZ3MucmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGFzeW5jIGdldFhmYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhPy5jaGlsZHJlblt0aGlzLl9wYWdlSW5kZXhdIHx8IG51bGw7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIHZpZXdwb3J0LFxuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgYmFja2dyb3VuZCA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGwsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBpZiAoIW9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShpbnRlbnRBcmdzLnJlbmRlcmluZ0ludGVudCAmIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAodGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCghaW50ZW50UHJpbnQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9yc1xuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oKFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWUsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb24gPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50Lml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IHtcbiAgICAgICAgcmV0dXJuIF94ZmFfdGV4dF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXy5YZmFUZXh0LnRleHRDb250ZW50KHhmYSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMucHVzaCguLi52YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5TdGF0VGltZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgI3RyeUNsZWFudXAoZGVsYXllZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlbGF5ZWQpIHtcbiAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICAgIH0sIERFTEFZRURfQ0xFQU5VUF9USU1FT1VUKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gICNhYm9ydERlbGF5ZWRDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpO1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHk/LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgfVxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaztcbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3Quc2VwYXJhdGVBbm5vdHMgPSBvcGVyYXRvckxpc3RDaHVuay5zZXBhcmF0ZUFubm90cztcbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaykge1xuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcFxuICAgIH0sIHRyYW5zZmVyKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbikge1xuICAgICAgICBsZXQgZGVsYXkgPSBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQ7XG4gICAgICAgIGlmIChyZWFzb24uZXh0cmFEZWxheSA+IDAgJiYgcmVhc29uLmV4dHJhRGVsYXkgPCAxMDAwKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5jbGFzcyBMb29wYmFja1BvcnQge1xuICAjbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAjZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2Zlcikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXIgPyB7XG4gICAgICAgIHRyYW5zZmVyXG4gICAgICB9IDogbnVsbClcbiAgICB9O1xuICAgIHRoaXMuI2RlZmVycmVkLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuI2xpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cbmNvbnN0IFBERldvcmtlclV0aWwgPSB7XG4gIGlzV29ya2VyRGlzYWJsZWQ6IGZhbHNlLFxuICBmYWtlV29ya2VySWQ6IDBcbn07XG57XG4gIGlmIChfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc05vZGVKUykge1xuICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgX3dvcmtlcl9vcHRpb25zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICB9XG4gIFBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luID0gZnVuY3Rpb24gKGJhc2VVcmwsIG90aGVyVXJsKSB7XG4gICAgbGV0IGJhc2U7XG4gICAgdHJ5IHtcbiAgICAgIGJhc2UgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvdGhlciA9IG5ldyBVUkwob3RoZXJVcmwsIGJhc2UpO1xuICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICB9O1xuICBQREZXb3JrZXJVdGlsLmNyZWF0ZUNETldyYXBwZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGBhd2FpdCBpbXBvcnQoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0sIHtcbiAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICB9KSk7XG4gIH07XG59XG5jbGFzcyBQREZXb3JrZXIge1xuICBzdGF0aWMgI3dvcmtlclBvcnRzO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSA9IG51bGwsXG4gICAgcG9ydCA9IG51bGwsXG4gICAgdmVyYm9zaXR5ID0gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0VmVyYm9zaXR5TGV2ZWwpKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgKFBERldvcmtlci4jd29ya2VyUG9ydHMgfHw9IG5ldyBXZWFrTWFwKCkpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9zaGFyZWRfbWVzc2FnZV9oYW5kbGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgJiYgIVBERldvcmtlci4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICBsZXQge1xuICAgICAgICB3b3JrZXJTcmNcbiAgICAgIH0gPSBQREZXb3JrZXI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIVBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyVXRpbC5jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX3NoYXJlZF9tZXNzYWdlX2hhbmRsZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmluZm8pKFwiVGhlIHdvcmtlciBoYXMgYmVlbiBkaXNhYmxlZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICB9XG4gIF9zZXR1cEZha2VXb3JrZXIoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyVXRpbC5mYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBfc2hhcmVkX21lc3NhZ2VfaGFuZGxlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLk1lc3NhZ2VIYW5kbGVyKGlkICsgXCJfd29ya2VyXCIsIGlkLCBwb3J0KTtcbiAgICAgIFdvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHdvcmtlckhhbmRsZXIsIHBvcnQpO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX3NoYXJlZF9tZXNzYWdlX2hhbmRsZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5NZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgIHRoaXMuX3dlYldvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgfVxuICAgIFBERldvcmtlci4jd29ya2VyUG9ydHM/LmRlbGV0ZSh0aGlzLl9wb3J0KTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHM/LmdldChwYXJhbXMucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKF93b3JrZXJfb3B0aW9uc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyB0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsXCIsIGxvYWRlcigpKTtcbiAgfVxufVxuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnkpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IF9mb250X2xvYWRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkZvbnRMb2FkZXIoe1xuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnQsXG4gICAgICBzdHlsZUVsZW1lbnQ6IHBhcmFtcy5zdHlsZUVsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gZmFjdG9yeS5jYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZhY3RvcnkuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5ID0gZmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeTtcbiAgICB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5ID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cbiAgI2NhY2hlU2ltcGxlTWV0aG9kKG5hbWUsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5Bbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IF9hbm5vdGF0aW9uX3N0b3JhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAoYW5ub3RhdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQW5ub3RhdGlvbk1vZGUuRElTQUJMRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRElTQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25Nb2RlLkVOQUJMRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uTW9kZS5FTkFCTEVfU1RPUkFHRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfU1RPUkFHRTtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9zdG9yYWdlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy53YXJuKShgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogYCR7cmVuZGVyaW5nSW50ZW50fV8ke2Fubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2h9YCxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICBjb25zdCBoZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgY29uc3QgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCFmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZDogZnVsbFJlYWRlci5pc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgY29udGVudExlbmd0aDogZnVsbFJlYWRlci5jb250ZW50TGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiBoZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5hc3NlcnQpKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBmdW5jdGlvbiAoZXgpIHtcbiAgICAgIGxldCByZWFzb247XG4gICAgICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlBhc3N3b3JkRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5JbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5NaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoXCJEb2NFeGNlcHRpb24gLSBleHBlY3RlZCBhIHZhbGlkIEVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4Y2VwdGlvbiA9PiB7XG4gICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGlmIChsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gcGFzc3dvcmQgPT4ge1xuICAgICAgICAgIGlmIChwYXNzd29yZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KHBhc3N3b3JkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEYXRhTG9hZGVkXCIsIGRhdGEgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KGRhdGEucGFnZUluZGV4KTtcbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29tbW9uT2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHBhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IF9mb250X2xvYWRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkZvbnRGYWNlT2JqZWN0KGV4cG9ydGVkRGF0YSwge1xuICAgICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICAgICAgaWdub3JlRXJyb3JzOiBwYXJhbXMuaWdub3JlRXJyb3JzLFxuICAgICAgICAgICAgaW5zcGVjdEZvbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkZvbnRGYWxsYmFja1wiLCB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5hc3NlcnQpKGltYWdlUmVmLCBcIlRoZSBpbWFnZVJlZiBtdXN0IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFnZVByb3h5IG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkYXRhXSBvZiBwYWdlUHJveHkub2Jqcykge1xuICAgICAgICAgICAgICBpZiAoZGF0YS5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFnZVByb3h5Ll9pbnRlbnRTdGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpbWFnZURhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgaWYgKGltYWdlRGF0YT8uZGF0YUxlbiA+IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFKSB7XG4gICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaFN0YW5kYXJkRm9udERhdGFcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm9iamVjdFwiIHx8IHJlZiA9PT0gbnVsbCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYubnVtKSB8fCByZWYubnVtIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYuZ2VuKSB8fCByZWYuZ2VuIDwgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXy5PcHRpb25hbENvbnRlbnRDb25maWcocmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZm86IHJlc3VsdHNbMF0sXG4gICAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IF9tZXRhZGF0YV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLk1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gIH1cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9ID0gdGhpcy5fcGFyYW1zO1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwibG9hZGluZ1BhcmFtc1wiLCB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICNlbnN1cmVPYmoob2JqSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gfHw9IHtcbiAgICAgIGNhcGFiaWxpdHk6IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmouY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIG9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkID8/IGZhbHNlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBkYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FwYWJpbGl0eSxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5LnNldHRsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBbb2JqSWQsIGRhdGFdO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgdGhpcy5vbkNvbnRpbnVlID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhbGxiYWNrLFxuICAgIHBhcmFtcyxcbiAgICBvYmpzLFxuICAgIGNvbW1vbk9ianMsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBvcGVyYXRvckxpc3QsXG4gICAgcGFnZUluZGV4LFxuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeSxcbiAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICBwZGZCdWcgPSBmYWxzZSxcbiAgICBwYWdlQ29sb3JzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzQ29udGV4dC5jYW52YXM7XG4gIH1cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IF9jYW52YXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5DYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2s/LigpO1xuICB9XG4gIGNhbmNlbChlcnJvciA9IG51bGwsIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2Z4Py5lbmREcmF3aW5nKCk7XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yIHx8IG5ldyBfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSkpO1xuICB9XG4gIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHkpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIHx8PSB0aGlzLl9jb250aW51ZUJvdW5kO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSAnNC4wLjM3OSc7XG5jb25zdCBidWlsZCA9ICc5ZTE0ZDA0ZmQnO1xuXG5fX3dlYnBhY2tfYXN5bmNfcmVzdWx0X18oKTtcbn0gY2F0Y2goZSkgeyBfX3dlYnBhY2tfYXN5bmNfcmVzdWx0X18oZSk7IH0gfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MjI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEJhc2VDTWFwUmVhZGVyRmFjdG9yeTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZUNhbnZhc0ZhY3Rvcnk6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VDYW52YXNGYWN0b3J5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZUZpbHRlckZhY3Rvcnk6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VGaWx0ZXJGYWN0b3J5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNWR0ZhY3Rvcnk6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTVkdGYWN0b3J5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiAoKSA9PiAoLyogYmluZGluZyAqLyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUZpbHRlckZhY3RvcnkpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VGaWx0ZXJGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUNhbnZhc0ZhY3RvcnkuXCIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgICB9O1xuICB9XG4gIHJlc2V0KGNhbnZhc0FuZENvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGRlc3Ryb3koY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyA9IG51bGw7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSB0cnVlXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ01hcFJlYWRlckZhY3RvcnkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuaXNDb21wcmVzc2VkID0gaXNDb21wcmVzc2VkO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ01hcCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwiY01hcFVybFwiIGFuZCBcImNNYXBQYWNrZWRcIiBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ01hcCBuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5iYXNlVXJsICsgbmFtZSArICh0aGlzLmlzQ29tcHJlc3NlZCA/IFwiLmJjbWFwXCIgOiBcIlwiKTtcbiAgICBjb25zdCBjb21wcmVzc2lvblR5cGUgPSB0aGlzLmlzQ29tcHJlc3NlZCA/IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkNNYXBDb21wcmVzc2lvblR5cGUuQklOQVJZIDogX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQ01hcENvbXByZXNzaW9uVHlwZS5OT05FO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YW5kYXJkIGZvbnQgXCJiYXNlVXJsXCIgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCAnICsgJ3RoZSBcInN0YW5kYXJkRm9udERhdGFVcmxcIiBBUEkgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgZm9udCBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVNWR0ZhY3RvcnkpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTVkdGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlU1ZHYCBjYWxsZWQuXCIpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI1MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBDYW52YXNHcmFwaGljczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ2FudmFzR3JhcGhpY3MpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9zaGFyZWQvdXRpbC5qc1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2Rpc3BsYXkvZGlzcGxheV91dGlscy5qc1xudmFyIGRpc3BsYXlfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3Myk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGlzcGxheS9wYXR0ZXJuX2hlbHBlci5qc1xuXG5cbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU2hhZGluZ1BhdHRlcm4pIHtcbiAgICAgICgwLHV0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNoYWRpbmdQYXR0ZXJuLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gdXRpbC5VdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGxldCBzY2FsZTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIHNjYWxlID0gdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKCgwLGRpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICAgICAgc2NhbGUgPSBbc2NhbGVbMF0gKiBtYXRyaXhTY2FsZVswXSwgc2NhbGVbMV0gKiBtYXRyaXhTY2FsZVsxXV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY29sb3IsIGN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdIHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB0aGlzLmJib3ggPSBJUls0XTtcbiAgICB0aGlzLnhzdGVwID0gSVJbNV07XG4gICAgdGhpcy55c3RlcCA9IElSWzZdO1xuICAgIHRoaXMucGFpbnRUeXBlID0gSVJbN107XG4gICAgdGhpcy50aWxpbmdUeXBlID0gSVJbOF07XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gIH1cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcikge1xuICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IHRoaXMub3BlcmF0b3JMaXN0O1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmJib3g7XG4gICAgY29uc3QgeHN0ZXAgPSB0aGlzLnhzdGVwO1xuICAgIGNvbnN0IHlzdGVwID0gdGhpcy55c3RlcDtcbiAgICBjb25zdCBwYWludFR5cGUgPSB0aGlzLnBhaW50VHlwZTtcbiAgICBjb25zdCB0aWxpbmdUeXBlID0gdGhpcy50aWxpbmdUeXBlO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICAoMCx1dGlsLmluZm8pKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3QgbWF0cml4U2NhbGUgPSB1dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGN1ck1hdHJpeFNjYWxlID0gdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZSA9IFttYXRyaXhTY2FsZVswXSAqIGN1ck1hdHJpeFNjYWxlWzBdLCBtYXRyaXhTY2FsZVsxXSAqIGN1ck1hdHJpeFNjYWxlWzFdXTtcbiAgICBjb25zdCBkaW14ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeHN0ZXAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVswXSk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHlzdGVwLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWzFdKTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIGRpbXguc2l6ZSwgZGlteS5zaXplLCB0cnVlKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBncmFwaGljcyA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeS5jcmVhdGVDYW52YXNHcmFwaGljcyh0bXBDdHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICBsZXQgYWRqdXN0ZWRYMCA9IHgwO1xuICAgIGxldCBhZGp1c3RlZFkwID0geTA7XG4gICAgbGV0IGFkanVzdGVkWDEgPSB4MTtcbiAgICBsZXQgYWRqdXN0ZWRZMSA9IHkxO1xuICAgIGlmICh4MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWDAgPSAwO1xuICAgICAgYWRqdXN0ZWRYMSArPSBNYXRoLmFicyh4MCk7XG4gICAgfVxuICAgIGlmICh5MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWTAgPSAwO1xuICAgICAgYWRqdXN0ZWRZMSArPSBNYXRoLmFicyh5MCk7XG4gICAgfVxuICAgIHRtcEN0eC50cmFuc2xhdGUoLShkaW14LnNjYWxlICogYWRqdXN0ZWRYMCksIC0oZGlteS5zY2FsZSAqIGFkanVzdGVkWTApKTtcbiAgICBncmFwaGljcy50cmFuc2Zvcm0oZGlteC5zY2FsZSwgMCwgMCwgZGlteS5zY2FsZSwgMCwgMCk7XG4gICAgdG1wQ3R4LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCBhZGp1c3RlZFgwLCBhZGp1c3RlZFkwLCBhZGp1c3RlZFgxLCBhZGp1c3RlZFkxKTtcbiAgICBncmFwaGljcy5iYXNlVHJhbnNmb3JtID0gKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpO1xuICAgIGdyYXBoaWNzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICBncmFwaGljcy5lbmREcmF3aW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IGFkanVzdGVkWDAsXG4gICAgICBvZmZzZXRZOiBhZGp1c3RlZFkwXG4gICAgfTtcbiAgfVxuICBnZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgc3RlcCA9IE1hdGguYWJzKHN0ZXApO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heChUaWxpbmdQYXR0ZXJuLk1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICBsZXQgc2l6ZSA9IE1hdGguY2VpbChzdGVwICogc2NhbGUpO1xuICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgIHNpemUgPSBtYXhTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBjbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICBncmFwaGljcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpLCBbeDAsIHkwLCB4MSwgeTFdKTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSB1dGlsLlV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgdXRpbC5Gb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogJHtwYWludFR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgbWF0cml4ID0gaW52ZXJzZTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IHV0aWwuVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSB1dGlsLlV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zaGFyZWQvaW1hZ2VfdXRpbHMuanNcblxuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBJbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4zMiA9IHNyYy5sZW5ndGggPj4gMjtcbiAgY29uc3Qgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlciwgc3JjUG9zLCBsZW4zMik7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA+Pj4gMjQgfCBzMiA8PCA4IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPj4+IDE2IHwgczMgPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA+Pj4gOCB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmMubGVuZ3RoOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyYy5sZW5ndGg7IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gPDwgMjQgfCBzcmNbaiArIDFdIDw8IDE2IHwgc3JjW2ogKyAyXSA8PCA4IHwgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gZ3JheVRvUkdCQShzcmMsIGRlc3QpIHtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxIHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxMDAgfCAweDAwMDAwMGZmO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGlzcGxheS9jYW52YXMuanNcblxuXG5cblxuY29uc3QgTUlOX0ZPTlRfU0laRSA9IDE2O1xuY29uc3QgTUFYX0ZPTlRfU0laRSA9IDEwMDtcbmNvbnN0IE1BWF9HUk9VUF9TSVpFID0gNDA5NjtcbmNvbnN0IEVYRUNVVElPTl9USU1FID0gMTU7XG5jb25zdCBFWEVDVVRJT05fU1RFUFMgPSAxMDtcbmNvbnN0IE1BWF9TSVpFX1RPX0NPTVBJTEUgPSAxMDAwO1xuY29uc3QgRlVMTF9DSFVOS19IRUlHSFQgPSAxNjtcbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuICBjdHguX19vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXN0b3JlID0gY3R4LnJlc3RvcmU7XG4gIGN0eC5fX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGUgPSBjdHgudHJhbnNsYXRlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSA9IGN0eC5yZXNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxDbGlwID0gY3R4LmNsaXA7XG4gIGN0eC5fX29yaWdpbmFsTW92ZVRvID0gY3R4Lm1vdmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxMaW5lVG8gPSBjdHgubGluZVRvO1xuICBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG8gPSBjdHguYmV6aWVyQ3VydmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxSZWN0ID0gY3R4LnJlY3Q7XG4gIGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcbiAgY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGggPSBjdHguYmVnaW5QYXRoO1xuICBjdHguX3JlbW92ZU1pcnJvcmluZyA9ICgpID0+IHtcbiAgICBjdHguc2F2ZSA9IGN0eC5fX29yaWdpbmFsU2F2ZTtcbiAgICBjdHgucmVzdG9yZSA9IGN0eC5fX29yaWdpbmFsUmVzdG9yZTtcbiAgICBjdHgucm90YXRlID0gY3R4Ll9fb3JpZ2luYWxSb3RhdGU7XG4gICAgY3R4LnNjYWxlID0gY3R4Ll9fb3JpZ2luYWxTY2FsZTtcbiAgICBjdHgudHJhbnNsYXRlID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGU7XG4gICAgY3R4LnRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtO1xuICAgIGN0eC5jbGlwID0gY3R4Ll9fb3JpZ2luYWxDbGlwO1xuICAgIGN0eC5tb3ZlVG8gPSBjdHguX19vcmlnaW5hbE1vdmVUbztcbiAgICBjdHgubGluZVRvID0gY3R4Ll9fb3JpZ2luYWxMaW5lVG87XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG87XG4gICAgY3R4LnJlY3QgPSBjdHguX19vcmlnaW5hbFJlY3Q7XG4gICAgY3R4LmNsb3NlUGF0aCA9IGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoO1xuICAgIGN0eC5iZWdpblBhdGggPSBjdHguX19vcmlnaW5hbEJlZ2luUGF0aDtcbiAgICBkZWxldGUgY3R4Ll9yZW1vdmVNaXJyb3Jpbmc7XG4gIH07XG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gY3R4U2F2ZSgpIHtcbiAgICBkZXN0Q3R4LnNhdmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTYXZlKCk7XG4gIH07XG4gIGN0eC5yZXN0b3JlID0gZnVuY3Rpb24gY3R4UmVzdG9yZSgpIHtcbiAgICBkZXN0Q3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG4gIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiBjdHhUcmFuc2xhdGUoeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gY3R4U2NhbGUoeCwgeSkge1xuICAgIGRlc3RDdHguc2NhbGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2NhbGUoeCwgeSk7XG4gIH07XG4gIGN0eC50cmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsU2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhSZXNldFRyYW5zZm9ybSgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIGN0eFJvdGF0ZShhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uIGN0eFJvdGF0ZShydWxlKSB7XG4gICAgZGVzdEN0eC5jbGlwKHJ1bGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsaXAocnVsZSk7XG4gIH07XG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1vdmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgZGVzdEN0eC5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gIH07XG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgY3R4LmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmVnaW5QYXRoKCk7XG4gIH07XG59XG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9ICgwLGRpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlM0dseXBoKGltZ0RhdGEpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gaW1nRGF0YTtcbiAgaWYgKHdpZHRoID4gTUFYX1NJWkVfVE9fQ09NUElMRSB8fCBoZWlnaHQgPiBNQVhfU0laRV9UT19DT01QSUxFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCA9IDEwMDA7XG4gIGNvbnN0IFBPSU5UX1RZUEVTID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDIsIDQsIDAsIDEsIDAsIDUsIDQsIDgsIDEwLCAwLCA4LCAwLCAyLCAxLCAwXSk7XG4gIGNvbnN0IHdpZHRoMSA9IHdpZHRoICsgMTtcbiAgbGV0IHBvaW50cyA9IG5ldyBVaW50OEFycmF5KHdpZHRoMSAqIChoZWlnaHQgKyAxKSk7XG4gIGxldCBpLCBqLCBqMDtcbiAgY29uc3QgbGluZVNpemUgPSB3aWR0aCArIDcgJiB+NztcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShsaW5lU2l6ZSAqIGhlaWdodCksXG4gICAgcG9zID0gMDtcbiAgZm9yIChjb25zdCBlbGVtIG9mIGltZ0RhdGEuZGF0YSkge1xuICAgIGxldCBtYXNrID0gMTI4O1xuICAgIHdoaWxlIChtYXNrID4gMCkge1xuICAgICAgZGF0YVtwb3MrK10gPSBlbGVtICYgbWFzayA/IDAgOiAyNTU7XG4gICAgICBtYXNrID4+PSAxO1xuICAgIH1cbiAgfVxuICBsZXQgY291bnQgPSAwO1xuICBwb3MgPSAwO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzWzBdID0gMTtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2pdID0gZGF0YVtwb3NdID8gMiA6IDE7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2pdID0gMjtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaSA9IDE7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHBvcyA9IGkgKiBsaW5lU2l6ZTtcbiAgICBqMCA9IGkgKiB3aWR0aDE7XG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMF0gPSBkYXRhW3Bvc10gPyAxIDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGxldCBzdW0gPSAoZGF0YVtwb3NdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemVdID8gOCA6IDApO1xuICAgIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBzdW0gPSAoc3VtID4+IDIpICsgKGRhdGFbcG9zICsgMV0gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZSArIDFdID8gOCA6IDApO1xuICAgICAgaWYgKFBPSU5UX1RZUEVTW3N1bV0pIHtcbiAgICAgICAgcG9pbnRzW2owICsgal0gPSBQT0lOVF9UWVBFU1tzdW1dO1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgICAgcG9zKys7XG4gICAgfVxuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDIgOiA0O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHBvcyA9IGxpbmVTaXplICogKGhlaWdodCAtIDEpO1xuICBqMCA9IGkgKiB3aWR0aDE7XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajBdID0gODtcbiAgICArK2NvdW50O1xuICB9XG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyA0IDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajAgKyBqXSA9IDQ7XG4gICAgKytjb3VudDtcbiAgfVxuICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RlcHMgPSBuZXcgSW50MzJBcnJheShbMCwgd2lkdGgxLCAtMSwgMCwgLXdpZHRoMSwgMCwgMCwgMCwgMV0pO1xuICBjb25zdCBwYXRoID0gbmV3IFBhdGgyRCgpO1xuICBmb3IgKGkgPSAwOyBjb3VudCAmJiBpIDw9IGhlaWdodDsgaSsrKSB7XG4gICAgbGV0IHAgPSBpICogd2lkdGgxO1xuICAgIGNvbnN0IGVuZCA9IHAgKyB3aWR0aDtcbiAgICB3aGlsZSAocCA8IGVuZCAmJiAhcG9pbnRzW3BdKSB7XG4gICAgICBwKys7XG4gICAgfVxuICAgIGlmIChwID09PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXRoLm1vdmVUbyhwICUgd2lkdGgxLCBpKTtcbiAgICBjb25zdCBwMCA9IHA7XG4gICAgbGV0IHR5cGUgPSBwb2ludHNbcF07XG4gICAgZG8ge1xuICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW3R5cGVdO1xuICAgICAgZG8ge1xuICAgICAgICBwICs9IHN0ZXA7XG4gICAgICB9IHdoaWxlICghcG9pbnRzW3BdKTtcbiAgICAgIGNvbnN0IHBwID0gcG9pbnRzW3BdO1xuICAgICAgaWYgKHBwICE9PSA1ICYmIHBwICE9PSAxMCkge1xuICAgICAgICB0eXBlID0gcHA7XG4gICAgICAgIHBvaW50c1twXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gcHAgJiAweDMzICogdHlwZSA+PiA0O1xuICAgICAgICBwb2ludHNbcF0gJj0gdHlwZSA+PiAyIHwgdHlwZSA8PCAyO1xuICAgICAgfVxuICAgICAgcGF0aC5saW5lVG8ocCAlIHdpZHRoMSwgcCAvIHdpZHRoMSB8IDApO1xuICAgICAgaWYgKCFwb2ludHNbcF0pIHtcbiAgICAgICAgLS1jb3VudDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwMCAhPT0gcCk7XG4gICAgLS1pO1xuICB9XG4gIGRhdGEgPSBudWxsO1xuICBwb2ludHMgPSBudWxsO1xuICBjb25zdCBkcmF3T3V0bGluZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgYy5zYXZlKCk7XG4gICAgYy5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBjLnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KTtcbiAgICBjLmZpbGwocGF0aCk7XG4gICAgYy5iZWdpblBhdGgoKTtcbiAgICBjLnJlc3RvcmUoKTtcbiAgfTtcbiAgcmV0dXJuIGRyYXdPdXRsaW5lO1xufVxuY2xhc3MgQ2FudmFzRXh0cmFTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IHV0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmZXJNYXBzID0gXCJub25lXCI7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIGNsb25lLmNsaXBCb3ggPSB0aGlzLmNsaXBCb3guc2xpY2UoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgdXBkYXRlUGF0aE1pbk1heCh0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSB1dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgeCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCB5KTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgeSk7XG4gIH1cbiAgdXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIHJlY3QpIHtcbiAgICBjb25zdCBwMSA9IHV0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHJlY3Quc2xpY2UoMiksIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgcDMgPSB1dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbM11dLCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHA0ID0gdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzFdXSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIHV0aWwuVXRpbC5zY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBtaW5NYXhbMF0pO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgbWluTWF4WzFdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIG1pbk1heFsyXSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBtaW5NYXhbM10pO1xuICB9XG4gIHVwZGF0ZUN1cnZlUGF0aE1pbk1heCh0cmFuc2Zvcm0sIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluTWF4KSB7XG4gICAgY29uc3QgYm94ID0gdXRpbC5VdGlsLmJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgaWYgKG1pbk1heCkge1xuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBib3hbMF0sIGJveFsyXSk7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIGJveFswXSwgYm94WzJdKTtcbiAgICAgIG1pbk1heFsyXSA9IE1hdGgubWluKG1pbk1heFsyXSwgYm94WzFdLCBib3hbM10pO1xuICAgICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCBib3hbMV0sIGJveFszXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIGJveCk7XG4gIH1cbiAgZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IHV0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IHNjYWxlWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IHNjYWxlWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHV0aWwuVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goaW50ZXJzZWN0IHx8IFswLCAwLCAwLCAwXSk7XG4gIH1cbiAgaXNFbXB0eUNsaXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3ggPSBib3g7XG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXhYID0gMDtcbiAgICB0aGlzLm1heFkgPSAwO1xuICB9XG4gIGdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgcmV0dXJuIHV0aWwuVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKHR5cGVvZiBJbWFnZURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsLkltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKCF1dGlsLmlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gYnl0ZXNbaV07XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBieXRlc1tpIC0gM10gPSByMDtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgfSBlbHNlIGlmIChhbHBoYSA8IDI1NSkge1xuICAgICAgY29uc3QgYWxwaGFfID0gMjU1IC0gYWxwaGE7XG4gICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMV0gPSBieXRlc1tpIC0gMV0gKiBhbHBoYSArIGIwICogYWxwaGFfID4+IDg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tBbHBoYShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGNvbnN0IHNjYWxlID0gMSAvIDI1NTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICBsYXllckRhdGFbaV0gPSBsYXllckRhdGFbaV0gKiBhbHBoYSAqIHNjYWxlIHwgMDtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrTHVtaW5vc2l0eShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB5ID0gbWFza0RhdGFbaSAtIDNdICogNzcgKyBtYXNrRGF0YVtpIC0gMl0gKiAxNTIgKyBtYXNrRGF0YVtpIC0gMV0gKiAyODtcbiAgICBsYXllckRhdGFbaV0gPSB0cmFuc2Zlck1hcCA/IGxheWVyRGF0YVtpXSAqIHRyYW5zZmVyTWFwW3kgPj4gOF0gPj4gOCA6IGxheWVyRGF0YVtpXSAqIHkgPj4gMTY7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICBjb25zdCBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gIGNvbnN0IHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gIGNvbnN0IGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gIGNvbnN0IGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gIGNvbnN0IGNvbXBvc2VGbiA9IHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiID8gY29tcG9zZVNNYXNrTHVtaW5vc2l0eSA6IGNvbXBvc2VTTWFza0FscGhhO1xuICBjb25zdCBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgY29uc3QgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WCwgcm93ICsgKGxheWVyT2Zmc2V0WSAtIG1hc2tPZmZzZXRZKSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcbiAgICBjb25zdCBsYXllckRhdGEgPSBsYXllckN0eC5nZXRJbWFnZURhdGEobGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFksIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICBjb21wb3NlU01hc2tCYWNrZHJvcChtYXNrRGF0YS5kYXRhLCByMCwgZzAsIGIwKTtcbiAgICB9XG4gICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgbGF5ZXJDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgbGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFkpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIGxheWVyQm94KSB7XG4gIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgY29uc3QgbGF5ZXJXaWR0aCA9IGxheWVyQm94WzJdIC0gbGF5ZXJPZmZzZXRYO1xuICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBnZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGNvbnN0IHNjYWxlID0gdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSk7XG4gIHNjYWxlWzBdID0gTWF0aC5mcm91bmQoc2NhbGVbMF0pO1xuICBzY2FsZVsxXSA9IE1hdGguZnJvdW5kKHNjYWxlWzFdKTtcbiAgY29uc3QgYWN0dWFsU2NhbGUgPSBNYXRoLmZyb3VuZCgoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpICogZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICBpZiAoaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgfSBlbHNlIGlmIChzY2FsZVswXSA8PSBhY3R1YWxTY2FsZSB8fCBzY2FsZVsxXSA8PSBhY3R1YWxTY2FsZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuY2xhc3MgQ2FudmFzR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIGZpbHRlckZhY3RvcnksIHtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgbWFya2VkQ29udGVudFN0YWNrID0gbnVsbFxuICB9LCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldE9iamVjdChkYXRhLCBmYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi4oMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgaWYgKGZuSWQgIT09IHV0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgdGhpc1tmbklkXS5hcHBseSh0aGlzLCBhcmdzQXJyYXlbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBPYmpJZCBvZiBhcmdzQXJyYXlbaV0pIHtcbiAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IGRlcE9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IGNvbW1vbk9ianMgOiBvYmpzO1xuICAgICAgICAgIGlmICghb2Jqc1Bvb2wuaGFzKGRlcE9iaklkKSkge1xuICAgICAgICAgICAgb2Jqc1Bvb2wuZ2V0KGRlcE9iaklkLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgaWYgKGkgPT09IGFyZ3NBcnJheUxlbikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVua09wZXJhdGlvbnMgJiYgKytzdGVwcyA+IEVYRUNVVElPTl9TVEVQUykge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IHV0aWwuVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgWzEgLyB3aWR0aCwgMCwgMCwgLTEgLyBoZWlnaHQsIDAsIDBdKTtcbiAgICBtYXNrVG9DYW52YXMgPSB1dGlsLlV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gPSB1dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gdXRpbC5VdGlsLnRyYW5zZm9ybSgoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShmaWxsQ3R4KSwgWzEsIDAsIDAsIDEsIC1vZmZzZXRYLCAtb2Zmc2V0WV0pO1xuICAgIGZpbGxDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgaW52ZXJzZSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJNXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTTWFza1wiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4uKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLnN1c3BlbmRlZEN0eCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gIH1cbiAgZW5kU01hc2tNb2RlKCkge1xuICAgIGlmICghdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5kU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBub3QgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jdHguX3JlbW92ZU1pcnJvcmluZygpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICB9XG4gIGNvbXBvc2UoZGlydHlCb3gpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRpcnR5Qm94KSB7XG4gICAgICBkaXJ0eUJveCA9IFswLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUJveFswXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMF0pO1xuICAgICAgZGlydHlCb3hbMV0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzFdKTtcbiAgICAgIGRpcnR5Qm94WzJdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzJdKTtcbiAgICAgIGRpcnR5Qm94WzNdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzNdKTtcbiAgICB9XG4gICAgY29uc3Qgc21hc2sgPSB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2s7XG4gICAgY29uc3Qgc3VzcGVuZGVkQ3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgICB0aGlzLnN1c3BlbmRlZEN0eC5zYXZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gIH1cbiAgcmVzdG9yZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5zdXNwZW5kZWRDdHgucmVzdG9yZSgpO1xuICAgICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MsIG1pbk1heCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBzdGFydFgsIHN0YXJ0WTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGNvbnN0IGlzU2NhbGluZ01hdHJpeCA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0gPT09IDAgJiYgY3VycmVudFRyYW5zZm9ybVszXSA9PT0gMCB8fCBjdXJyZW50VHJhbnNmb3JtWzFdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bMl0gPT09IDA7XG4gICAgY29uc3QgbWluTWF4Rm9yQmV6aWVyID0gaXNTY2FsaW5nTWF0cml4ID8gbWluTWF4LnNsaWNlKDApIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGlpID0gb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICBjYXNlIHV0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgIGNvbnN0IHloID0geSArIGhlaWdodDtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHloKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUmVjdE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBbeCwgeSwgeHcsIHloXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdXRpbC5PUFMubGluZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHV0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHksIG1pbk1heEZvckJlemllcik7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHV0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICBjdXJyZW50LnVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIG1pbk1heEZvckJlemllcik7XG4gICAgfVxuICAgIGN1cnJlbnQuc2V0Q3VycmVudFBvaW50KHgsIHkpO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2UoY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBQYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UoZmFsc2UpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG4gIGZpbGwoY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGxldCBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGludGVyc2VjdCA9IHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCk7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgaW50ZXJzZWN0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgIGN0eC5maWxsKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZFJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aChpbnRlcnNlY3QpO1xuICAgIH1cbiAgfVxuICBlb0ZpbGwoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGwoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuZmlsbChmYWxzZSk7XG4gICAgdGhpcy5zdHJva2UoZmFsc2UpO1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgZW5kUGF0aCgpIHtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgY2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gTk9STUFMX0NMSVA7XG4gIH1cbiAgZW9DbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dCgpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IHV0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0aC50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwYXRoLngsIHBhdGgueSk7XG4gICAgICBwYXRoLmFkZFRvUGF0aChjdHgsIHBhdGguZm9udFNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQoZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgKDAsdXRpbC53YXJuKShcIkludmFsaWQgZm9udCBtYXRyaXggZm9yIGZvbnQgXCIgKyBmb250UmVmTmFtZSk7XG4gICAgfVxuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBmb250T2JqLnN5c3RlbUZvbnRJbmZvPy5jc3MgfHwgYFwiJHtuYW1lfVwiLCAke2ZvbnRPYmouZmFsbGJhY2tOYW1lfWA7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGxldCBicm93c2VyRm9udFNpemUgPSBzaXplO1xuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2l0YWxpY30gJHtib2xkfSAke2Jyb3dzZXJGb250U2l6ZX1weCAke3R5cGVmYWNlfWA7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUobW9kZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIH1cbiAgc2V0VGV4dFJpc2UocmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKCkge1xuICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICB9XG4gIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiB1dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgYWRkVG9QYXRoO1xuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgYWRkVG9QYXRoID0gZm9udC5nZXRQYXRoR2VuZXJhdG9yKHRoaXMuY29tbW9uT2JqcywgY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFRvUGF0aChjdHgsIGZvbnRTaXplKTtcbiAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IHV0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSB1dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IHV0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IHV0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBhZGRUb1BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250U3VicGl4ZWxBQUVuYWJsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDogY3R4XG4gICAgfSA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgMTAsIDEwKTtcbiAgICBjdHguc2NhbGUoMS41LCAxKTtcbiAgICBjdHguZmlsbFRleHQoXCJJXCIsIDAsIDEwKTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxMCwgMTApLmRhdGE7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2ldID4gMCAmJiBkYXRhW2ldIDwgMjU1KSB7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLHV0aWwuc2hhZG93KSh0aGlzLCBcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIGVuYWJsZWQpO1xuICB9XG4gIHNob3dUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGUzVGV4dChnbHlwaHMpO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IHV0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVyblRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBwYXR0ZXJuVHJhbnNmb3JtID0gKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiB1dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IHV0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSB1dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsVGV4dChjaGFycy5qb2luKFwiXCIpLCAwLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICogdGV4dEhTY2FsZTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCB4ID0gMCxcbiAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3RvcmVOZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgY29uc3QgYWNjZW50ID0gZ2x5cGguYWNjZW50O1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgIGNvbnN0IHZ4ID0gLShnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41KSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgc2NhbGVkWCA9IHZ4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlZFggPSB4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDIwMDAgKiBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICBpZiAoc2ltcGxlRmlsbFRleHQgJiYgIWFjY2VudCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WCA9IHNjYWxlZFggKyBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRZID0gc2NhbGVkWSAtIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC55IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgc2hvd1R5cGUzVGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IHV0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSB1dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICgwLHV0aWwud2FybikoYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IGdseXBoO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtnbHlwaC53aWR0aCwgMF0sIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSB0cmFuc2Zvcm1lZFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cbiAgc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMoeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIHRoaXMuY3R4LnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBjb2xvciA9IElSWzFdO1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IGN0eCA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IHV0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIGNvbnN0IGNvbG9yID0gdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgX2dldFBhdHRlcm4ob2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob2JqSWQpKTtcbiAgICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuc2V0KG9iaklkLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNoYWRpbmdGaWxsKG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKG9iaklkKTtcbiAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybi5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgUGF0aFR5cGUuU0hBRElORyk7XG4gICAgY29uc3QgaW52ID0gKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHV0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIGludik7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCgtMWUxMCwgLTFlMTAsIDJlMTAsIDJlMTApO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgICgwLHV0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgIHRoaXMuY3R4LnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heCgoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSwgYmJveCk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgICgwLHV0aWwuaW5mbykoXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgICgwLHV0aWwud2FybikoXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IHV0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gdXRpbC5VdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBsZXQgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgbGV0IGRyYXduSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1szXSkgLSBvZmZzZXRZLCAxKTtcbiAgICBsZXQgc2NhbGVYID0gMSxcbiAgICAgIHNjYWxlWSA9IDE7XG4gICAgaWYgKGRyYXduV2lkdGggPiBNQVhfR1JPVVBfU0laRSkge1xuICAgICAgc2NhbGVYID0gZHJhd25XaWR0aCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgZHJhd25XaWR0aCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgIH1cbiAgICBpZiAoZHJhd25IZWlnaHQgPiBNQVhfR1JPVVBfU0laRSkge1xuICAgICAgc2NhbGVZID0gZHJhd25IZWlnaHQgLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgIGRyYXduSGVpZ2h0ID0gTUFYX0dST1VQX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHN1YnR5cGU6IGdyb3VwLnNtYXNrLnN1YnR5cGUsXG4gICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgdHJhbnNmZXJNYXA6IGdyb3VwLnNtYXNrLnRyYW5zZmVyTWFwIHx8IG51bGwsXG4gICAgICAgIHN0YXJ0VHJhbnNmb3JtSW52ZXJzZTogbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN1cnJlbnRDdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgIHRoaXMuY3R4ID0gZ3JvdXBDdHg7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgY29uc3QgY3VycmVudE10eCA9ICgwLGRpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IHV0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihpZCwgcmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgsIGhhc093bkNhbnZhcykge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWN0KSAmJiByZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB1dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCkpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmlld3BvcnRTY2FsZVxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiB0aGlzLm91dHB1dFNjYWxlWCAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogdGhpcy5vdXRwdXRTY2FsZVkgKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZShjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcC5zZXQoaWQsIGNhbnZhcyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eCA9IHRoaXMuY3R4O1xuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgMCwgMCwgLXNjYWxlWSwgMCwgaGVpZ2h0ICogc2NhbGVZKTtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25DYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgfVxuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcbiAgICBpZiAoZ2x5cGgpIHtcbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkID0gY29tcGlsZVR5cGUzR2x5cGgoaW1nKTtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZChjdHgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdChpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLGRpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBtYXNrLm9mZnNldFggLSBjdXJyZW50VHJhbnNmb3JtWzRdLCBtYXNrLm9mZnNldFkgLSBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSB1dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IHV0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIHRyYW5zKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobWFzay5jYW52YXMsIHgsIHkpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3QoZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCAoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBQYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCx1dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMoY3R4KSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgIT09IFwibm9uZVwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBjdHguY2FudmFzO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIGltZ0RhdGEuYml0bWFwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWdEYXRhO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgdG1wQ3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgIHRtcEN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAoIXV0aWwuaXNOb2RlSlMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsdGVyXG4gICAgICB9ID0gY3R4O1xuICAgICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgKDAsZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCgoMCxkaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIG1hcmtQb2ludCh0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKHRhZywgcHJvcGVydGllcykge1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KCkge31cbiAgZW5kQ29tcGF0KCkge31cbiAgY29uc3VtZVBhdGgoY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9ICgwLGRpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2Uoc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsaW5lV2lkdGhcbiAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZvciAoY29uc3Qgb3AgaW4gdXRpbC5PUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVt1dGlsLk9QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERPTUNNYXBSZWFkZXJGYWN0b3J5OiAoKSA9PiAoLyogYmluZGluZyAqLyBET01DTWFwUmVhZGVyRmFjdG9yeSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERPTUNhbnZhc0ZhY3Rvcnk6ICgpID0+ICgvKiBiaW5kaW5nICovIERPTUNhbnZhc0ZhY3RvcnkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBET01GaWx0ZXJGYWN0b3J5OiAoKSA9PiAoLyogYmluZGluZyAqLyBET01GaWx0ZXJGYWN0b3J5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRE9NU1ZHRmFjdG9yeTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRE9NU1ZHRmFjdG9yeSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiAoKSA9PiAoLyogYmluZGluZyAqLyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBERkRhdGVTdHJpbmc6ICgpID0+ICgvKiBiaW5kaW5nICovIFBERkRhdGVTdHJpbmcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQYWdlVmlld3BvcnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFBhZ2VWaWV3cG9ydCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBpeGVsc1BlckluY2g6ICgpID0+ICgvKiBiaW5kaW5nICovIFBpeGVsc1BlckluY2gpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN0YXRUaW1lcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3RhdFRpbWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZmV0Y2hEYXRhOiAoKSA9PiAoLyogYmluZGluZyAqLyBmZXRjaERhdGEpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRDb2xvclZhbHVlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0Q29sb3JWYWx1ZXMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRDdXJyZW50VHJhbnNmb3JtOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRDdXJyZW50VHJhbnNmb3JtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2U6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0RmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRGaWxlbmFtZUZyb21VcmwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRQZGZGaWxlbmFtZUZyb21Vcmw6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFBkZkZpbGVuYW1lRnJvbVVybCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldFJHQjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0UkdCKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0WGZhUGFnZVZpZXdwb3J0OiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRYZmFQYWdlVmlld3BvcnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpc0RhdGFTY2hlbWU6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzRGF0YVNjaGVtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGlzUGRmRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNQZGZGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaXNWYWxpZEZldGNoVXJsOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc1ZhbGlkRmV0Y2hVcmwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBub0NvbnRleHRNZW51OiAoKSA9PiAoLyogYmluZGluZyAqLyBub0NvbnRleHRNZW51KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2V0TGF5ZXJEaW1lbnNpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXRMYXllckRpbWVuc2lvbnMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBkZXByZWNhdGVkICovXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfZmFjdG9yeV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmNsYXNzIERPTUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjX2NhY2hlO1xuICAjX2RlZnM7XG4gICNkb2NJZDtcbiAgI2RvY3VtZW50O1xuICAjaGNtRmlsdGVyO1xuICAjaGNtS2V5O1xuICAjaGNtVXJsO1xuICAjaGNtSGlnaGxpZ2h0RmlsdGVyO1xuICAjaGNtSGlnaGxpZ2h0S2V5O1xuICAjaGNtSGlnaGxpZ2h0VXJsO1xuICAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZG9jSWQsXG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBrZXk7XG4gICAgaWYgKG1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtYXBSID0gbWFwc1swXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAga2V5ID0gdGFibGVSID0gdGFibGVHID0gdGFibGVCID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWFwUiwgbWFwRywgbWFwQl0gPSBtYXBzO1xuICAgICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyQiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgICAgYnVmZmVyR1tpXSA9IG1hcEdbaV0gLyAyNTU7XG4gICAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAgdGFibGVSID0gYnVmZmVyUi5qb2luKFwiLFwiKTtcbiAgICAgIHRhYmxlRyA9IGJ1ZmZlckcuam9pbihcIixcIik7XG4gICAgICB0YWJsZUIgPSBidWZmZXJCLmpvaW4oXCIsXCIpO1xuICAgICAga2V5ID0gYCR7dGFibGVSfSR7dGFibGVHfSR7dGFibGVCfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21LZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtVXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtRmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5VdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21VcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUhpZ2hsaWdodEtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21IaWdobGlnaHRLZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2hpZ2hsaWdodF9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21IaWdobGlnaHRVcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiAodGhpcy4jaGNtVXJsIHx8IHRoaXMuI2hjbUhpZ2hsaWdodFVybCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI19kZWZzKSB7XG4gICAgICB0aGlzLiNfZGVmcy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNfY2FjaGUpIHtcbiAgICAgIHRoaXMuI19jYWNoZS5jbGVhcigpO1xuICAgICAgdGhpcy4jX2NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAgMCAwIDEgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNjcmVhdGVGaWx0ZXIoaWQpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZpbHRlclwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwic1JHQlwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIHRoaXMuI2RlZnMuYXBwZW5kKGZpbHRlcik7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICAjYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIGZ1bmMsIHRhYmxlKSB7XG4gICAgY29uc3QgZmVGdW5jID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgZnVuYyk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkaXNjcmV0ZVwiKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidGFibGVWYWx1ZXNcIiwgdGFibGUpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kKGZlRnVuYyk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihyVGFibGUsIGdUYWJsZSwgYlRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jUlwiLCByVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0dcIiwgZ1RhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNCXCIsIGJUYWJsZSk7XG4gIH1cbiAgI2dldFJHQihjb2xvcikge1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICByZXR1cm4gZ2V0UkdCKGdldENvbXB1dGVkU3R5bGUodGhpcy4jZGVmcykuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpKTtcbiAgfVxufVxuY2xhc3MgRE9NQ2FudmFzRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgdHlwZSA9IFwidGV4dFwiKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgZGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGF0YSA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkID8gXCJhcnJheWJ1ZmZlclwiIDogXCJ0ZXh0XCIpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zdHJpbmdUb0J5dGVzKShkYXRhKSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmFzZVNWR0ZhY3Rvcnkge1xuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gIH1cbn1cbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB2aWV3Qm94XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnNoYWRvdykodGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogdmlld0JveFsyXSAtIHZpZXdCb3hbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSxcbiAgICAgIHBhZ2VYOiB2aWV3Qm94WzBdLFxuICAgICAgcGFnZVk6IHZpZXdCb3hbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5VdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxufVxuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwsIG9ubHlTdHJpcFBhdGggPSBmYWxzZSkge1xuICBpZiAoIW9ubHlTdHJpcFBhdGgpIHtcbiAgICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLndhcm4pKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgcmVVUkkgPSAvXig/Oig/OlteOl0rOik/XFwvXFwvW14vXSspPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8kLztcbiAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICBjb25zdCBzcGxpdFVSSSA9IHJlVVJJLmV4ZWModXJsKTtcbiAgbGV0IHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzFdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMl0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVszXSk7XG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG4gICAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHN1Z2dlc3RlZEZpbGVuYW1lKSlbMF07XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGltZXMgPSBbXTtcbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy53YXJuKShgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy53YXJuKShgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBvdXRCdWYgPSBbXTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmFtZS5sZW5ndGgsIGxvbmdlc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgb3V0QnVmLnB1c2goYCR7bmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZW5kIC0gc3RhcnR9bXNcXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBiYXNlVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvdG9jb2xcbiAgICB9ID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gcHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBub0NvbnRleHRNZW51KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5sZXQgcGRmRGF0ZVN0cmluZ1JlZ2V4O1xuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBkZkRhdGVTdHJpbmdSZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBkZkRhdGVTdHJpbmdSZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG4gICAgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgfSBlbHNlIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiK1wiKSB7XG4gICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0WGZhUGFnZVZpZXdwb3J0KHhmYVBhZ2UsIHtcbiAgc2NhbGUgPSAxLFxuICByb3RhdGlvbiA9IDBcbn0pIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0geGZhUGFnZS5hdHRyaWJ1dGVzLnN0eWxlO1xuICBjb25zdCB2aWV3Qm94ID0gWzAsIDAsIHBhcnNlSW50KHdpZHRoKSwgcGFyc2VJbnQoaGVpZ2h0KV07XG4gIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UkdCKGNvbG9yKSB7XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGNvbnN0IGNvbG9yUkdCID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KTtcbiAgICByZXR1cm4gWyhjb2xvclJHQiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGNvbG9yUkdCICYgMHgwMGZmMDApID4+IDgsIGNvbG9yUkdCICYgMHgwMDAwZmZdO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg0LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDUsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpLnNsaWNlKDAsIDMpO1xuICB9XG4gICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLndhcm4pKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmQoc3Bhbik7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBjb2xvcnMua2V5cygpKSB7XG4gICAgc3Bhbi5zdHlsZS5jb2xvciA9IG5hbWU7XG4gICAgY29uc3QgY29tcHV0ZWRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmNvbG9yO1xuICAgIGNvbG9ycy5zZXQobmFtZSwgZ2V0UkdCKGNvbXB1dGVkQ29sb3IpKTtcbiAgfVxuICBzcGFuLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gc2V0TGF5ZXJEaW1lbnNpb25zKGRpdiwgdmlld3BvcnQsIG11c3RGbGlwID0gZmFsc2UsIG11c3RSb3RhdGUgPSB0cnVlKSB7XG4gIGlmICh2aWV3cG9ydCBpbnN0YW5jZW9mIFBhZ2VWaWV3cG9ydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgY29uc3QgdXNlUm91bmQgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZCgke3d9LCAxcHgpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKCR7aH0sIDFweClgIDogYGNhbGMoJHtofSlgO1xuICAgIGlmICghbXVzdEZsaXAgfHwgdmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gaGVpZ2h0U3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gd2lkdGhTdHI7XG4gICAgfVxuICB9XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCB2aWV3cG9ydC5yb3RhdGlvbik7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBEcmF3TGF5ZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIERyYXdMYXllcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG5cblxuY2xhc3MgRHJhd0xheWVyIHtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNpZCA9IDA7XG4gICNtYXBwaW5nID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFnZUluZGV4XG4gIH0pIHtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLiNwYXJlbnQpIHtcbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jbWFwcGluZy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zdmdGYWN0b3J5KCkge1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zaGFkb3cpKHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRE9NU1ZHRmFjdG9yeSgpKTtcbiAgfVxuICBzdGF0aWMgI3NldEJveChlbGVtZW50LCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoYm94KSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgRHJhd0xheWVyLiNzZXRCb3goc3ZnLCBib3gpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgaGlnaGxpZ2h0KHtcbiAgICBvdXRsaW5lcyxcbiAgICBib3hcbiAgfSwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRyhib3gpO1xuICAgIHJvb3QuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodFwiKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIERyYXdMYXllci4jZXh0cmFjdFBhdGhGcm9tSGlnaGxpZ2h0T3V0bGluZXMob3V0bGluZXMpKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBgY2xpcF8ke3BhdGhJZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGNsaXBQYXRoSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBjb25zdCBjbGlwUGF0aFVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwUGF0aFVzZSk7XG4gICAgY2xpcFBhdGhVc2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGNsaXBQYXRoVXNlLmNsYXNzTGlzdC5hZGQoXCJjbGlwXCIpO1xuICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZSk7XG4gICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGNvbG9yKTtcbiAgICByb290LnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBvcGFjaXR5KTtcbiAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBjbGlwUGF0aElkOiBgdXJsKCMke2NsaXBQYXRoSWR9KWBcbiAgICB9O1xuICB9XG4gIGhpZ2hsaWdodE91dGxpbmUoe1xuICAgIG91dGxpbmVzLFxuICAgIGJveFxuICB9KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoYm94KTtcbiAgICByb290LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRPdXRsaW5lXCIpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgRHJhd0xheWVyLiNleHRyYWN0UGF0aEZyb21IaWdobGlnaHRPdXRsaW5lcyhvdXRsaW5lcykpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBjb25zdCB1c2UxID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlMSk7XG4gICAgdXNlMS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgY29uc3QgdXNlMiA9IHVzZTEuY2xvbmVOb2RlKCk7XG4gICAgcm9vdC5hcHBlbmQodXNlMik7XG4gICAgdXNlMS5jbGFzc0xpc3QuYWRkKFwibWFpbk91dGxpbmVcIik7XG4gICAgdXNlMi5jbGFzc0xpc3QuYWRkKFwic2Vjb25kYXJ5T3V0bGluZVwiKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHN0YXRpYyAjZXh0cmFjdFBhdGhGcm9tSGlnaGxpZ2h0T3V0bGluZXMocG9seWdvbnMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgcG9seWdvbnMpIHtcbiAgICAgIGxldCBbcHJldlgsIHByZXZZXSA9IHBvbHlnb247XG4gICAgICBidWZmZXIucHVzaChgTSR7cHJldlh9ICR7cHJldll9YCk7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeCA9IHBvbHlnb25baV07XG4gICAgICAgIGNvbnN0IHkgPSBwb2x5Z29uW2kgKyAxXTtcbiAgICAgICAgaWYgKHggPT09IHByZXZYKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goYFYke3l9YCk7XG4gICAgICAgICAgcHJldlkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKHkgPT09IHByZXZZKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goYEgke3h9YCk7XG4gICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgdXBkYXRlQm94KGlkLCBib3gpIHtcbiAgICBEcmF3TGF5ZXIuI3NldEJveCh0aGlzLiNtYXBwaW5nLmdldChpZCksIGJveCk7XG4gIH1cbiAgcm90YXRlKGlkLCBhbmdsZSkge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgYW5nbGUpO1xuICB9XG4gIGNoYW5nZUNvbG9yKGlkLCBjb2xvcikge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGNvbG9yKTtcbiAgfVxuICBjaGFuZ2VPcGFjaXR5KGlkLCBvcGFjaXR5KSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBvcGFjaXR5KTtcbiAgfVxuICBhZGRDbGFzcyhpZCwgY2xhc3NOYW1lKSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfVxuICByZW1vdmVDbGFzcyhpZCwgY2xhc3NOYW1lKSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICBpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5yZW1vdmUoKTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICByb290LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmNsZWFyKCk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjI5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEFubm90YXRpb25FZGl0b3JMYXllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGlvbkVkaXRvckxheWVyKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2hhcmVkL3V0aWwuanNcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2VkaXRvci9lZGl0b3IuanMgKyAyIG1vZHVsZXNcbnZhciBlZGl0b3JfZWRpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xudmFyIHRvb2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanMgKyAxIG1vZHVsZXNcbnZhciBhbm5vdGF0aW9uX2xheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDApO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2ZyZWV0ZXh0LmpzXG5cblxuXG5cbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgZWRpdG9yX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JvdW5kRWRpdG9yRGl2Qmx1ciA9IHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZGb2N1cyA9IHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2SW5wdXQgPSB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdktleWRvd24gPSB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKTtcbiAgI2NvbG9yO1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNmb250U2l6ZTtcbiAgI2luaXRpYWxEYXRhID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiAoMCx1dGlsLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyB0b29scy5LZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNjb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB7XG4gICAgICBzdHJpbmdzOiBbXCJwZGZqcy1mcmVlLXRleHQtZGVmYXVsdC1jb250ZW50XCJdXG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1t1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy4jY29sb3JdXTtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRGb250c2l6ZShmb250U2l6ZSk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRGb250c2l6ZShzYXZlZEZvbnRzaXplKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcih1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUKTtcbiAgICBzdXBlci5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2S2V5ZG93bik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Rm9jdXMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Qmx1cik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2SW5wdXQpO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEVkaXRvckRpdktleWRvd24pO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEVkaXRvckRpdkZvY3VzKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEVkaXRvckRpdkJsdXIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLiNib3VuZEVkaXRvckRpdklucHV0KTtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgdGhpcy4jY2hlYXRJbml0aWFsUmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICAjZXh0cmFjdFRleHQoKSB7XG4gICAgY29uc3QgZGl2cyA9IHRoaXMuZWRpdG9yRGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpO1xuICAgIGlmIChkaXZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBkaXYgb2YgZGl2cykge1xuICAgICAgYnVmZmVyLnB1c2goZGl2LmlubmVyVGV4dC5yZXBsYWNlKC9cXHJcXG4/fFxcbi8sIFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dFwiKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcInBkZmpzLWZyZWUtdGV4dC1kZWZhdWx0LWNvbnRlbnRcIikudGhlbihtc2cgPT4gdGhpcy5lZGl0b3JEaXY/LnNldEF0dHJpYnV0ZShcImRlZmF1bHQtY29udGVudFwiLCBtc2cpKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgICgwLHRvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJkYmxjbGlja1wiLCBcImtleWRvd25cIl0pO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICB9ID0gdGhpcy4jaW5pdGlhbERhdGE7XG4gICAgICAgIGxldCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIFt0eCwgdHldID0gdGhpcy5wYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih0eCwgdHkpO1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICAgIGxldCBwb3NYLCBwb3NZO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyB0aGlzLmhlaWdodCAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gW3R5LCAtdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggLSB0aGlzLndpZHRoICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eCwgLXR5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVggLSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgKHBvc2l0aW9uWzFdIC0gcGFnZVkgLSB0aGlzLndpZHRoICogcGFnZVdpZHRoKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHksIHR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXQocG9zWCAqIHBhcmVudFdpZHRoLCBwb3NZICogcGFyZW50SGVpZ2h0LCB0eCwgdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2O1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBhbm5vdGF0aW9uX2xheWVyLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci4jY29sb3IgPSB1dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci4jY29udGVudCA9IGRhdGEudmFsdWU7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLiNpbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gICAgY29uc3QgY29sb3IgPSBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgY29sb3IsXG4gICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUsXG4gICAgICB2YWx1ZTogdGhpcy4jY29udGVudCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9udFNpemUsXG4gICAgICBjb2xvcixcbiAgICAgIHJlY3QsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy4jaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQucmVjdC5zb21lKCh4LCBpKSA9PiBNYXRoLmFicyh4IC0gcmVjdFtpXSkgPj0gMSkgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICAjY2hlYXRJbml0aWFsUmVjdChkZWxheWVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgaWYgKCFkZWxheWVkICYmICh0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwKSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLiNjaGVhdEluaXRpYWxSZWN0KHRydWUpLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHRoaXMuI2luaXRpYWxEYXRhLnJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb2xvcl9waWNrZXIuanNcbnZhciBjb2xvcl9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlzcGxheS9lZGl0b3Ivb3V0bGluZXIuanNcbnZhciBlZGl0b3Jfb3V0bGluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwNSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGlzcGxheS9lZGl0b3IvaGlnaGxpZ2h0LmpzXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgZWRpdG9yX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JveGVzO1xuICAjY2xpcFBhdGhJZCA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNmb2N1c091dGxpbmVzID0gbnVsbDtcbiAgI2hpZ2hsaWdodERpdiA9IG51bGw7XG4gICNoaWdobGlnaHRPdXRsaW5lcyA9IG51bGw7XG4gICNpZCA9IG51bGw7XG4gICNsYXN0UG9pbnQgPSBudWxsO1xuICAjb3BhY2l0eTtcbiAgI291dGxpbmVJZCA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfbDEwblByb21pc2U7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImhpZ2hsaWdodEVkaXRvclwiXG4gICAgfSk7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHw9IHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNmZmYwNjZcIjtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IGVkaXRvcl9vdXRsaW5lci5PdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICAoe1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCk7XG4gICAgY29uc3Qgb3V0bGluZXJGb3JPdXRsaW5lID0gbmV3IGVkaXRvcl9vdXRsaW5lci5PdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDI1LCAwLjAwMSwgdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IG91dGxpbmVyRm9yT3V0bGluZS5nZXRPdXRsaW5lcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzLmJveDtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHRoaXMueCkgLyB0aGlzLndpZHRoLCAobGFzdFBvaW50WzFdIC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgZWRpdG9yX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbik7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1t1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIHRoaXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdXTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5jaGFuZ2VDb2xvcih0aGlzLiNpZCwgY29sb3IpO1xuICAgICAgICB0aGlzLiNjb2xvclBpY2tlcj8udXBkYXRlQ29sb3IoY29sb3IpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2xvciA9IHNhdmVkQ29sb3I7XG4gICAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5jaGFuZ2VDb2xvcih0aGlzLiNpZCwgc2F2ZWRDb2xvcik7XG4gICAgICAgIHRoaXMuI2NvbG9yUGlja2VyPy51cGRhdGVDb2xvcihzYXZlZENvbG9yKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgY29uc3QgdG9vbGJhciA9IGF3YWl0IHN1cGVyLmFkZEVkaXRUb29sYmFyKCk7XG4gICAgaWYgKCF0b29sYmFyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIHRoaXMuI2NvbG9yUGlja2VyID0gbmV3IGNvbG9yX3BpY2tlci5Db2xvclBpY2tlcih7XG4gICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgfSk7XG4gICAgICB0b29sYmFyLmFkZENvbG9yUGlja2VyKHRoaXMuI2NvbG9yUGlja2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2xiYXI7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gc3VwZXIuZml4QW5kU2V0UG9zaXRpb24oMCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0UmVjdCh0eCwgdHksIDApO1xuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLiNpZCA9PT0gbnVsbCB8fCAhdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNpZCk7XG4gICAgdGhpcy4jaWQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jb3V0bGluZUlkKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBudWxsO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLiNpZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy4jY2xpcFBhdGhJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmhpZ2hsaWdodCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcywgdGhpcy5jb2xvciwgdGhpcy4jb3BhY2l0eSkpO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHREaXYpIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgfVxuICAgIHRoaXMuI291dGxpbmVJZCA9IHBhcmVudC5kcmF3TGF5ZXIuaGlnaGxpZ2h0T3V0bGluZSh0aGlzLiNmb2N1c091dGxpbmVzKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IDEgLSB5IC0gaGVpZ2h0LFxuICAgICAgICAgIHk6IHgsXG4gICAgICAgICAgd2lkdGg6IGhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHdpZHRoXG4gICAgICAgIH07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAxIC0geCAtIHdpZHRoLFxuICAgICAgICAgIHk6IDEgLSB5IC0gaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9O1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeSxcbiAgICAgICAgICB5OiAxIC0geCAtIHdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3aWR0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGRyYXdMYXllci5yb3RhdGUodGhpcy4jaWQsIGFuZ2xlKTtcbiAgICBkcmF3TGF5ZXIucm90YXRlKHRoaXMuI291dGxpbmVJZCwgYW5nbGUpO1xuICAgIGRyYXdMYXllci51cGRhdGVCb3godGhpcy4jaWQsIEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLCBhbmdsZSkpO1xuICAgIGRyYXdMYXllci51cGRhdGVCb3godGhpcy4jb3V0bGluZUlkLCBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIGhpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAoMCx0b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLiNoaWdobGlnaHREaXYsIFtcInBvaW50ZXJvdmVyXCIsIFwicG9pbnRlcmxlYXZlXCJdKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHBvaW50ZXJvdmVyKCkge1xuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5hZGRDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwiaG92ZXJlZFwiKTtcbiAgfVxuICBwb2ludGVybGVhdmUoKSB7XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZUNsYXNzKHRoaXMuI291dGxpbmVJZCwgXCJob3ZlcmVkXCIpO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnJlbW92ZUNsYXNzKHRoaXMuI291dGxpbmVJZCwgXCJob3ZlcmVkXCIpO1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIuYWRkQ2xhc3ModGhpcy4jb3V0bGluZUlkLCBcInNlbGVjdGVkXCIpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHN1cGVyLnVuc2VsZWN0KCk7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci5yZW1vdmVDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwic2VsZWN0ZWRcIik7XG4gIH1cbiAgI3NlcmlhbGl6ZUJveGVzKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuI2JveGVzO1xuICAgIGNvbnN0IHF1YWRQb2ludHMgPSBuZXcgQXJyYXkoYm94ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHN4ID0geCAqIHBhZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHN5ID0gKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICBxdWFkUG9pbnRzW2ldID0gcXVhZFBvaW50c1tpICsgNF0gPSBzeDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDFdID0gcXVhZFBvaW50c1tpICsgM10gPSBzeTtcbiAgICAgIHF1YWRQb2ludHNbaSArIDJdID0gcXVhZFBvaW50c1tpICsgNl0gPSBzeCArIHdpZHRoICogcGFnZVdpZHRoO1xuICAgICAgcXVhZFBvaW50c1tpICsgNV0gPSBxdWFkUG9pbnRzW2kgKyA3XSA9IHN5ICsgaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICAgIGkgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRQb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHR4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHR5ID0gKDEgLSB0aGlzLnkgLSB0aGlzLmhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLm91dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IHR4ICsgb3V0bGluZVtpXSAqIHdpZHRoO1xuICAgICAgICBwb2ludHNbaSArIDFdID0gdHkgKyAoMSAtIG91dGxpbmVbaSArIDFdKSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVzLnB1c2gocG9pbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgY29sb3IsXG4gICAgICBxdWFkUG9pbnRzXG4gICAgfSA9IGRhdGE7XG4gICAgZWRpdG9yLmNvbG9yID0gdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvcik7XG4gICAgZWRpdG9yLiNvcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IGJveGVzID0gZWRpdG9yLiNib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgYm94ZXMucHVzaCh7XG4gICAgICAgIHg6IHF1YWRQb2ludHNbNF0gLyBwYWdlV2lkdGgsXG4gICAgICAgIHk6IDEgLSBxdWFkUG9pbnRzW2kgKyA1XSAvIHBhZ2VIZWlnaHQsXG4gICAgICAgIHdpZHRoOiAocXVhZFBvaW50c1tpICsgMl0gLSBxdWFkUG9pbnRzW2ldKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgNV0gLSBxdWFkUG9pbnRzW2kgKyAxXSkgLyBwYWdlSGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY29sb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHk6IHRoaXMuI29wYWNpdHksXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2Rpc3BsYXlfdXRpbHMuanNcbnZhciBkaXNwbGF5X3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2luay5qc1xuXG5cblxuXG5cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiYXNlSGVpZ2h0ID0gMDtcbiAgI2Jhc2VXaWR0aCA9IDA7XG4gICNib3VuZENhbnZhc1BvaW50ZXJtb3ZlID0gdGhpcy5jYW52YXNQb2ludGVybW92ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVybGVhdmUgPSB0aGlzLmNhbnZhc1BvaW50ZXJsZWF2ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVydXAgPSB0aGlzLmNhbnZhc1BvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVyZG93biA9IHRoaXMuY2FudmFzUG9pbnRlcmRvd24uYmluZCh0aGlzKTtcbiAgI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gbnVsbDtcbiAgI2N1cnJlbnRQYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICNkaXNhYmxlRWRpdGluZyA9IGZhbHNlO1xuICAjaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICNpc0NhbnZhc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICNvYnNlcnZlciA9IG51bGw7XG4gICNyZWFsV2lkdGggPSAwO1xuICAjcmVhbEhlaWdodCA9IDA7XG4gICNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfZGVmYXVsdFRoaWNrbmVzcyA9IDE7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBudWxsO1xuICAgIHRoaXMudGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBudWxsO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IG51bGw7XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMuYmV6aWVyUGF0aDJEID0gW107XG4gICAgdGhpcy5hbGxSYXdQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gMTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgdGhpcy4jdXBkYXRlT3BhY2l0eSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl0sIFt1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgKiAxMDApXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1t1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIHRoaXMudGhpY2tuZXNzIHx8IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFt1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgdGhpcy5jb2xvciB8fCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSwgTWF0aC5yb3VuZCgxMDAgKiAodGhpcy5vcGFjaXR5ID8/IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkpKV1dO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHNhdmVkVGhpY2tuZXNzO1xuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiB1dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICBvcGFjaXR5IC89IDEwMDtcbiAgICBjb25zdCBzYXZlZE9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBzYXZlZE9wYWNpdHk7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIH1cbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50ICYmIHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiBwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcgfHwgdGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0aW5nXCIpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSAhdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRocy5sZW5ndGggPT09IDAgfHwgdGhpcy5wYXRocy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXRoc1swXS5sZW5ndGggPT09IDA7XG4gIH1cbiAgI2dldEluaXRpYWxCQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3dpZHRoLCBoZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChwYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFswLCBoZWlnaHQsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgMCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjc2V0U3Ryb2tlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgc2NhbGVGYWN0b3JcbiAgICB9ID0gdGhpcztcbiAgICBjdHgubGluZVdpZHRoID0gdGhpY2tuZXNzICogcGFyZW50U2NhbGUgLyBzY2FsZUZhY3RvcjtcbiAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBgJHtjb2xvcn0keygwLHRvb2xzLm9wYWNpdHlUb0hleCkob3BhY2l0eSl9YDtcbiAgfVxuICAjc3RhcnREcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybW92ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy50aGlja25lc3MgfHw9IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICAgIHRoaXMuY29sb3IgfHw9IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICAgIHRoaXMub3BhY2l0eSA/Pz0gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNkcmF3UG9pbnRzKCk7XG4gICAgICBpZiAodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKTtcbiAgfVxuICAjZHJhdyh4LCB5KSB7XG4gICAgY29uc3QgW2xhc3RYLCBsYXN0WV0gPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPiAxICYmIHggPT09IGxhc3RYICYmIHkgPT09IGxhc3RZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICBsZXQgcGF0aDJEID0gdGhpcy4jY3VycmVudFBhdGgyRDtcbiAgICBjdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gdHJ1ZTtcbiAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgICAgcGF0aDJELmxpbmVUbyh4LCB5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IHBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgIH1cbiAgICB0aGlzLiNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCAuLi5jdXJyZW50UGF0aC5hdCgtMyksIC4uLmN1cnJlbnRQYXRoLmF0KC0yKSwgeCwgeSk7XG4gIH1cbiAgI2VuZFBhdGgoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHRoaXMuY3VycmVudFBhdGguYXQoLTEpO1xuICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQubGluZVRvKC4uLmxhc3RQb2ludCk7XG4gIH1cbiAgI3N0b3BEcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIDApLCB0aGlzLmNhbnZhcy53aWR0aCk7XG4gICAgeSA9IE1hdGgubWluKE1hdGgubWF4KHksIDApLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuI2RyYXcoeCwgeSk7XG4gICAgdGhpcy4jZW5kUGF0aCgpO1xuICAgIGxldCBiZXppZXI7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoICE9PSAxKSB7XG4gICAgICBiZXppZXIgPSB0aGlzLiNnZW5lcmF0ZUJlemllclBvaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB4eSA9IFt4LCB5XTtcbiAgICAgIGJlemllciA9IFtbeHksIHh5LnNsaWNlKCksIHh5LnNsaWNlKCksIHh5XV07XG4gICAgfVxuICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICB0aGlzLnBhdGhzLnB1c2goYmV6aWVyKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnB1c2gocGF0aDJEKTtcbiAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucG9wKCk7XG4gICAgICB0aGlzLnBhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5iZXppZXJQYXRoMkQucG9wKCk7XG4gICAgICBpZiAodGhpcy5wYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjZHJhd1BvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgICBjb25zdCB0aGlja25lc3MgPSBNYXRoLmNlaWwodGhpcy50aGlja25lc3MgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICBjb25zdCBsYXN0UG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zbGljZSgtMyk7XG4gICAgY29uc3QgeCA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzBdKTtcbiAgICBjb25zdCB5ID0gbGFzdFBvaW50cy5tYXAoeHkgPT4geHlbMV0pO1xuICAgIGNvbnN0IHhNaW4gPSBNYXRoLm1pbiguLi54KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoLi4ueCkgKyB0aGlja25lc3M7XG4gICAgY29uc3QgeU1pbiA9IE1hdGgubWluKC4uLnkpIC0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNYXggPSBNYXRoLm1heCguLi55KSArIHRoaWNrbmVzcztcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKHRoaXMuI2N1cnJlbnRQYXRoMkQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgI21ha2VCZXppZXJDdXJ2ZShwYXRoMkQsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBwcmV2WCA9ICh4MCArIHgxKSAvIDI7XG4gICAgY29uc3QgcHJldlkgPSAoeTAgKyB5MSkgLyAyO1xuICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgcGF0aDJELmJlemllckN1cnZlVG8ocHJldlggKyAyICogKHgxIC0gcHJldlgpIC8gMywgcHJldlkgKyAyICogKHkxIC0gcHJldlkpIC8gMywgeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gMywgeDMsIHkzKTtcbiAgfVxuICAjZ2VuZXJhdGVCZXppZXJQb2ludHMoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKHBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBbW3BhdGhbMF0sIHBhdGhbMF0sIHBhdGguYXQoLTEpLCBwYXRoLmF0KC0xKV1dO1xuICAgIH1cbiAgICBjb25zdCBiZXppZXJQb2ludHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgW3gwLCB5MF0gPSBwYXRoWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgY29uc3QgW3gxLCB5MV0gPSBwYXRoW2ldO1xuICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGNvbnN0IHkzID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgICAgY29uc3QgY29udHJvbDIgPSBbeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gM107XG4gICAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gzLCB5M11dKTtcbiAgICAgIFt4MCwgeTBdID0gW3gzLCB5M107XG4gICAgfVxuICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHBhdGhbaSArIDFdO1xuICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgIGNvbnN0IGNvbnRyb2wyID0gW3gyICsgMiAqICh4MSAtIHgyKSAvIDMsIHkyICsgMiAqICh5MSAtIHkyKSAvIDNdO1xuICAgIGJlemllclBvaW50cy5wdXNoKFtbeDAsIHkwXSwgY29udHJvbDEsIGNvbnRyb2wyLCBbeDIsIHkyXV0pO1xuICAgIHJldHVybiBiZXppZXJQb2ludHM7XG4gIH1cbiAgI3JlZHJhdygpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXMsXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5iZXppZXJQYXRoMkQpIHtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQodHJ1ZSk7XG4gICAgdGhpcy5zZWxlY3QoKTtcbiAgICB0aGlzLnBhcmVudC5hZGRJbmtFZGl0b3JJZk5lZWRlZCh0cnVlKTtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jc3RhcnREcmF3aW5nKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJtb3ZlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNkcmF3KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJ1cChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jZW5kRHJhd2luZyhldmVudCk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcmxlYXZlKGV2ZW50KSB7XG4gICAgdGhpcy4jZW5kRHJhd2luZyhldmVudCk7XG4gIH1cbiAgI2VuZERyYXdpbmcoZXZlbnQpIHtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybW92ZSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIGlmICh0aGlzLiNjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBkaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIH0sIDEwKTtcbiAgICB0aGlzLiNzdG9wRHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgICB0aGlzLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc05hbWUgPSBcImlua0VkaXRvckNhbnZhc1wiO1xuICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWluay1jYW52YXNcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy4jZGlzYWJsZUVkaXRpbmc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1pbmtcIik7XG4gICAgY29uc3QgW3gsIHksIHcsIGhdID0gdGhpcy4jZ2V0SW5pdGlhbEJCb3goKTtcbiAgICB0aGlzLnNldEF0KHgsIHksIDAsIDApO1xuICAgIHRoaXMuc2V0RGltcyh3LCBoKTtcbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImVkaXRpbmdcIik7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDYW52YXNEaW1zKCkge1xuICAgIGlmICghdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHBhcmVudFdpZHRoKTtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHRoaXMuI3JlYWxXaWR0aCA9PT0gcm91bmRlZFdpZHRoICYmIHRoaXMuI3JlYWxIZWlnaHQgPT09IHJvdW5kZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gcm91bmRlZFdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSByb3VuZGVkSGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICB0aGlzLmZpeERpbXMoKTtcbiAgfVxuICAjc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JXID0gKHdpZHRoIC0gcGFkZGluZykgLyB0aGlzLiNiYXNlV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JIID0gKGhlaWdodCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZUhlaWdodDtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gTWF0aC5taW4oc2NhbGVGYWN0b3JXLCBzY2FsZUZhY3RvckgpO1xuICB9XG4gICN1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKSAvIDI7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHRoaXMuc2NhbGVGYWN0b3IsIDAsIDAsIHRoaXMuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcsIHRoaXMudHJhbnNsYXRpb25ZICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyAjYnVpbGRQYXRoMkQoYmV6aWVyKSB7XG4gICAgY29uc3QgcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltpXTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uZmlyc3QpO1xuICAgICAgfVxuICAgICAgcGF0aDJELmJlemllckN1cnZlVG8oY29udHJvbDFbMF0sIGNvbnRyb2wxWzFdLCBjb250cm9sMlswXSwgY29udHJvbDJbMV0sIHNlY29uZFswXSwgc2Vjb25kWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyRDtcbiAgfVxuICBzdGF0aWMgI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldICs9IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdICsgYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4ICsgYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gKz0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBzdGF0aWMgI2Zyb21QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gLT0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gLSBibFk7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggLSBibFg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSAtPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWCAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVQYXRocyhzLCB0eCwgdHksIHJlY3QpIHtcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnRoaWNrbmVzcyAvIDI7XG4gICAgY29uc3Qgc2hpZnRYID0gcyAqIHR4ICsgcGFkZGluZztcbiAgICBjb25zdCBzaGlmdFkgPSBzICogdHkgKyBwYWRkaW5nO1xuICAgIGZvciAoY29uc3QgYmV6aWVyIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBiZXppZXIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltqXTtcbiAgICAgICAgY29uc3QgcDEwID0gcyAqIGZpcnN0WzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMTEgPSBzICogZmlyc3RbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHMgKiBjb250cm9sMVswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDIxID0gcyAqIGNvbnRyb2wxWzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMzAgPSBzICogY29udHJvbDJbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAzMSA9IHMgKiBjb250cm9sMlsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDQwID0gcyAqIHNlY29uZFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDQxID0gcyAqIHNlY29uZFsxXSArIHNoaWZ0WTtcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICBidWZmZXIucHVzaChwMTAsIHAxMSk7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEpO1xuICAgICAgICBwb2ludHMucHVzaChwMjAsIHAyMSk7XG4gICAgICAgIGlmIChqID09PSBqaiAtIDEpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChwNDAsIHA0MSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICBiZXppZXI6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhidWZmZXIsIHJlY3QsIHRoaXMucm90YXRpb24pLFxuICAgICAgICBwb2ludHM6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHRoaXMucm90YXRpb24pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG4gICNnZXRCYm94KCkge1xuICAgIGxldCB4TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHhNYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IHlNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5wYXRocykge1xuICAgICAgZm9yIChjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSB1dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goLi4uZmlyc3QsIC4uLmNvbnRyb2wxLCAuLi5jb250cm9sMiwgLi4uc2Vjb25kKTtcbiAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIGJib3hbMF0pO1xuICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgYmJveFsxXSk7XG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBiYm94WzJdKTtcbiAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIGJib3hbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdO1xuICB9XG4gICNnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNkaXNhYmxlRWRpdGluZyA/IE1hdGguY2VpbCh0aGlzLnRoaWNrbmVzcyAqIHRoaXMucGFyZW50U2NhbGUpIDogMDtcbiAgfVxuICAjZml0VG9Db250ZW50KGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jZ2V0QmJveCgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgdGhpcy4jYmFzZVdpZHRoID0gTWF0aC5tYXgoZWRpdG9yX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdGhpcy4jYmFzZUhlaWdodCA9IE1hdGgubWF4KGVkaXRvcl9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlV2lkdGggKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VIZWlnaHQgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gLWJib3hbMF07XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAtYmJveFsxXTtcbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy4jcmVhbEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNldERpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdW5zY2FsZWRQYWRkaW5nID0gZmlyc3RUaW1lID8gcGFkZGluZyAvIHRoaXMuc2NhbGVGYWN0b3IgLyAyIDogMDtcbiAgICB0aGlzLnRyYW5zbGF0ZShwcmV2VHJhbnNsYXRpb25YIC0gdGhpcy50cmFuc2xhdGlvblggLSB1bnNjYWxlZFBhZGRpbmcsIHByZXZUcmFuc2xhdGlvblkgLSB0aGlzLnRyYW5zbGF0aW9uWSAtIHVuc2NhbGVkUGFkZGluZyk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBhbm5vdGF0aW9uX2xheWVyLklua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci50aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICBlZGl0b3IuY29sb3IgPSB1dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gZWRpdG9yLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVkaXRvci5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZWRpdG9yLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkYXRhLnRoaWNrbmVzcyAvIDI7XG4gICAgZWRpdG9yLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgZWRpdG9yLiNyZWFsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBlZGl0b3IuI3JlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aHMsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBmb3IgKGxldCB7XG4gICAgICBiZXppZXJcbiAgICB9IG9mIHBhdGhzKSB7XG4gICAgICBiZXppZXIgPSBJbmtFZGl0b3IuI2Zyb21QREZDb29yZGluYXRlcyhiZXppZXIsIHJlY3QsIHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgIGVkaXRvci5wYXRocy5wdXNoKHBhdGgpO1xuICAgICAgbGV0IHAwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzBdIC0gcGFkZGluZyk7XG4gICAgICBsZXQgcDEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMV0gLSBwYWRkaW5nKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IHAxMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMTEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDFdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMl0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAzXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDRdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNV0gLSBwYWRkaW5nKTtcbiAgICAgICAgcGF0aC5wdXNoKFtbcDAsIHAxXSwgW3AxMCwgcDExXSwgW3AyMCwgcDIxXSwgW3AzMCwgcDMxXV0pO1xuICAgICAgICBwMCA9IHAzMDtcbiAgICAgICAgcDEgPSBwMzE7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNidWlsZFBhdGgyRChwYXRoKTtcbiAgICAgIGVkaXRvci5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gZWRpdG9yLiNnZXRCYm94KCk7XG4gICAgZWRpdG9yLiNiYXNlV2lkdGggPSBNYXRoLm1heChlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICBlZGl0b3IuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBlZGl0b3IuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY3R4LnN0cm9rZVN0eWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3M6IHRoaXMudGhpY2tuZXNzLFxuICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5LFxuICAgICAgcGF0aHM6IHRoaXMuI3NlcmlhbGl6ZVBhdGhzKHRoaXMuc2NhbGVGYWN0b3IgLyB0aGlzLnBhcmVudFNjYWxlLCB0aGlzLnRyYW5zbGF0aW9uWCwgdGhpcy50cmFuc2xhdGlvblksIHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGlzcGxheS9lZGl0b3Ivc3RhbXAuanNcblxuXG5cblxuY2xhc3MgU3RhbXBFZGl0b3IgZXh0ZW5kcyBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgZWRpdG9yX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbik7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtcImFwbmdcIiwgXCJhdmlmXCIsIFwiYm1wXCIsIFwiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcInN2Zyt4bWxcIiwgXCJ3ZWJwXCIsIFwieC1pY29uXCJdO1xuICAgIHJldHVybiAoMCx1dGlsLnNoYWRvdykodGhpcywgXCJzdXBwb3J0ZWRUeXBlc1wiLCB0eXBlcy5tYXAodHlwZSA9PiBgaW1hZ2UvJHt0eXBlfWApKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzU3RyKCkge1xuICAgIHJldHVybiAoMCx1dGlsLnNoYWRvdykodGhpcywgXCJzdXBwb3J0ZWRUeXBlc1N0clwiLCB0aGlzLnN1cHBvcnRlZFR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLiNjYW52YXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdGFtcEVkaXRvci5zdXBwb3J0ZWRUeXBlc1N0cjtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMod2lkdGggKiBwYXJlbnRXaWR0aCAvIHBhZ2VXaWR0aCwgaGVpZ2h0ICogcGFyZW50SGVpZ2h0IC8gcGFnZUhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgZGl2LmFwcGVuZChjYW52YXMpO1xuICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgc3VidHlwZTogdGhpcy5lZGl0b3JUeXBlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQWx0VGV4dEJ1dHRvbigpO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgfVxuICAjc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjYW52YXM7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBkaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAqIGRpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLiNzZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIGFubm90YXRpb25fbGF5ZXIuU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgYml0bWFwVXJsLFxuICAgICAgYml0bWFwSWQsXG4gICAgICBpc1N2ZyxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcFVybCA9IGJpdG1hcFVybDtcbiAgICB9XG4gICAgZWRpdG9yLiNpc1N2ZyA9IGlzU3ZnO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBlZGl0b3Iud2lkdGggPSAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFyZW50V2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICBlZGl0b3IuYWx0VGV4dERhdGEgPSBhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuYWx0VGV4dERhdGE7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5hbHRUZXh0RGF0YTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICNhbGxvd0NsaWNrID0gZmFsc2U7XG4gICNhbm5vdGF0aW9uTGF5ZXIgPSBudWxsO1xuICAjYm91bmRQb2ludGVydXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAjYm91bmRQb2ludGVyVXBBZnRlclNlbGVjdGlvbiA9IHRoaXMucG9pbnRlclVwQWZ0ZXJTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgI2JvdW5kUG9pbnRlcmRvd24gPSB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICNib3VuZFNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydC5iaW5kKHRoaXMpO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICN0ZXh0TGF5ZXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0YXRpYyAjZWRpdG9yVHlwZXMgPSBuZXcgTWFwKFtGcmVlVGV4dEVkaXRvciwgSW5rRWRpdG9yLCBTdGFtcEVkaXRvciwgSGlnaGxpZ2h0RWRpdG9yXS5tYXAodHlwZSA9PiBbdHlwZS5fZWRpdG9yVHlwZSwgdHlwZV0pKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICBkcmF3TGF5ZXIsXG4gICAgdGV4dExheWVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGwxMG5cbiAgfSkge1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gWy4uLkFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCldO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4pO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN0ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgdGhpcy5kcmF3TGF5ZXIgPSBkcmF3TGF5ZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuICAgIGlmIChtb2RlICE9PSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NMaXN0XG4gICAgICB9ID0gdGhpcy5kaXY7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2AsIG1vZGUgPT09IGVkaXRvclR5cGUuX2VkaXRvclR5cGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFkZElua0VkaXRvcklmTmVlZGVkKGlzQ29tbWl0dGluZykge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpICE9PSB1dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tbWl0dGluZykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgIG9mZnNldFg6IDAsXG4gICAgICBvZmZzZXRZOiAwXG4gICAgfSwgZmFsc2UpO1xuICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIHRvZ2dsZVBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIGNvbnN0IGFubm90YXRpb25FbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgfVxuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgY29uc3QgaGlkZGVuQW5ub3RhdGlvbklkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGhpZGRlbkFubm90YXRpb25JZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKGhpZGRlbkFubm90YXRpb25JZHMuaGFzKGlkKSB8fCB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCB0aGlzLiNib3VuZFNlbGVjdGlvblN0YXJ0KTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2KSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgdGhpcy4jYm91bmRTZWxlY3Rpb25TdGFydCk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZFBvaW50ZXJkb3duKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kUG9pbnRlcnVwKTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRQb2ludGVydXApO1xuICB9XG4gIGF0dGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICAgIH0gPSBlZGl0b3I7XG4gICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQgJiYgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRldGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgIGlmICghdGhpcy4jaXNEaXNhYmxpbmcgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGVkaXRvcikge1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy4jaXNDbGVhbmluZ1VwKSB7XG4gICAgICB0aGlzLmFkZElua0VkaXRvcklmTmVlZGVkKGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgY2hhbmdlUGFyZW50KGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBlZGl0b3JfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3IucGFyZW50Py5kZXRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2V0UGFyZW50KHRoaXMpO1xuICAgIGlmIChlZGl0b3IuZGl2ICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWRpdG9yLmRpdik7XG4gICAgfVxuICB9XG4gIGFkZChlZGl0b3IpIHtcbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCgpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gIH1cbiAgbW92ZUVkaXRvckluRE9NKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmICF0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucGFyZW50IHx8PSB0aGlzO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gIGdldCAjY3VycmVudEVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZSA9IHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlO1xuICAgIHJldHVybiBlZGl0b3JUeXBlID8gbmV3IGVkaXRvclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcykgOiBudWxsO1xuICB9XG4gIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKTtcbiAgfVxuICBwYXN0ZUVkaXRvcihtb2RlLCBwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQoZGF0YS5hbm5vdGF0aW9uVHlwZSA/PyBkYXRhLmFubm90YXRpb25FZGl0b3JUeXBlKT8uZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKSB8fCBudWxsO1xuICB9XG4gICNjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZCxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcigpIHtcbiAgICB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmlzU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBzZWxlY3Rpb25TdGFydChfZXZlbnQpIHtcbiAgICB0aGlzLiN0ZXh0TGF5ZXI/LmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kUG9pbnRlclVwQWZ0ZXJTZWxlY3Rpb24sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfVxuICBwb2ludGVyVXBBZnRlclNlbGVjdGlvbihldmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0ZXh0TGF5ZXI/LmRpdi5jb250YWlucyhyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGhpcy4jdGV4dExheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBiYm94ZXMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGhpcy52aWV3cG9ydC5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6ICh5IC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYmJveGVzKSB7XG4gICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG4gICAgaWYgKGJveGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBib3hlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IHV0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIHRoaXMuI2lzQ2xlYW5pbmdVcCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbG9yUGlja2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvclBpY2tlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90b29sc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3Myk7XG5cblxuXG5jbGFzcyBDb2xvclBpY2tlciB7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNidXR0b24gPSBudWxsO1xuICAjYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgI2RlZmF1bHRDb2xvcjtcbiAgI2Ryb3Bkb3duID0gbnVsbDtcbiAgI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZmFsc2U7XG4gICNpc01haW5Db2xvclBpY2tlciA9IGZhbHNlO1xuICAjZXZlbnRCdXM7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBfdG9vbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5LZXlib2FyZE1hbmFnZXIoW1tbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZF0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmRdLCBbW1wiQXJyb3dEb3duXCIsIFwiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9OZXh0XSwgW1tcIkFycm93VXBcIiwgXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dVcFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvUHJldmlvdXNdLCBbW1wiSG9tZVwiLCBcIm1hYytIb21lXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0JlZ2lubmluZ10sIFtbXCJFbmRcIiwgXCJtYWMrRW5kXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0VuZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvciA9IG51bGwsXG4gICAgdWlNYW5hZ2VyID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSAhZWRpdG9yO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvcj8uX3VpTWFuYWdlciB8fCB1aU1hbmFnZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzO1xuICAgIHRoaXMuI2RlZmF1bHRDb2xvciA9IGVkaXRvcj8uY29sb3IgfHwgdGhpcy4jdWlNYW5hZ2VyPy5oaWdobGlnaHRDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI0ZGRkY5OFwiO1xuICB9XG4gIHJlbmRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbG9yUGlja2VyXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1idXR0b25cIik7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNvcGVuRHJvcGRvd24uYmluZCh0aGlzKSk7XG4gICAgY29uc3Qgc3dhdGNoID0gdGhpcy4jYnV0dG9uU3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICByZW5kZXJNYWluRHJvcGRvd24oKSB7XG4gICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdChfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUik7XG4gICAgZHJvcGRvd24uc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcImhvcml6b250YWxcIik7XG4gICAgZHJvcGRvd24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIFwiaGlnaGxpZ2h0Q29sb3JQaWNrZXJMYWJlbFwiKTtcbiAgICByZXR1cm4gZHJvcGRvd247XG4gIH1cbiAgI2dldERyb3Bkb3duUm9vdChwYXJhbVR5cGUpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5ub0NvbnRleHRNZW51KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGZhbHNlKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcInZlcnRpY2FsXCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IG5hbWU7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGBwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItJHtuYW1lfWApO1xuICAgICAgY29uc3Qgc3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3IpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNjb2xvclNlbGVjdC5iaW5kKHRoaXMsIHBhcmFtVHlwZSwgY29sb3IpKTtcbiAgICAgIGRpdi5hcHBlbmQoYnV0dG9uKTtcbiAgICB9XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjY29sb3JTZWxlY3QodHlwZSwgY29sb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZTogY29sb3JcbiAgICB9KTtcbiAgfVxuICBfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQoZXZlbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29sb3JTZWxlY3QoY29sb3IsIGV2ZW50KTtcbiAgfVxuICBfbW92ZVRvTmV4dChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uZmlyc3RDaGlsZD8uZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0Lm5leHRTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9QcmV2aW91cyhldmVudCkge1xuICAgIGV2ZW50LnRhcmdldC5wcmV2aW91c1NpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb0JlZ2lubmluZygpIHtcbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoKSB7XG4gICAgdGhpcy4jZHJvcGRvd24ubGFzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIikpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICh0aGlzLiNkcm9wZG93bikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUik7XG4gICAgdGhpcy4jYnV0dG9uLmFwcGVuZChyb290KTtcbiAgfVxuICBoaWRlRHJvcGRvd24oKSB7XG4gICAgdGhpcy4jZHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgfHwgIXRoaXMuI2Ryb3Bkb3duIHx8IHRoaXMuI2Ryb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5uZXh0KCkudmFsdWUgPT09IGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBBbm5vdGF0aW9uRWRpdG9yOiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0aW9uRWRpdG9yKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbHMuanNcbnZhciB0b29scyA9IF9fd2VicGFja19yZXF1aXJlX18oODEyKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2hhcmVkL3V0aWwuanNcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2Rpc3BsYXlfdXRpbHMuanNcbnZhciBkaXNwbGF5X3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2FsdF90ZXh0LmpzXG5cbmNsYXNzIEFsdFRleHQge1xuICAjYWx0VGV4dCA9IFwiXCI7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAjYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuUHJvbWlzZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuUHJvbWlzZSkge1xuICAgIEFsdFRleHQuX2wxMG5Qcm9taXNlIHx8PSBsMTBuUHJvbWlzZTtcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgY29uc3QgbXNnID0gYXdhaXQgQWx0VGV4dC5fbDEwblByb21pc2UuZ2V0KFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvbi1sYWJlbFwiKTtcbiAgICBhbHRUZXh0LnRleHRDb250ZW50ID0gbXNnO1xuICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpO1xuICAgIGFsdFRleHQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBkaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMuI2VkaXRvcik7XG4gICAgfTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBhbHRUZXh0ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSB0cnVlO1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLiNzZXRTdGF0ZSgpO1xuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQ6IHRoaXMuI2FsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZVxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgfVxuICBhc3luYyAjc2V0U3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICBBbHRUZXh0Ll9sMTBuUHJvbWlzZS5nZXQoXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZWRpdC1idXR0b24tbGFiZWxcIikudGhlbihtc2cgPT4ge1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICB9KTtcbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIGNvbnN0IGlkID0gdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy4jZWRpdG9yLmlkfWA7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBpZCk7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xuICAgICAgICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICAgICAgICBzdWJ0eXBlOiB0aGlzLiNlZGl0b3IuZWRpdG9yVHlwZSxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdG9vbHRpcC5pbm5lclRleHQgPSB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA/IGF3YWl0IEFsdFRleHQuX2wxMG5Qcm9taXNlLmdldChcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1kZWNvcmF0aXZlLXRvb2x0aXBcIikgOiB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghdG9vbHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICBidXR0b24uYXBwZW5kKHRvb2x0aXApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWRpdG9yLmdldEltYWdlRm9yQWx0VGV4dCgpO1xuICAgIGVsZW1lbnQ/LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgdG9vbHRpcC5pZCk7XG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3Rvb2xiYXIuanNcblxuY2xhc3MgRWRpdG9yVG9vbGJhciB7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2VkaXRvcjtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NOYW1lID0gXCJlZGl0VG9vbGJhclwiO1xuICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBkaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBFZGl0b3JUb29sYmFyLiNwb2ludGVyRG93bik7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLnRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBlZGl0VG9vbGJhcjtcbiAgICAgIGNvbnN0IHggPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXTtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICAgIH1cbiAgICB0aGlzLiNhZGREZWxldGVCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgc3RhdGljICNwb2ludGVyRG93bihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjZm9jdXNJbihlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjZm9jdXNPdXQoZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjYWRkTGlzdGVuZXJzVG9FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2ZvY3VzSW4uYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2ZvY3VzT3V0LmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBkaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgfVxuICAjYWRkRGVsZXRlQnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiZGVsZXRlXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGBwZGZqcy1lZGl0b3ItcmVtb3ZlLSR7dGhpcy4jZWRpdG9yLmVkaXRvclR5cGV9LWJ1dHRvbmApO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kZWxldGUoKTtcbiAgICB9KTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG4gIGdldCAjZGl2aWRlcigpIHtcbiAgICBjb25zdCBkaXZpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXZpZGVyLmNsYXNzTmFtZSA9IFwiZGl2aWRlclwiO1xuICAgIHJldHVybiBkaXZpZGVyO1xuICB9XG4gIGFkZEFsdFRleHRCdXR0b24oYnV0dG9uKSB7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5wcmVwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgYWRkQ29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGNvbG9yUGlja2VyLnJlbmRlckJ1dHRvbigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMucHJlcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2VkaXRvci9lZGl0b3IuanNcblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAja2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICNyZXNpemVyc0RpdiA9IG51bGw7XG4gICNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAjYm91bmRGb2N1c2luID0gdGhpcy5mb2N1c2luLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3Vzb3V0ID0gdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpO1xuICAjZWRpdFRvb2xiYXIgPSBudWxsO1xuICAjZm9jdXNlZFJlc2l6ZXJOYW1lID0gXCJcIjtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpc0VkaXRpbmcgPSBmYWxzZTtcbiAgI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAjaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgX2luaXRpYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX3VpTWFuYWdlciA9IG51bGw7XG4gIF9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICBfbDEwblByb21pc2UgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyB0b29scy5Db2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSB0b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuICgwLHV0aWwuc2hhZG93KSh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyB0b29scy5LZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEFubm90YXRpb25FZGl0b3IuXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gKDAsdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2RlZmF1bHRMaW5lQ29sb3JcIiwgdGhpcy5fY29sb3JNYW5hZ2VyLmdldEhleENvZGUoXCJDYW52YXNUZXh0XCIpKTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgY29uc3QgZmFrZUVkaXRvciA9IG5ldyBGYWtlRWRpdG9yKHtcbiAgICAgIGlkOiBlZGl0b3IucGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgcGFyZW50OiBlZGl0b3IucGFyZW50LFxuICAgICAgdWlNYW5hZ2VyOiBlZGl0b3IuX3VpTWFuYWdlclxuICAgIH0pO1xuICAgIGZha2VFZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGZha2VFZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gICAgZmFrZUVkaXRvci5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZmFrZUVkaXRvcik7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZSB8fD0gbmV3IE1hcChbXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uLWxhYmVsXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWVkaXQtYnV0dG9uLWxhYmVsXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWRlY29yYXRpdmUtdG9vbHRpcFwiLCBcInBkZmpzLWVkaXRvci1yZXNpemVyLWxhYmVsLXRvcExlZnRcIiwgXCJwZGZqcy1lZGl0b3ItcmVzaXplci1sYWJlbC10b3BNaWRkbGVcIiwgXCJwZGZqcy1lZGl0b3ItcmVzaXplci1sYWJlbC10b3BSaWdodFwiLCBcInBkZmpzLWVkaXRvci1yZXNpemVyLWxhYmVsLW1pZGRsZVJpZ2h0XCIsIFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbGFiZWwtYm90dG9tUmlnaHRcIiwgXCJwZGZqcy1lZGl0b3ItcmVzaXplci1sYWJlbC1ib3R0b21NaWRkbGVcIiwgXCJwZGZqcy1lZGl0b3ItcmVzaXplci1sYWJlbC1ib3R0b21MZWZ0XCIsIFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbGFiZWwtbWlkZGxlTGVmdFwiXS5tYXAoc3RyID0+IFtzdHIsIGwxMG4uZ2V0KHN0ci5yZXBsYWNlQWxsKC8oW0EtWl0pL2csIGMgPT4gYC0ke2MudG9Mb3dlckNhc2UoKX1gKSldKSk7XG4gICAgaWYgKG9wdGlvbnM/LnN0cmluZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RyIG9mIG9wdGlvbnMuc3RyaW5ncykge1xuICAgICAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5zZXQoc3RyLCBsMTBuLmdldChzdHIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHt9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICAoMCx1dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQ2xpY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Py5pc011bHRpcGxlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgc2V0QXQoeCwgeSwgdHgsIHR5KSB7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih0eCwgdHkpO1xuICAgIHRoaXMueCA9ICh4ICsgdHgpIC8gd2lkdGg7XG4gICAgdGhpcy55ID0gKHkgKyB0eSkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFnZURpbWVuc2lvbnMsIHgsIHkpO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIGRyYWcodHgsIHR5KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCArPSB0eCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMueSArPSB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgKHRoaXMueCA8IDAgfHwgdGhpcy54ID4gMSB8fCB0aGlzLnkgPCAwIHx8IHRoaXMueSA+IDEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5maW5kTmV3UGFyZW50KHRoaXMsIHgsIHkpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy4jZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICAjZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBfYm9yZGVyTGluZVdpZHRoXG4gICAgfSA9IEFubm90YXRpb25FZGl0b3I7XG4gICAgY29uc3QgeCA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCB5ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbLXgsIHldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4LCAteV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgfVxuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gd2lkdGgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSBoZWlnaHQsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gaGVpZ2h0LCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heCh3aWR0aCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heCh3aWR0aCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgoaGVpZ2h0LCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHggPSBNYXRoLm1pbihwYWdlV2lkdGgsIE1hdGgubWF4KGhlaWdodCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUhlaWdodCAtIHdpZHRoLCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLiNnZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gIH1cbiAgc3RhdGljICNyb3RhdGVQb2ludCh4LCB5LCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeSwgLXhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gWy15LCB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgcGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCAzNjAgLSB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICAjZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgLXBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFstMSwgMCwgMCwgLTFdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCAtcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMSwgMCwgMCwgMV07XG4gICAgfVxuICB9XG4gIGdldCBwYXJlbnRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxuICBnZXQgcGFyZW50Um90YXRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24gKyB0aGlzLnBhZ2VSb3RhdGlvbikgJSAzNjA7XG4gIH1cbiAgZ2V0IHBhcmVudERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IHBhZ2VXaWR0aCAqIHBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdXRpbC5GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkID8gW01hdGgucm91bmQoc2NhbGVkV2lkdGgpLCBNYXRoLnJvdW5kKHNjYWxlZEhlaWdodCldIDogW3NjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHRdO1xuICB9XG4gIHNldERpbXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IGAkeygxMDAgKiB3aWR0aCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogaGVpZ2h0IC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBmaXhEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHdpZHRoUGVyY2VudCA9IHdpZHRoLmVuZHNXaXRoKFwiJVwiKTtcbiAgICBjb25zdCBoZWlnaHRQZXJjZW50ID0gIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiBoZWlnaHQuZW5kc1dpdGgoXCIlXCIpO1xuICAgIGlmICh3aWR0aFBlcmNlbnQgJiYgaGVpZ2h0UGVyY2VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKCF3aWR0aFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmICFoZWlnaHRQZXJjZW50KSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogcGFyc2VGbG9hdChoZWlnaHQpIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPyBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl0gOiBbXCJ0b3BMZWZ0XCIsIFwidG9wTWlkZGxlXCIsIFwidG9wUmlnaHRcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwiYm90dG9tTGVmdFwiLCBcIm1pZGRsZUxlZnRcIl07XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSkpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBkaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgICAgZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgY29uc3QgYm91bmRSZXNpemVyUG9pbnRlcm1vdmUgPSB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKTtcbiAgICBjb25zdCBzYXZlZERyYWdnYWJsZSA9IHRoaXMuX2lzRHJhZ2dhYmxlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgY29uc3QgcG9pbnRlck1vdmVPcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgYm91bmRSZXNpemVyUG9pbnRlcm1vdmUsIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGJvdW5kUmVzaXplclBvaW50ZXJtb3ZlLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkUGFyZW50Q3Vyc29yO1xuICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRDdXJzb3I7XG4gICAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjayhzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gIH1cbiAgI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCkge1xuICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICB0aGlzLnggPSBuZXdYO1xuICAgICAgICB0aGlzLnkgPSBuZXdZO1xuICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLndpZHRoID0gc2F2ZWRXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzYXZlZEhlaWdodDtcbiAgICAgICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgICAgICB0aGlzLnkgPSBzYXZlZFk7XG4gICAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogc2F2ZWRXaWR0aCwgcGFyZW50SGVpZ2h0ICogc2F2ZWRIZWlnaHQpO1xuICAgICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJtb3ZlKG5hbWUsIGV2ZW50KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5XaWR0aCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50SGVpZ2h0O1xuICAgIGNvbnN0IHJvdW5kID0geCA9PiBNYXRoLnJvdW5kKHggKiAxMDAwMCkgLyAxMDAwMDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IFtkZWx0YVgsIGRlbHRhWV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZKTtcbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aC5tYXgobWluV2lkdGgsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCkpKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGgubWF4KG1pbkhlaWdodCwgTWF0aC5taW4oMSwgTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSkpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB0aGlzLnggPSBuZXdYO1xuICAgIHRoaXMueSA9IG5ld1k7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFsdFRleHRGaW5pc2goKSB7XG4gICAgdGhpcy4jYWx0VGV4dD8uZmluaXNoKCk7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRUb29sYmFyIHx8IHRoaXMuI2lzSW5FZGl0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2VkaXRUb29sYmFyO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0VG9vbGJhciA9IG5ldyBFZGl0b3JUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLiNlZGl0VG9vbGJhci5yZW5kZXIoKSk7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHRoaXMuI2VkaXRUb29sYmFyLmFkZEFsdFRleHRCdXR0b24oYXdhaXQgdGhpcy4jYWx0VGV4dC5yZW5kZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNlZGl0VG9vbGJhcjtcbiAgfVxuICByZW1vdmVFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRUb29sYmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRUb29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2VkaXRUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0Py5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0Q2xpZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBbHRUZXh0LmluaXRpYWxpemUoQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBuZXcgQWx0VGV4dCh0aGlzKTtcbiAgICBhd2FpdCB0aGlzLmFkZEVkaXRUb29sYmFyKCk7XG4gIH1cbiAgZ2V0IGFsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5kYXRhO1xuICB9XG4gIHNldCBhbHRUZXh0RGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRvci1yb3RhdGlvblwiLCAoMzYwIC0gdGhpcy5yb3RhdGlvbikgJSAzNjApO1xuICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmlkKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCAwKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICgwLHRvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLl91aU1hbmFnZXIuaXNTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBwb2ludGVyTW92ZU9wdGlvbnMsIHBvaW50ZXJNb3ZlQ2FsbGJhY2s7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHBvaW50ZXJNb3ZlT3B0aW9ucyA9IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHBvaW50ZXJNb3ZlQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGUubW92ZW1lbnRYLCBlLm1vdmVtZW50WSk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBwb2ludGVyTW92ZUNhbGxiYWNrLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuZW5kRHJhZ1Nlc3Npb24oKSkge1xuICAgICAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgfVxuICBtb3ZlSW5ET00oKSB7XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLnBhcmVudD8ubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICAgIH0sIDApO1xuICB9XG4gIF9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpIHtcbiAgICBwYXJlbnQuY2hhbmdlUGFyZW50KHRoaXMpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHksIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBzaGlmdFggPSB0eCAvIHNjYWxlO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHR5IC8gc2NhbGU7XG4gICAgY29uc3QgeCA9IHRoaXMueCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVksIHggKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSArIHBhZ2VZXTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHBhZ2VZLCB4ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBwYWdlWSwgeCAtIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VZLCB4IC0gc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYICsgcGFnZVldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVjdEluQ3VycmVudENvb3JkcyhyZWN0LCBwYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJlY3Q7XG4gICAgY29uc3Qgd2lkdGggPSB4MiAtIHgxO1xuICAgIGNvbnN0IGhlaWdodCA9IHkyIC0geTE7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5Miwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkyLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgfVxuICByb3RhdGUoX2FuZ2xlKSB7fVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgKDAsdXRpbC51bnJlYWNoYWJsZSkoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXJcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jYm91bmRGb2N1c2luKTtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jYm91bmRGb2N1c291dCk7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5yZW1vdmVFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICAoMCx0b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLmRpdiwgW1wia2V5ZG93blwiXSk7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiKTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGJvdW5kUmVzaXplcktleWRvd24pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYm91bmRSZXNpemVyQmx1cik7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSkpO1xuICAgICAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoYHBkZmpzLWVkaXRvci1yZXNpemVyLWxhYmVsLSR7bmFtZX1gKS50aGVuKG1zZyA9PiBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1swXTtcbiAgICBsZXQgZmlyc3RQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChjb25zdCBkaXYgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChkaXYgPT09IGZpcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmlyc3RQb3NpdGlvbisrO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Rmlyc3RQb3NpdGlvbiA9ICgzNjAgLSB0aGlzLnJvdGF0aW9uICsgdGhpcy5wYXJlbnRSb3RhdGlvbikgJSAzNjAgLyA5MCAqICh0aGlzLiNhbGxSZXNpemVyRGl2cy5sZW5ndGggLyA0KTtcbiAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gIT09IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA8IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFBvc2l0aW9uIC0gbmV4dEZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZCh0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA+IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Rmlyc3RQb3NpdGlvbiAtIGZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuYmVmb3JlKHRoaXMuI3Jlc2l6ZXJzRGl2Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbaSsrXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KGBwZGZqcy1lZGl0b3ItcmVzaXplci1sYWJlbC0ke25hbWV9YCkudGhlbihtc2cgPT4gY2hpbGQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KDApO1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IHRydWU7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRydWVcbiAgICB9KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG4gICNyZXNpemVyS2V5ZG93bihldmVudCkge1xuICAgIEFubm90YXRpb25FZGl0b3IuX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgI3Jlc2l6ZXJCbHVyKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCAmJiBldmVudC5yZWxhdGVkVGFyZ2V0Py5wYXJlbnROb2RlICE9PSB0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgfVxuICB9XG4gICNyZXNpemVyRm9jdXMobmFtZSkge1xuICAgIHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSA9IHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA/IG5hbWUgOiBcIlwiO1xuICB9XG4gICNzZXRSZXNpemVyVGFiSW5kZXgodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICBkaXYudGFiSW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZVdpdGhLZXlib2FyZCh4LCB5KSB7XG4gICAgaWYgKCF0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlKHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSwge1xuICAgICAgbW92ZW1lbnRYOiB4LFxuICAgICAgbW92ZW1lbnRZOiB5XG4gICAgfSk7XG4gIH1cbiAgI3N0b3BSZXNpemluZygpIHtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoLTEpO1xuICAgIGlmICh0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2F2ZWRYLFxuICAgICAgICBzYXZlZFksXG4gICAgICAgIHNhdmVkV2lkdGgsXG4gICAgICAgIHNhdmVkSGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jc2F2ZWREaW1lbnNpb25zO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAoIXRoaXMuI2VkaXRUb29sYmFyKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIikpIHtcbiAgICAgICAgICB0aGlzLiNlZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuI2VkaXRUb29sYmFyPy5oaWRlKCk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHt9XG4gIGVuYWJsZUVkaXRpbmcoKSB7fVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXRJbWFnZUZvckFsdFRleHQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBpc0VkaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRWRpdGluZztcbiAgfVxuICBzZXQgaXNFZGl0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNFZGl0aW5nID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLiNrZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICBzdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgfVxuICBzdGF0aWMgZ2V0IE1JTl9TSVpFKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4XG4gICAgfTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE91dGxpbmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBPdXRsaW5lcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuY2xhc3MgT3V0bGluZXIge1xuICAjYm94O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDIpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5Mik7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1heFggLSBtaW5YICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSBtYXhZIC0gbWluWSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pblggLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWSA9IG1pblkgLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0ge1xuICAgICAgeDogc2hpZnRlZE1pblgsXG4gICAgICB5OiBzaGlmdGVkTWluWSxcbiAgICAgIHdpZHRoOiBiYm94V2lkdGgsXG4gICAgICBoZWlnaHQ6IGJib3hIZWlnaHQsXG4gICAgICBsYXN0UG9pbnRcbiAgICB9O1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0gfHwgYVsyXSAtIGJbMl0pO1xuICAgIGNvbnN0IG91dGxpbmVWZXJ0aWNhbEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGlmIChlZGdlWzNdKSB7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgICAgdGhpcy4jaW5zZXJ0KGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcmVtb3ZlKGVkZ2UpO1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcyk7XG4gIH1cbiAgI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBjb25zdCBhbGxFZGdlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VzLnB1c2goW3gsIHkxLCBlZGdlXSwgW3gsIHkyLCBlZGdlXSk7XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdIHx8IGFbMF0gLSBiWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlZGdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBlZGdlMSA9IGVkZ2VzW2ldWzJdO1xuICAgICAgY29uc3QgZWRnZTIgPSBlZGdlc1tpICsgMV1bMl07XG4gICAgICBlZGdlMS5wdXNoKGVkZ2UyKTtcbiAgICAgIGVkZ2UyLnB1c2goZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMik7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgbGV0IG91dGxpbmU7XG4gICAgd2hpbGUgKGFsbEVkZ2VzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlZGdlID0gYWxsRWRnZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgbGV0IFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlZGdlO1xuICAgICAgYWxsRWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgbGV0IGxhc3RQb2ludFggPSB4O1xuICAgICAgbGV0IGxhc3RQb2ludFkgPSB5MTtcbiAgICAgIG91dGxpbmUgPSBbeCwgeTJdO1xuICAgICAgb3V0bGluZXMucHVzaChvdXRsaW5lKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UxKSkge1xuICAgICAgICAgIGUgPSBlZGdlMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxFZGdlcy5oYXMoZWRnZTIpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlKTtcbiAgICAgICAgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGU7XG4gICAgICAgIGlmIChsYXN0UG9pbnRYICE9PSB4KSB7XG4gICAgICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFksIHgsIGxhc3RQb2ludFkgPT09IHkxID8geTEgOiB5Mik7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IGxhc3RQb2ludFkgPT09IHkxID8geTIgOiB5MTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmVzLFxuICAgICAgYm94OiB0aGlzLiNib3hcbiAgICB9O1xuICB9XG4gICNiaW5hcnlTZWFyY2goeSkge1xuICAgIGNvbnN0IGFycmF5ID0gdGhpcy4jaW50ZXJ2YWxzO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4gMTtcbiAgICAgIGNvbnN0IHkxID0gYXJyYXlbbWlkZGxlXVswXTtcbiAgICAgIGlmICh5MSA9PT0geSkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfVxuICAgICAgaWYgKHkxIDwgeSkge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kICsgMTtcbiAgfVxuICAjaW5zZXJ0KFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMCwgW3kxLCB5Ml0pO1xuICB9XG4gICNyZW1vdmUoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLiNpbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNicmVha0VkZ2UoZWRnZSkge1xuICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICBjb25zdCByZXN1bHRzID0gW1t4LCB5MSwgeTJdXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5Mik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSByZXN1bHRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgY29uc3QgWywgeTMsIHk0XSA9IHJlc3VsdHNbal07XG4gICAgICAgIGlmIChlbmQgPD0geTMgfHwgeTQgPD0gc3RhcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeTMgPj0gc3RhcnQpIHtcbiAgICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbal1bMV0gPSBlbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChqaiA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIGpqLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHNbal1bMl0gPSBzdGFydDtcbiAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFt4LCBlbmQsIHk0XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODEyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JNYW5hZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvck1hbmFnZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBLZXlib2FyZE1hbmFnZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIEtleWJvYXJkTWFuYWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGJpbmRFdmVudHM6ICgpID0+ICgvKiBiaW5kaW5nICovIGJpbmRFdmVudHMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBvcGFjaXR5VG9IZXg6ICgpID0+ICgvKiBiaW5kaW5nICovIG9wYWNpdHlUb0hleClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IENvbW1hbmRNYW5hZ2VyICovXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDczKTtcblxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzKG9iaiwgZWxlbWVudCwgbmFtZXMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIG9ialtuYW1lXS5iaW5kKG9iaikpO1xuICB9XG59XG5mdW5jdGlvbiBvcGFjaXR5VG9IZXgob3BhY2l0eSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1pbigyNTUsIE1hdGgubWF4KDEsIDI1NSAqIG9wYWNpdHkpKSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmNsYXNzIElkTWFuYWdlciB7XG4gICNpZCA9IDA7XG4gIGdldElkKCkge1xuICAgIHJldHVybiBgJHtfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0VXVpZCkoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGltYWdlID0gYXdhaXQgKDAsX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5mZXRjaERhdGEpKHJhd0RhdGEsIFwiYmxvYlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICBjb25zdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlID0gSW1hZ2VNYW5hZ2VyLl9pc1NWR0ZpdHRpbmdDYW52YXM7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJpdG1hcCA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuaXNTdmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnN2Z1VybCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IChhd2FpdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlKSA/IGAke3VybH0jc3ZnVmlldyhwcmVzZXJ2ZUFzcGVjdFJhdGlvKG5vbmUpKWAgOiB1cmw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZpbGVSZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZSk7XG4gICAgICAgIGF3YWl0IGltYWdlUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgfVxuICAgICAgZGF0YS5yZWZDb3VudGVyID0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIGRhdGEpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGFzeW5jIGdldEZyb21GaWxlKGZpbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lLFxuICAgICAgc2l6ZSxcbiAgICAgIHR5cGVcbiAgICB9ID0gZmlsZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGAke2xhc3RNb2RpZmllZH1fJHtuYW1lfV8ke3NpemV9XyR7dHlwZX1gLCBmaWxlKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLiNnZXQodXJsLCB1cmwpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIG11c3RFeGVjLFxuICAgIHR5cGUgPSBOYU4sXG4gICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgIGtlZXBVbmRvID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZSA9IHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLmNtZCgpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWFuZHMgPSBudWxsO1xuICB9XG59XG5jbGFzcyBLZXlib2FyZE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWxsS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIFswLCAwLCAwXV0sIFtcIkNhbnZhc1wiLCBbMjU1LCAyNTUsIDI1NV1dXSk7XG4gIGdldCBfY29sb3JzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgbnVsbF0sIFtcIkNhbnZhc1wiLCBudWxsXV0pO1xuICAgICgwLF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZ2V0Q29sb3JWYWx1ZXMpKGNvbG9ycyk7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9ICgwLF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZ2V0UkdCKShjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAjZWRpdG9yVHlwZXMgPSBudWxsO1xuICAjZWRpdG9yc1RvUmVzY2FsZSA9IG5ldyBTZXQoKTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgI2hpZ2hsaWdodENvbG9ycyA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgI21vZGUgPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjcGFnZUNvbG9ycyA9IG51bGw7XG4gICNib3VuZEJsdXIgPSB0aGlzLmJsdXIuYmluZCh0aGlzKTtcbiAgI2JvdW5kRm9jdXMgPSB0aGlzLmZvY3VzLmJpbmQodGhpcyk7XG4gICNib3VuZENvcHkgPSB0aGlzLmNvcHkuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ3V0ID0gdGhpcy5jdXQuYmluZCh0aGlzKTtcbiAgI2JvdW5kUGFzdGUgPSB0aGlzLnBhc3RlLmJpbmQodGhpcyk7XG4gICNib3VuZEtleWRvd24gPSB0aGlzLmtleWRvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25FZGl0aW5nQWN0aW9uID0gdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25QYWdlQ2hhbmdpbmcgPSB0aGlzLm9uUGFnZUNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNib3VuZE9uU2NhbGVDaGFuZ2luZyA9IHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNib3VuZE9uUm90YXRpb25DaGFuZ2luZyA9IHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICB9O1xuICAjdHJhbnNsYXRpb24gPSBbMCwgMF07XG4gICN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjdmlld2VyID0gbnVsbDtcbiAgc3RhdGljIFRSQU5TTEFURV9TTUFMTCA9IDE7XG4gIHN0YXRpYyBUUkFOU0xBVEVfQklHID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4ge1xuICAgICAgcmV0dXJuIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgIT09IFwiQlVUVE9OXCIgJiYgc2VsZi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICB9O1xuICAgIGNvbnN0IHRleHRJbnB1dENoZWNrZXIgPSAoX3NlbGYsIHtcbiAgICAgIHRhcmdldDogZWxcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBlbDtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09IFwidGV4dFwiICYmIHR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHNtYWxsID0gdGhpcy5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdGhpcy5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGUsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkVudGVyXCIsIFwibWFjK0VudGVyXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGVsKSAmJiAhc2VsZi5pc0VudGVySGFuZGxlZFxuICAgIH1dLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IHNlbGYgPT4gc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCBhbHRUZXh0TWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzLCBoaWdobGlnaHRDb2xvcnMpIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdmlld2VyID0gdmlld2VyO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyID0gYWx0VGV4dE1hbmFnZXI7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblBhZ2VDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uU2NhbGVDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUm90YXRpb25DaGFuZ2luZyk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPSBoaWdobGlnaHRDb2xvcnMgfHwgbnVsbDtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25TY2FsZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUm90YXRpb25DaGFuZ2luZyk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwiaGNtRmlsdGVyXCIsIHRoaXMuI3BhZ2VDb2xvcnMgPyB0aGlzLiNmaWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLiNwYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMuI3BhZ2VDb2xvcnMuYmFja2dyb3VuZCkgOiBcIm5vbmVcIik7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc2hhZG93KSh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JzKCkge1xuICAgIHJldHVybiAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zaGFkb3cpKHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAodGhpcy4jaGlnaGxpZ2h0Q29sb3JzLnNwbGl0KFwiLFwiKS5tYXAocGFpciA9PiBwYWlyLnNwbGl0KFwiPVwiKS5tYXAoeCA9PiB4LnRyaW0oKSkpKSA6IG51bGwpO1xuICB9XG4gIHNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvcikge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IpO1xuICB9XG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cbiAgZm9jdXNNYWluQ29udGFpbmVyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5mb2N1cygpO1xuICB9XG4gIGZpbmRQYXJlbnQoeCwgeSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxheWVyWCxcbiAgICAgICAgeTogbGF5ZXJZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gbGF5ZXIuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHggPj0gbGF5ZXJYICYmIHggPD0gbGF5ZXJYICsgd2lkdGggJiYgeSA+PSBsYXllclkgJiYgeSA8PSBsYXllclkgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkaXNhYmxlVXNlclNlbGVjdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKHtcbiAgICBzY2FsZVxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlID0gc2NhbGUgKiBfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICB9XG4gIG9uUm90YXRpb25DaGFuZ2luZyh7XG4gICAgcGFnZXNSb3RhdGlvblxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucm90YXRpb24gPSBwYWdlc1JvdGF0aW9uO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRGb2N1cyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kQmx1cik7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRm9jdXMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEJsdXIpO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5ZG93bik7XG4gIH1cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlkb3duKTtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuI2JvdW5kQ29weSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLiNib3VuZEN1dCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuI2JvdW5kUGFzdGUpO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy4jYm91bmRDb3B5KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuI2JvdW5kQ3V0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy4jYm91bmRQYXN0ZSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKGRldGFpbHMpIHtcbiAgICBpZiAoW1widW5kb1wiLCBcInJlZG9cIiwgXCJkZWxldGVcIiwgXCJzZWxlY3RBbGxcIl0uaW5jbHVkZXMoZGV0YWlscy5uYW1lKSkge1xuICAgICAgdGhpc1tkZXRhaWxzLm5hbWVdKCk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSwgZWRpdElkID0gbnVsbCwgaXNGcm9tS2V5Ym9hcmQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQgJiYgaXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMYXllci5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy51cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JzO1xuICB9XG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cbiAgYWRkRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgfVxuICByZW1vdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c01haW5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBmb3IgKGNvbnN0IGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkICE9PSBlZGl0b3IpIHtcbiAgICAgICAgZWQudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG4gIGdldCBmaXJzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSAhPT0gMDtcbiAgfVxuICBnZXQgaXNFbnRlckhhbmRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5pc0VudGVySGFuZGxlZDtcbiAgfVxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5yZWRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmFkZChwYXJhbXMpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb0NvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciB8fCB0aGlzLmhhc1NlbGVjdGlvbjtcbiAgfVxuICAjc2VsZWN0RWRpdG9ycyhlZGl0b3JzKSB7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJpbWFnZU1hbmFnZXJcIiwgbmV3IEltYWdlTWFuYWdlcigpKTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBERkZldGNoU3RyZWFtOiAoKSA9PiAoLyogYmluZGluZyAqLyBQREZGZXRjaFN0cmVhbSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9uZXR3b3JrX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1Myk7XG5cblxuO1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbHVlID0gaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaGVhZGVycy5hcHBlbmQocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB2YWwuYnVmZmVyO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBzb3VyY2UuaHR0cEhlYWRlcnMgfHwge307XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX3N0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5faGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnModGhpcy5faGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmICghKDAsX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLF9uZXR3b3JrX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc0Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9udEZhY2VPYmplY3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIEZvbnRGYWNlT2JqZWN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9udExvYWRlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9udExvYWRlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuXG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvLFxuICAgIF9pbnNwZWN0Rm9udFxuICB9KSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkoIXRoaXMuZGlzYWJsZUZvbnRGYWNlLCBcImxvYWRTeXN0ZW1Gb250IHNob3VsZG4ndCBiZSBjYWxsZWQgd2hlbiBgZGlzYWJsZUZvbnRGYWNlYCBpcyBzZXQuXCIpO1xuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG9hZGVkTmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGluZm87XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShsb2FkZWROYW1lLCBzcmMsIHN0eWxlKTtcbiAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgICB0aGlzLiNzeXN0ZW1Gb250cy5hZGQobG9hZGVkTmFtZSk7XG4gICAgICAgIF9pbnNwZWN0Rm9udD8uKGluZm8pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoXCJOb3QgaW1wbGVtZW50ZWQ6IGxvYWRTeXN0ZW1Gb250IHdpdGhvdXQgdGhlIEZvbnQgTG9hZGluZyBBUEkuXCIpO1xuICB9XG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUgJiYgIWZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG4gICAgaWYgKGZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZFN5c3RlbUZvbnQoZm9udCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5hdGl2ZUZvbnRGYWNlLmxvYWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy53YXJuKShgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIGlmIChfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc05vZGVKUykge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8udXNlckFnZW50ID09PSBcInN0cmluZ1wiICYmIC9Nb3ppbGxhXFwvNS4wLio/cnY6XFxkKy4qPyBHZWNrby8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnNoYWRvdykodGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBzdXBwb3J0ZWQpO1xuICB9XG4gIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc2hhZG93KSh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoXCJMb2FkIHRlc3QgZm9udCBuZXZlciBsb2FkZWQuXCIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IFwiMzBweCBcIiArIG5hbWU7XG4gICAgICBjdHguZmlsbFRleHQoXCIuXCIsIDAsIDIwKTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbM10gPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoaXNGb250UmVhZHkuYmluZChudWxsLCBuYW1lLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkVGVzdEZvbnRJZCA9IGBsdCR7RGF0ZS5ub3coKX0ke3RoaXMubG9hZFRlc3RGb250SWQrK31gO1xuICAgIGxldCBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgIGNvbnN0IENGRl9DSEVDS1NVTV9PRkZTRVQgPSAxNjtcbiAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICBsZXQgY2hlY2tzdW0gPSBpbnQzMihkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUKTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgfVxuICAgIGlmIChpIDwgbG9hZFRlc3RGb250SWQubGVuZ3RoKSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkICsgXCJYWFhcIiwgaSkgfCAwO1xuICAgIH1cbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnN0cmluZzMyKShjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCB7XG4gICAgaXNFdmFsU3VwcG9ydGVkID0gdHJ1ZSxcbiAgICBkaXNhYmxlRm9udEZhY2UgPSBmYWxzZSxcbiAgICBpZ25vcmVFcnJvcnMgPSBmYWxzZSxcbiAgICBpbnNwZWN0Rm9udCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cbiAgICB0aGlzLmlzRXZhbFN1cHBvcnRlZCA9IGlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRm9udEZhY2UgPSBkaXNhYmxlRm9udEZhY2UgPT09IHRydWU7XG4gICAgdGhpcy5pZ25vcmVFcnJvcnMgPSBpZ25vcmVFcnJvcnMgPT09IHRydWU7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYnl0ZXNUb1N0cmluZykodGhpcy5kYXRhKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBsZXQgcnVsZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMubG9hZGVkTmFtZX1cIjtzcmM6JHt1cmx9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjc3MgPSBgZm9udC13ZWlnaHQ6ICR7dGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0fTtgO1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzICs9IGBmb250LXN0eWxlOiBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWc7YDtcbiAgICAgIH1cbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseX1cIjske2Nzc31zcmM6JHt1cmx9fWA7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcywgdXJsKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXTtcbiAgICB9XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldCh0aGlzLmxvYWRlZE5hbWUgKyBcIl9wYXRoX1wiICsgY2hhcmFjdGVyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKCF0aGlzLmlnbm9yZUVycm9ycykge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0V2YWxTdXBwb3J0ZWQgJiYgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRmVhdHVyZVRlc3QuaXNFdmFsU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBqc0J1ZiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50IG9mIGNtZHMpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGN1cnJlbnQuYXJncyAhPT0gdW5kZWZpbmVkID8gY3VycmVudC5hcmdzLmpvaW4oXCIsXCIpIDogXCJcIjtcbiAgICAgICAganNCdWYucHVzaChcImMuXCIsIGN1cnJlbnQuY21kLCBcIihcIiwgYXJncywgXCIpO1xcblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqc0J1Zi5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgY21kcykge1xuICAgICAgICBpZiAoY3VycmVudC5jbWQgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgIGN1cnJlbnQuYXJncyA9IFtzaXplLCAtc2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgY1tjdXJyZW50LmNtZF0uYXBwbHkoYywgY3VycmVudC5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWV0YWRhdGE6ICgpID0+ICgvKiBiaW5kaW5nICovIE1ldGFkYXRhKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG5cbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21ldGFkYXRhTWFwO1xuICAjZGF0YTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcnNlZERhdGEsXG4gICAgcmF3RGF0YVxuICB9KSB7XG4gICAgdGhpcy4jbWV0YWRhdGFNYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9iamVjdEZyb21NYXApKHRoaXMuI21ldGFkYXRhTWFwKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBQREZOZXR3b3JrU3RyZWFtOiAoKSA9PiAoLyogYmluZGluZyAqLyBQREZOZXR3b3JrU3RyZWFtKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUzKTtcblxuXG47XG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc3RyaW5nVG9CeXRlcykoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGFyZ3MgPSB7fSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBhcmdzLmh0dHBIZWFkZXJzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgYmVnaW4sXG4gICAgICBlbmRcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGFyZ3NbcHJvcF0gPSBsaXN0ZW5lcnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXJncyk7XG4gIH1cbiAgcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChsaXN0ZW5lcnMpO1xuICB9XG4gIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHhocklkID0gdGhpcy5jdXJyWGhySWQrKztcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXSA9IHtcbiAgICAgIHhoclxuICAgIH07XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHRoaXMuaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YXJncy5iZWdpbn0tJHthcmdzLmVuZCAtIDF9YCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBPS19SRVNQT05TRTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBpZiAoYXJncy5vbkVycm9yKSB7XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyU3RhdHVzID0geGhyLnN0YXR1cyB8fCBPS19SRVNQT05TRTtcbiAgICBjb25zdCBva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ID0geGhyU3RhdHVzID09PSBPS19SRVNQT05TRSAmJiBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIGlmICghb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCAmJiB4aHJTdGF0dXMgIT09IHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UudXJsLCB7XG4gICAgICBodHRwSGVhZGVyczogc291cmNlLmh0dHBIZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBzb3VyY2Uud2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgIHJldHVybiBmdWxsUmVxdWVzdFhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSAoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcbiAgICBpZiAodGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgfVxuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBhcmdzKTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLF9uZXR3b3JrX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjUzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3I6ICgpID0+ICgvKiBiaW5kaW5nICovIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpLFxuICBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKSxcbiAgdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXM6ICgpID0+ICgvKiBiaW5kaW5nICovIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSxcbiAgdmFsaWRhdGVSZXNwb25zZVN0YXR1czogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFsaWRhdGVSZXNwb25zZVN0YXR1cylcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NoYXJlZC91dGlsLmpzXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L2NvbnRlbnRfZGlzcG9zaXRpb24uanNcblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsdXRpbC5zdHJpbmdUb0J5dGVzKSh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG52YXIgZGlzcGxheV91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDczKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kaXNwbGF5L25ldHdvcmtfdXRpbHMuanNcblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuc3VnZ2VzdGVkTGVuZ3RoID0gbGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLmFsbG93UmFuZ2VSZXF1ZXN0cyA9IHRydWU7XG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKGdldFJlc3BvbnNlSGVhZGVyKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKCgwLGRpc3BsYXlfdXRpbHMuaXNQZGZGaWxlKShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdXJsKSB7XG4gIGlmIChzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyB1dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTg6XG4vKioqLyAoKF9fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmEoX193ZWJwYWNrX21vZHVsZV9fLCBhc3luYyAoX193ZWJwYWNrX2hhbmRsZV9hc3luY19kZXBlbmRlbmNpZXNfXywgX193ZWJwYWNrX2FzeW5jX3Jlc3VsdF9fKSA9PiB7IHRyeSB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBQREZOb2RlU3RyZWFtOiAoKSA9PiAoLyogYmluZGluZyAqLyBQREZOb2RlU3RyZWFtKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUzKTtcblxuXG47XG5sZXQgZnMsIGh0dHAsIGh0dHBzLCB1cmw7XG5pZiAoX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNOb2RlSlMpIHtcbiAgZnMgPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyBcImZzXCIpO1xuICBodHRwID0gYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gXCJodHRwXCIpO1xuICBodHRwcyA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIFwiaHR0cHNcIik7XG4gIHVybCA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIFwidXJsXCIpO1xufVxuY29uc3QgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5mdW5jdGlvbiBwYXJzZVVybChzb3VyY2VVcmwpIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cbiAgaWYgKC9eW2Etel06Wy9cXFxcXS9pLnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiB1cmwucGFyc2UoYGZpbGU6Ly8vJHtzb3VyY2VVcmx9YCk7XG4gIH1cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCkge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9IFwiZmlsZTpcIjtcbiAgfVxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpIDogbmV3IFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKSA6IG5ldyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2Vycm9yKG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5BYm9ydEV4Y2VwdGlvbihcInN0cmVhbWluZyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdE9wdGlvbnMocGFyc2VkVXJsLCBoZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHBhcnNlZFVybC5wcm90b2NvbCxcbiAgICBhdXRoOiBwYXJzZWRVcmwuYXV0aCxcbiAgICBob3N0OiBwYXJzZWRVcmwuaG9zdG5hbWUsXG4gICAgcG9ydDogcGFyc2VkVXJsLnBvcnQsXG4gICAgcGF0aDogcGFyc2VkVXJsLnBhdGgsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnNcbiAgfTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdHJlYW0uaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCxfbmV0d29ya191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsX25ldHdvcmtfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgc3RyZWFtLmh0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICB0aGlzLl9odHRwSGVhZGVycyA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc3RyZWFtLmh0dHBIZWFkZXJzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHN0cmVhbS5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2h0dHBIZWFkZXJzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLl9odHRwSGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZCAtIDF9YDtcbiAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciBleHRlbmRzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cbiAgICBmcy5sc3RhdChwYXRoLCAoZXJyb3IsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgIGVycm9yID0gbmV3IF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHtwYXRofVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VybC5wYXRoKTtcbiAgICBpZiAoZmlsZVVyaVJlZ2V4LnRlc3QodGhpcy5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbn1cblxuX193ZWJwYWNrX2FzeW5jX3Jlc3VsdF9fKCk7XG59IGNhdGNoKGUpIHsgX193ZWJwYWNrX2FzeW5jX3Jlc3VsdF9fKGUpOyB9IH0sIDEpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzM4OlxuLyoqKi8gKChfX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5hKF9fd2VicGFja19tb2R1bGVfXywgYXN5bmMgKF9fd2VicGFja19oYW5kbGVfYXN5bmNfZGVwZW5kZW5jaWVzX18sIF9fd2VicGFja19hc3luY19yZXN1bHRfXykgPT4geyB0cnkge1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTm9kZUNNYXBSZWFkZXJGYWN0b3J5OiAoKSA9PiAoLyogYmluZGluZyAqLyBOb2RlQ01hcFJlYWRlckZhY3RvcnkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBOb2RlQ2FudmFzRmFjdG9yeTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTm9kZUNhbnZhc0ZhY3RvcnkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBOb2RlRmlsdGVyRmFjdG9yeTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTm9kZUZpbHRlckZhY3RvcnkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk6ICgpID0+ICgvKiBiaW5kaW5nICovIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcblxuXG47XG5sZXQgZnMsIGNhbnZhcywgcGF0aDJkX3BvbHlmaWxsO1xuaWYgKF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmlzTm9kZUpTKSB7XG4gIGZzID0gYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gXCJmc1wiKTtcbiAgdHJ5IHtcbiAgICBjYW52YXMgPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyBcImNhbnZhc1wiKTtcbiAgfSBjYXRjaCB7fVxuICB0cnkge1xuICAgIHBhdGgyZF9wb2x5ZmlsbCA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIFwicGF0aDJkLXBvbHlmaWxsXCIpO1xuICB9IGNhdGNoIHt9XG59XG47XG5jb25zdCBmZXRjaERhdGEgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZEZpbGUodXJsLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5jbGFzcyBOb2RlRmlsdGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNNYXBEYXRhOiBkYXRhLFxuICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsKTtcbiAgfVxufVxuXG5fX3dlYnBhY2tfYXN5bmNfcmVzdWx0X18oKTtcbn0gY2F0Y2goZSkgeyBfX3dlYnBhY2tfYXN5bmNfcmVzdWx0X18oZSk7IH0gfSwgMSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE9wdGlvbmFsQ29udGVudENvbmZpZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gT3B0aW9uYWxDb250ZW50Q29uZmlnKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF9tdXJtdXJoYXNoM19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjUpO1xuXG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IobmFtZSwgaW50ZW50KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnVucmVhY2hhYmxlKShcIkludGVybmFsIG1ldGhvZCBgX3NldFZpc2libGVgIGNhbGxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG59XG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICAjY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gICNncm91cHMgPSBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKGdyb3VwLm5hbWUsIGdyb3VwLmludGVudCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZGVmaW5lZC5cIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ud2FybikoYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3JvdXBzLmdldChpZCkuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuc2l6ZSA+IDAgPyAoMCxfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vYmplY3RGcm9tTWFwKSh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IF9zaGFyZWRfbXVybXVyaGFzaDNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5NdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzM5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICByZW5kZXJUZXh0TGF5ZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbmRlclRleHRMYXllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVwZGF0ZVRleHRMYXllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdXBkYXRlVGV4dExheWVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgVGV4dExheWVyUmVuZGVyVGFzayAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3Myk7XG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNvbnN0IGFzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q3R4KHNpemUsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGxldCBjdHg7XG4gIGlmIChpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCAmJiBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGN0eCA9IG5ldyBPZmZzY3JlZW5DYW52YXMoc2l6ZSwgc2l6ZSkuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gZ2V0QXNjZW50KGZvbnRGYW1pbHksIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGNvbnN0IGNhY2hlZEFzY2VudCA9IGFzY2VudENhY2hlLmdldChmb250RmFtaWx5KTtcbiAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gIH1cbiAgY29uc3QgY3R4ID0gZ2V0Q3R4KERFRkFVTFRfRk9OVF9TSVpFLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gIGN0eC5mb250ID0gYCR7REVGQVVMVF9GT05UX1NJWkV9cHggJHtmb250RmFtaWx5fWA7XG4gIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gIGxldCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICBpZiAoYXNjZW50KSB7XG4gICAgY29uc3QgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgbGV0IHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBkZXNjZW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgZGVzY2VudCA9IE1hdGguY2VpbChpIC8gNCAvIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiQVwiLCAwLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBhc2NlbnQgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCBERUZBVUxUX0ZPTlRfQVNDRU5UKTtcbiAgcmV0dXJuIERFRkFVTFRfRk9OVF9BU0NFTlQ7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRhc2ssIGdlb20sIHN0eWxlcykge1xuICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgIGFuZ2xlOiAwLFxuICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgIGhhc0VPTDogZ2VvbS5oYXNFT0wsXG4gICAgZm9udFNpemU6IDBcbiAgfTtcbiAgdGFzay5fdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcbiAgY29uc3QgdHggPSBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5VdGlsLnRyYW5zZm9ybSh0YXNrLl90cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICBjb25zdCBzdHlsZSA9IHN0eWxlc1tnZW9tLmZvbnROYW1lXTtcbiAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gIH1cbiAgY29uc3QgZm9udEZhbWlseSA9IHRhc2suX2ZvbnRJbnNwZWN0b3JFbmFibGVkICYmIHN0eWxlLmZvbnRTdWJzdGl0dXRpb24gfHwgc3R5bGUuZm9udEZhbWlseTtcbiAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBnZXRBc2NlbnQoZm9udEZhbWlseSwgdGFzay5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICBsZXQgbGVmdCwgdG9wO1xuICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICBsZWZ0ID0gdHhbNF07XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICB9XG4gIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXNjYWxlLWZhY3RvcikqXCI7XG4gIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgaWYgKHRhc2suX2NvbnRhaW5lciA9PT0gdGFzay5fcm9vdENvbnRhaW5lcikge1xuICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRhc2suX3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGFzay5fcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgfSBlbHNlIHtcbiAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gIH1cbiAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2ZvbnRIZWlnaHQudG9GaXhlZCgyKX1weClgO1xuICBkaXZTdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgaWYgKHRhc2suX2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gc3R5bGUuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUgfHwgZ2VvbS5mb250TmFtZTtcbiAgfVxuICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gIH1cbiAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgaWYgKHRhc2suX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICB9XG59XG5mdW5jdGlvbiBsYXlvdXQocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBkaXYsXG4gICAgc2NhbGUsXG4gICAgcHJvcGVydGllcyxcbiAgICBjdHgsXG4gICAgcHJldkZvbnRTaXplLFxuICAgIHByZXZGb250RmFtaWx5XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHtcbiAgICBzdHlsZVxuICB9ID0gZGl2O1xuICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udEZhbWlseVxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNXaWR0aCxcbiAgICAgIGZvbnRTaXplXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKHByZXZGb250U2l6ZSAhPT0gZm9udFNpemUgfHwgcHJldkZvbnRGYW1pbHkgIT09IGZvbnRGYW1pbHkpIHtcbiAgICAgIGN0eC5mb250ID0gYCR7Zm9udFNpemUgKiBzY2FsZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHNjYWxlIC8gd2lkdGh9KWA7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICB9XG4gIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgaWYgKHRhc2suX2NhbmNlbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRleHREaXZzID0gdGFzay5fdGV4dERpdnM7XG4gIGNvbnN0IGNhcGFiaWxpdHkgPSB0YXNrLl9jYXBhYmlsaXR5O1xuICBjb25zdCB0ZXh0RGl2c0xlbmd0aCA9IHRleHREaXZzLmxlbmd0aDtcbiAgaWYgKHRleHREaXZzTGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0YXNrLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgZm9yIChjb25zdCB0ZXh0RGl2IG9mIHRleHREaXZzKSB7XG4gICAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICAgIH1cbiAgfVxuICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbn1cbmNsYXNzIFRleHRMYXllclJlbmRlclRhc2sge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGV4dENvbnRlbnRTb3VyY2UsXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0LFxuICAgIHRleHREaXZzLFxuICAgIHRleHREaXZQcm9wZXJ0aWVzLFxuICAgIHRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcbiAgfSkge1xuICAgIHRoaXMuX3RleHRDb250ZW50U291cmNlID0gdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgdGhpcy5faXNSZWFkYWJsZVN0cmVhbSA9IHRleHRDb250ZW50U291cmNlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG4gICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl90ZXh0RGl2cyA9IHRleHREaXZzIHx8IFtdO1xuICAgIHRoaXMuX3RleHRDb250ZW50SXRlbXNTdHIgPSB0ZXh0Q29udGVudEl0ZW1zU3RyIHx8IFtdO1xuICAgIHRoaXMuX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ7XG4gICAgdGhpcy5fZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXMgfHwgbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgcHJldkZvbnRTaXplOiBudWxsLFxuICAgICAgcHJldkZvbnRGYW1pbHk6IG51bGwsXG4gICAgICBkaXY6IG51bGwsXG4gICAgICBzY2FsZTogdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogZ2V0Q3R4KDAsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLl9wYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy5fcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgKDAsX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zZXRMYXllckRpbWVuc2lvbnMpKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdChuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKTtcbiAgfVxuICBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS5zdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFByb3BzXCIgfHwgaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFya2VkQ29udGVudFwiKTtcbiAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2l0ZW0uaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLl90ZXh0Q29udGVudEl0ZW1zU3RyLnB1c2goaXRlbS5zdHIpO1xuICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtLCBzdHlsZUNhY2hlKTtcbiAgICB9XG4gIH1cbiAgX2xheW91dFRleHQodGV4dERpdikge1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICBsYXlvdXQodGhpcy5fbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyKCkge1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICBsZXQgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKHRoaXMuX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcywgc3R5bGVDYWNoZSk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCBjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcmVhZGVyID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2UuZ2V0UmVhZGVyKCk7XG4gICAgICBwdW1wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90ZXh0Q29udGVudFNvdXJjZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgc3R5bGVzXG4gICAgICB9ID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgICB0aGlzLl9wcm9jZXNzSXRlbXMoaXRlbXMsIHN0eWxlcyk7XG4gICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInRleHRDb250ZW50U291cmNlXCIgcGFyYW1ldGVyIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgICByZW5kZXIodGhpcyk7XG4gICAgfSwgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXIocGFyYW1zKSB7XG4gIGNvbnN0IHRhc2sgPSBuZXcgVGV4dExheWVyUmVuZGVyVGFzayhwYXJhbXMpO1xuICB0YXNrLl9yZW5kZXIoKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5mdW5jdGlvbiB1cGRhdGVUZXh0TGF5ZXIoe1xuICBjb250YWluZXIsXG4gIHZpZXdwb3J0LFxuICB0ZXh0RGl2cyxcbiAgdGV4dERpdlByb3BlcnRpZXMsXG4gIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICBtdXN0Um90YXRlID0gdHJ1ZSxcbiAgbXVzdFJlc2NhbGUgPSB0cnVlXG59KSB7XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgKDAsX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zZXRMYXllckRpbWVuc2lvbnMpKGNvbnRhaW5lciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gIH1cbiAgaWYgKG11c3RSZXNjYWxlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q3R4KDAsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKTtcbiAgICBjb25zdCBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBwcmV2Rm9udFNpemU6IG51bGwsXG4gICAgICBwcmV2Rm9udEZhbWlseTogbnVsbCxcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHNjYWxlLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGV4dERpdnMpIHtcbiAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG4gICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgbGF5b3V0KHBhcmFtcyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBQREZEYXRhVHJhbnNwb3J0U3RyZWFtOiAoKSA9PiAoLyogYmluZGluZyAqLyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDczKTtcblxuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGxlbmd0aCxcbiAgICBpbml0aWFsRGF0YSxcbiAgICBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwsXG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0sIHBkZkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgICgwLF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICBjb25zdCBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIodGhpcywgcXVldWVkQ2h1bmtzLCB0aGlzLl9wcm9ncmVzc2l2ZURvbmUsIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKTtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9ICgwLF9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uaXNQZGZGaWxlKShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNjg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEdsb2JhbFdvcmtlck9wdGlvbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIEdsb2JhbFdvcmtlck9wdGlvbnMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0ID0gbnVsbDtcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gXCJcIjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTYwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBYZmFMYXllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gWGZhTGF5ZXIpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfeGZhX3RleHRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIxKTtcblxuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIF94ZmFfdGV4dF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBfeGZhX3RleHRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5YZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFhmYVRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFhmYVRleHQpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbmNsYXNzIFhmYVRleHQge1xuICBzdGF0aWMgdGV4dENvbnRlbnQoeGZhKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBpdGVtcyxcbiAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0ciA9IG51bGw7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICghWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChub2RlPy5hdHRyaWJ1dGVzPy50ZXh0Q29udGVudCkge1xuICAgICAgICBzdHIgPSBub2RlLmF0dHJpYnV0ZXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgc3RyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2Fsayh4ZmEpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZEJ1aWxkVGV4dChuYW1lKSB7XG4gICAgcmV0dXJuICEobmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcIm9wdGlvblwiIHx8IG5hbWUgPT09IFwic2VsZWN0XCIpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwNzpcbi8qKiovICgoX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18uYShfX3dlYnBhY2tfbW9kdWxlX18sIGFzeW5jIChfX3dlYnBhY2tfaGFuZGxlX2FzeW5jX2RlcGVuZGVuY2llc19fLCBfX3dlYnBhY2tfYXN5bmNfcmVzdWx0X18pID0+IHsgdHJ5IHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFib3J0RXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5BYm9ydEV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRpb25FZGl0b3JMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZWRpdG9yX2Fubm90YXRpb25fZWRpdG9yX2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uQW5ub3RhdGlvbkVkaXRvckxheWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQW5ub3RhdGlvbkVkaXRvclR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkFubm90YXRpb25FZGl0b3JUeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZWRpdG9yX3Rvb2xzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRpb25MYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfYW5ub3RhdGlvbl9sYXllcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLkFubm90YXRpb25MYXllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRpb25Nb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Bbm5vdGF0aW9uTW9kZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENNYXBDb21wcmVzc2lvblR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkNNYXBDb21wcmVzc2lvblR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvclBpY2tlcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZWRpdG9yX2NvbG9yX3BpY2tlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLkNvbG9yUGlja2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRE9NU1ZHRmFjdG9yeTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkRPTVNWR0ZhY3RvcnkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEcmF3TGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9kaXNwbGF5X2RyYXdfbGF5ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5EcmF3TGF5ZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGZWF0dXJlVGVzdDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRmVhdHVyZVRlc3QpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBHbG9iYWxXb3JrZXJPcHRpb25zOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfZGlzcGxheV93b3JrZXJfb3B0aW9uc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLkdsb2JhbFdvcmtlck9wdGlvbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbWFnZUtpbmQ6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkltYWdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEludmFsaWRQREZFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkludmFsaWRQREZFeGNlcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNaXNzaW5nUERGRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5NaXNzaW5nUERGRXhjZXB0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgT1BTOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5PUFMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPdXRsaW5lcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZWRpdG9yX291dGxpbmVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLk91dGxpbmVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgUERGRGF0YVJhbmdlVHJhbnNwb3J0OiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfZGlzcGxheV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQREZEYXRlU3RyaW5nOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfZGlzcGxheV9kaXNwbGF5X3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uUERGRGF0ZVN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBERldvcmtlcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uUERGV29ya2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgUGFzc3dvcmRSZXNwb25zZXM6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlBhc3N3b3JkUmVzcG9uc2VzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgUGVybWlzc2lvbkZsYWc6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlBlcm1pc3Npb25GbGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgUGl4ZWxzUGVySW5jaDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlBpeGVsc1BlckluY2gpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQcm9taXNlQ2FwYWJpbGl0eTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9kaXNwbGF5X2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFV0aWw6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlV0aWwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBWZXJib3NpdHlMZXZlbDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVmVyYm9zaXR5TGV2ZWwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBYZmFMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfeGZhX2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fLlhmYUxheWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYnVpbGQ6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9kaXNwbGF5X2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmJ1aWxkKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGZldGNoRGF0YTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmZldGNoRGF0YSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldERvY3VtZW50OiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfZGlzcGxheV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5nZXREb2N1bWVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldEZpbGVuYW1lRnJvbVVybDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmdldEZpbGVuYW1lRnJvbVVybCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldFBkZkZpbGVuYW1lRnJvbVVybDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmdldFBkZkZpbGVuYW1lRnJvbVVybCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldFhmYVBhZ2VWaWV3cG9ydDogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmdldFhmYVBhZ2VWaWV3cG9ydCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGlzRGF0YVNjaGVtZTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmlzRGF0YVNjaGVtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGlzUGRmRmlsZTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmlzUGRmRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG5vQ29udGV4dE1lbnU6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9kaXNwbGF5X2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5ub0NvbnRleHRNZW51KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbm9ybWFsaXplVW5pY29kZTogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubm9ybWFsaXplVW5pY29kZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlbmRlclRleHRMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfdGV4dF9sYXllcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLnJlbmRlclRleHRMYXllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNldExheWVyRGltZW5zaW9uczogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLnNldExheWVyRGltZW5zaW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNoYWRvdzogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX3NoYXJlZF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc2hhZG93KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdXBkYXRlVGV4dExheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfZGlzcGxheV90ZXh0X2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18udXBkYXRlVGV4dExheWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdmVyc2lvbjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2Rpc3BsYXlfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18udmVyc2lvbilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zaGFyZWRfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDczKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzcGxheV90ZXh0X2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3BsYXlfZWRpdG9yX2Fubm90YXRpb25fZWRpdG9yX2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3BsYXlfZWRpdG9yX3Rvb2xzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3BsYXlfYW5ub3RhdGlvbl9sYXllcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X2VkaXRvcl9jb2xvcl9waWNrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X2RyYXdfbGF5ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzcGxheV93b3JrZXJfb3B0aW9uc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXNwbGF5X2VkaXRvcl9vdXRsaW5lcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzcGxheV94ZmFfbGF5ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MCk7XG52YXIgX193ZWJwYWNrX2FzeW5jX2RlcGVuZGVuY2llc19fID0gX193ZWJwYWNrX2hhbmRsZV9hc3luY19kZXBlbmRlbmNpZXNfXyhbX2Rpc3BsYXlfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19dKTtcbl9kaXNwbGF5X2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gKF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXy50aGVuID8gKGF3YWl0IF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXykoKSA6IF9fd2VicGFja19hc3luY19kZXBlbmRlbmNpZXNfXylbMF07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBwZGZqc1ZlcnNpb24gPSAnNC4wLjM3OSc7XG5jb25zdCBwZGZqc0J1aWxkID0gJzllMTRkMDRmZCc7XG5cbl9fd2VicGFja19hc3luY19yZXN1bHRfXygpO1xufSBjYXRjaChlKSB7IF9fd2VicGFja19hc3luY19yZXN1bHRfXyhlKTsgfSB9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDY5NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWVzc2FnZUhhbmRsZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE1lc3NhZ2VIYW5kbGVyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHJlYXNvbiA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwpKSB7XG4gICAgKDAsX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51bnJlYWNoYWJsZSkoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKHJlYXNvbi5uYW1lKSB7XG4gICAgY2FzZSBcIkFib3J0RXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTWlzc2luZ1BERkV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUGFzc3dvcmRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5jb2RlKTtcbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSB0aGlzLnNvdXJjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgICBjb25zdCBjYXBhYmlsaXR5ID0gdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICAgIGNvbnN0IGNiU291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZTtcbiAgICAgICAgY29uc3QgY2JUYXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zdHJlYW1JZCkge1xuICAgICAgICB0aGlzLiNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgICB9O1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSk7XG4gIH1cbiAgb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJHthY3Rpb25OYW1lfVwiYCk7XG4gICAgfVxuICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgfVxuICBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGFcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICB9XG4gIHNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IG5ldyBfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gbmV3IF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTEwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWxsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgKDAsX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGNvbnN0IGNhbmNlbENhcGFiaWxpdHkgPSBuZXcgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG4gICNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG4gICAgICAgIGlmIChsYXN0RGVzaXJlZFNpemUgPiAwICYmIHRoaXMuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSBuZXcgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICAoMCxfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBuZXcgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgb25QdWxsOiBudWxsLFxuICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICBpc0NhbmNlbGxlZDogZmFsc2UsXG4gICAgICBkZXNpcmVkU2l6ZTogZGF0YS5kZXNpcmVkU2l6ZSxcbiAgICAgIHJlYWR5OiBudWxsXG4gICAgfTtcbiAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdID0gc3RyZWFtU2luaztcbiAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhLCBzdHJlYW1TaW5rKSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgIHN0cmVhbVNpbmsgPSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTEw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vblB1bGw/LigpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgKDAsX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5hc3NlcnQpKHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgICgwLF91dGlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICAoMCxfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25DYW5jZWw/Lih3cmFwUmVhc29uKGRhdGEucmVhc29uKSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jICNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsPy5wcm9taXNlXSk7XG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTXVybXVySGFzaDNfNjQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE11cm11ckhhc2gzXzY0KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcblxuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoMCxfdXRpbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmlzQXJyYXlCdWZmZXIpKGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGRhdGEgZm9ybWF0IGluIE11cm11ckhhc2gzXzY0X3VwZGF0ZS4gXCIgKyBcIklucHV0IG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQWJvcnRFeGNlcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIEFib3J0RXhjZXB0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlOiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRpb25FZGl0b3JQcmVmaXg6ICgpID0+ICgvKiBiaW5kaW5nICovIEFubm90YXRpb25FZGl0b3JQcmVmaXgpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0aW9uRWRpdG9yVHlwZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGlvbkVkaXRvclR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0aW9uTW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGlvbk1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0aW9uUHJlZml4OiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0aW9uUHJlZml4KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQW5ub3RhdGlvblR5cGU6ICgpID0+ICgvKiBiaW5kaW5nICovIEFubm90YXRpb25UeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZUV4Y2VwdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmFzZUV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENNYXBDb21wcmVzc2lvblR5cGU6ICgpID0+ICgvKiBiaW5kaW5nICovIENNYXBDb21wcmVzc2lvblR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGT05UX0lERU5USVRZX01BVFJJWDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRk9OVF9JREVOVElUWV9NQVRSSVgpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGZWF0dXJlVGVzdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRmVhdHVyZVRlc3QpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGb3JtYXRFcnJvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9ybWF0RXJyb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJREVOVElUWV9NQVRSSVg6ICgpID0+ICgvKiBiaW5kaW5nICovIElERU5USVRZX01BVFJJWCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEltYWdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW1hZ2VLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW52YWxpZFBERkV4Y2VwdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW52YWxpZFBERkV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIExJTkVfRkFDVE9SOiAoKSA9PiAoLyogYmluZGluZyAqLyBMSU5FX0ZBQ1RPUiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFOiAoKSA9PiAoLyogYmluZGluZyAqLyBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1pc3NpbmdQREZFeGNlcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIE1pc3NpbmdQREZFeGNlcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPUFM6ICgpID0+ICgvKiBiaW5kaW5nICovIE9QUyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhc3N3b3JkRXhjZXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXNzd29yZEV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhc3N3b3JkUmVzcG9uc2VzOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXNzd29yZFJlc3BvbnNlcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBlcm1pc3Npb25GbGFnOiAoKSA9PiAoLyogYmluZGluZyAqLyBQZXJtaXNzaW9uRmxhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFByb21pc2VDYXBhYmlsaXR5OiAoKSA9PiAoLyogYmluZGluZyAqLyBQcm9taXNlQ2FwYWJpbGl0eSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmRlcmluZ0ludGVudEZsYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmRlcmluZ0ludGVudEZsYWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0UmVuZGVyaW5nTW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dFJlbmRlcmluZ01vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFVua25vd25FcnJvckV4Y2VwdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVW5rbm93bkVycm9yRXhjZXB0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVXRpbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVXRpbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcmJvc2l0eUxldmVsOiAoKSA9PiAoLyogYmluZGluZyAqLyBWZXJib3NpdHlMZXZlbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGFzc2VydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYXNzZXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYnl0ZXNUb1N0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYnl0ZXNUb1N0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw6ICgpID0+ICgvKiBiaW5kaW5nICovIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRVdWlkOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRVdWlkKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0VmVyYm9zaXR5TGV2ZWw6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFZlcmJvc2l0eUxldmVsKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW5mbzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW5mbyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGlzQXJyYXlCdWZmZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzQXJyYXlCdWZmZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpc05vZGVKUzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNOb2RlSlMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBub3JtYWxpemVVbmljb2RlOiAoKSA9PiAoLyogYmluZGluZyAqLyBub3JtYWxpemVVbmljb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb2JqZWN0RnJvbU1hcDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb2JqZWN0RnJvbU1hcCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNldFZlcmJvc2l0eUxldmVsOiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXRWZXJib3NpdHlMZXZlbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNoYWRvdzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2hhZG93KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc3RyaW5nMzI6ICgpID0+ICgvKiBiaW5kaW5nICovIHN0cmluZzMyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc3RyaW5nVG9CeXRlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3RyaW5nVG9CeXRlcyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVucmVhY2hhYmxlOiAoKSA9PiAoLyogYmluZGluZyAqLyB1bnJlYWNoYWJsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHdhcm46ICgpID0+ICgvKiBiaW5kaW5nICovIHdhcm4pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydHMgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSwgQW5ub3RhdGlvbkZpZWxkRmxhZywgQW5ub3RhdGlvbkZsYWcsIEFubm90YXRpb25SZXBseVR5cGUsIEJBU0VMSU5FX0ZBQ1RPUiwgRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUsIGdldE1vZGlmaWNhdGlvbkRhdGUsIGlzQXJyYXlFcXVhbCwgTElORV9ERVNDRU5UX0ZBQ1RPUiwgb2JqZWN0U2l6ZSwgUGFnZUFjdGlvbkV2ZW50VHlwZSwgc3RyaW5nVG9QREZTdHJpbmcsIHN0cmluZ1RvVVRGOFN0cmluZywgdXRmOFN0cmluZ1RvU3RyaW5nICovXG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuY29uc3QgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmNvbnN0IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gMTBlNjtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgSElHSExJR0hUOiA5LFxuICBTVEFNUDogMTMsXG4gIElOSzogMTVcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzLFxuICBISUdITElHSFRfQ09MT1I6IDMxLFxuICBISUdITElHSFRfREVGQVVMVF9DT0xPUjogMzJcbn07XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuY29uc3QgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBDTWFwQ29tcHJlc3Npb25UeXBlID0ge1xuICBOT05FOiAwLFxuICBCSU5BUlk6IDFcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xubGV0IHZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTO1xuZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwobGV2ZWwpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIobGV2ZWwpKSB7XG4gICAgdmVyYm9zaXR5ID0gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5JTkZPUykge1xuICAgIGNvbnNvbGUubG9nKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5yZWFjaGFibGUobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNWYWxpZFByb3RvY29sKHVybCkge1xuICBzd2l0Y2ggKHVybD8ucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgYmFzZVVybCA9IG51bGwsIG9wdGlvbnMgPSBudWxsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAob3B0aW9ucy5hZGREZWZhdWx0UHJvdG9jb2wgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgICAgIGNvbnN0IGRvdHMgPSB1cmwubWF0Y2goL1xcLi9nKTtcbiAgICAgICAgaWYgKGRvdHM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50cnlDb252ZXJ0RW5jb2RpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBzdHJpbmdUb1VURjhTdHJpbmcodXJsKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYnNvbHV0ZVVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG4gICAgaWYgKF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGVVcmw7XG4gICAgfVxuICB9IGNhdGNoIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUsIG5vblNlcmlhbGl6YWJsZSA9IGZhbHNlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiAhbm9uU2VyaWFsaXphYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VFeGNlcHRpb24pIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUV4Y2VwdGlvbi5cIik7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gQmFzZUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEJhc2VFeGNlcHRpb247XG59KCk7XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufVxuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG9iamVjdEZyb21NYXAobWFwKSB7XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBGZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8ucGxhdGZvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNNYWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuY29uc3QgaGV4TnVtYmVycyA9IFsuLi5BcnJheSgyNTYpLmtleXMoKV0ubWFwKG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs1XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgIGNvbnN0IHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIGNvbnN0IHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgY29uc3QgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChyLCBtKSB7XG4gICAgY29uc3QgcDEgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIsIG0pO1xuICAgIGNvbnN0IHAyID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLnNsaWNlKDIsIDQpLCBtKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMF0sIHJbM11dLCBtKTtcbiAgICBjb25zdCBwNCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMl0sIHJbMV1dLCBtKTtcbiAgICByZXR1cm4gW01hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5taW4ocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLCBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKV07XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICBjb25zdCB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgY29uc3QgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiogMiAtIDQgKiAoYSAqIGQgLSBjICogYikpIC8gMjtcbiAgICBjb25zdCBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgY29uc3Qgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuICAgIHJldHVybiBbTWF0aC5zcXJ0KHN4KSwgTWF0aC5zcXJ0KHN5KV07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICBjb25zdCB0dmFsdWVzID0gW10sXG4gICAgICBib3VuZHMgPSBbW10sIFtdXTtcbiAgICBsZXQgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgbXQ7XG4gICAgY29uc3QgamxlbiA9IGo7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDAgKyAzICogbXQgKiBtdCAqIHQgKiB4MSArIDMgKiBtdCAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkwICsgMyAqIG10ICogbXQgKiB0ICogeTEgKyAzICogbXQgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gICAgfVxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcbiAgICByZXR1cm4gW01hdGgubWluKC4uLmJvdW5kc1swXSksIE1hdGgubWluKC4uLmJvdW5kc1sxXSksIE1hdGgubWF4KC4uLmJvdW5kc1swXSksIE1hdGgubWF4KC4uLmJvdW5kc1sxXSldO1xuICB9XG59XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY10pKTtcbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0cikge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZiZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIGlmICghZGVjb2RlZC5pbmNsdWRlcyhcIlxceDFiXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZUFsbCgvXFx4MWJbXlxceDFiXSooPzpcXHgxYnwkKS9nLCBcIlwiKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHdhcm4oYHN0cmluZ1RvUERGU3RyaW5nOiBcIiR7ZXh9XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJDb2RlID09PSAweDFiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgaWkgJiYgc3RyLmNoYXJDb2RlQXQoaSkgIT09IDB4MWIpIHt9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW2NoYXJDb2RlXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHY/LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5jbGFzcyBQcm9taXNlQ2FwYWJpbGl0eSB7XG4gICNzZXR0bGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IGRhdGEgPT4ge1xuICAgICAgICB0aGlzLiNzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuI3NldHRsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNldHRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NldHRsZWQ7XG4gIH1cbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiB7XG4gICAgcmV0dXJuIHAxID8gcDEubm9ybWFsaXplKFwiTkZLQ1wiKSA6IE5vcm1hbGl6YXRpb25NYXAuZ2V0KHAyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRVdWlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5yYW5kb21VVUlEID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgYnVmW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcoYnVmKTtcbn1cbmNvbnN0IEFubm90YXRpb25QcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2lkX1wiO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIFxuLyoqKioqKi8gXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcbi8qKioqKiovIFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gfVxuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2FzeW5jIG1vZHVsZSAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0dmFyIHdlYnBhY2tRdWV1ZXMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIHF1ZXVlc1wiKSA6IFwiX193ZWJwYWNrX3F1ZXVlc19fXCI7XG4vKioqKioqLyBcdHZhciB3ZWJwYWNrRXhwb3J0cyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgZXhwb3J0c1wiKSA6IFwiX193ZWJwYWNrX2V4cG9ydHNfX1wiO1xuLyoqKioqKi8gXHR2YXIgd2VicGFja0Vycm9yID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sKFwid2VicGFjayBlcnJvclwiKSA6IFwiX193ZWJwYWNrX2Vycm9yX19cIjtcbi8qKioqKiovIFx0dmFyIHJlc29sdmVRdWV1ZSA9IChxdWV1ZSkgPT4ge1xuLyoqKioqKi8gXHRcdGlmKHF1ZXVlICYmIHF1ZXVlLmQgPCAxKSB7XG4vKioqKioqLyBcdFx0XHRxdWV1ZS5kID0gMTtcbi8qKioqKiovIFx0XHRcdHF1ZXVlLmZvckVhY2goKGZuKSA9PiAoZm4uci0tKSk7XG4vKioqKioqLyBcdFx0XHRxdWV1ZS5mb3JFYWNoKChmbikgPT4gKGZuLnItLSA/IGZuLnIrKyA6IGZuKCkpKTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0dmFyIHdyYXBEZXBzID0gKGRlcHMpID0+IChkZXBzLm1hcCgoZGVwKSA9PiB7XG4vKioqKioqLyBcdFx0aWYoZGVwICE9PSBudWxsICYmIHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpIHtcbi8qKioqKiovIFx0XHRcdGlmKGRlcFt3ZWJwYWNrUXVldWVzXSkgcmV0dXJuIGRlcDtcbi8qKioqKiovIFx0XHRcdGlmKGRlcC50aGVuKSB7XG4vKioqKioqLyBcdFx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuLyoqKioqKi8gXHRcdFx0XHRxdWV1ZS5kID0gMDtcbi8qKioqKiovIFx0XHRcdFx0ZGVwLnRoZW4oKHIpID0+IHtcbi8qKioqKiovIFx0XHRcdFx0XHRvYmpbd2VicGFja0V4cG9ydHNdID0gcjtcbi8qKioqKiovIFx0XHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuLyoqKioqKi8gXHRcdFx0XHR9LCAoZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0XHRcdG9ialt3ZWJwYWNrRXJyb3JdID0gZTtcbi8qKioqKiovIFx0XHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuLyoqKioqKi8gXHRcdFx0XHR9KTtcbi8qKioqKiovIFx0XHRcdFx0dmFyIG9iaiA9IHt9O1xuLyoqKioqKi8gXHRcdFx0XHRvYmpbd2VicGFja1F1ZXVlc10gPSAoZm4pID0+IChmbihxdWV1ZSkpO1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gb2JqO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHR2YXIgcmV0ID0ge307XG4vKioqKioqLyBcdFx0cmV0W3dlYnBhY2tRdWV1ZXNdID0geCA9PiB7fTtcbi8qKioqKiovIFx0XHRyZXRbd2VicGFja0V4cG9ydHNdID0gZGVwO1xuLyoqKioqKi8gXHRcdHJldHVybiByZXQ7XG4vKioqKioqLyBcdH0pKTtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5hID0gKG1vZHVsZSwgYm9keSwgaGFzQXdhaXQpID0+IHtcbi8qKioqKiovIFx0XHR2YXIgcXVldWU7XG4vKioqKioqLyBcdFx0aGFzQXdhaXQgJiYgKChxdWV1ZSA9IFtdKS5kID0gLTEpO1xuLyoqKioqKi8gXHRcdHZhciBkZXBRdWV1ZXMgPSBuZXcgU2V0KCk7XG4vKioqKioqLyBcdFx0dmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR2YXIgY3VycmVudERlcHM7XG4vKioqKioqLyBcdFx0dmFyIG91dGVyUmVzb2x2ZTtcbi8qKioqKiovIFx0XHR2YXIgcmVqZWN0O1xuLyoqKioqKi8gXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlaikgPT4ge1xuLyoqKioqKi8gXHRcdFx0cmVqZWN0ID0gcmVqO1xuLyoqKioqKi8gXHRcdFx0b3V0ZXJSZXNvbHZlID0gcmVzb2x2ZTtcbi8qKioqKiovIFx0XHR9KTtcbi8qKioqKiovIFx0XHRwcm9taXNlW3dlYnBhY2tFeHBvcnRzXSA9IGV4cG9ydHM7XG4vKioqKioqLyBcdFx0cHJvbWlzZVt3ZWJwYWNrUXVldWVzXSA9IChmbikgPT4gKHF1ZXVlICYmIGZuKHF1ZXVlKSwgZGVwUXVldWVzLmZvckVhY2goZm4pLCBwcm9taXNlW1wiY2F0Y2hcIl0oeCA9PiB7fSkpO1xuLyoqKioqKi8gXHRcdG1vZHVsZS5leHBvcnRzID0gcHJvbWlzZTtcbi8qKioqKiovIFx0XHRib2R5KChkZXBzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRjdXJyZW50RGVwcyA9IHdyYXBEZXBzKGRlcHMpO1xuLyoqKioqKi8gXHRcdFx0dmFyIGZuO1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldFJlc3VsdCA9ICgpID0+IChjdXJyZW50RGVwcy5tYXAoKGQpID0+IHtcbi8qKioqKiovIFx0XHRcdFx0aWYoZFt3ZWJwYWNrRXJyb3JdKSB0aHJvdyBkW3dlYnBhY2tFcnJvcl07XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiBkW3dlYnBhY2tFeHBvcnRzXTtcbi8qKioqKiovIFx0XHRcdH0pKVxuLyoqKioqKi8gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0XHRmbiA9ICgpID0+IChyZXNvbHZlKGdldFJlc3VsdCkpO1xuLyoqKioqKi8gXHRcdFx0XHRmbi5yID0gMDtcbi8qKioqKiovIFx0XHRcdFx0dmFyIGZuUXVldWUgPSAocSkgPT4gKHEgIT09IHF1ZXVlICYmICFkZXBRdWV1ZXMuaGFzKHEpICYmIChkZXBRdWV1ZXMuYWRkKHEpLCBxICYmICFxLmQgJiYgKGZuLnIrKywgcS5wdXNoKGZuKSkpKTtcbi8qKioqKiovIFx0XHRcdFx0Y3VycmVudERlcHMubWFwKChkZXApID0+IChkZXBbd2VicGFja1F1ZXVlc10oZm5RdWV1ZSkpKTtcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGZuLnIgPyBwcm9taXNlIDogZ2V0UmVzdWx0KCk7XG4vKioqKioqLyBcdFx0fSwgKGVycikgPT4gKChlcnIgPyByZWplY3QocHJvbWlzZVt3ZWJwYWNrRXJyb3JdID0gZXJyKSA6IG91dGVyUmVzb2x2ZShleHBvcnRzKSksIHJlc29sdmVRdWV1ZShxdWV1ZSkpKTtcbi8qKioqKiovIFx0XHRxdWV1ZSAmJiBxdWV1ZS5kIDwgMCAmJiAocXVldWUuZCA9IDApO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFxuLyoqKioqKi8gLy8gc3RhcnR1cFxuLyoqKioqKi8gLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyAvLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdtb2R1bGUnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDcpO1xuLyoqKioqKi8gX193ZWJwYWNrX2V4cG9ydHNfXyA9IGdsb2JhbFRoaXMucGRmanNMaWIgPSBhd2FpdCAoZ2xvYmFsVGhpcy5wZGZqc0xpYlByb21pc2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFib3J0RXhjZXB0aW9uO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JMYXllcjtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclR5cGU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25MYXllciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkxheWVyO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbk1vZGU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NNYXBDb21wcmVzc2lvblR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNNYXBDb21wcmVzc2lvblR5cGU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yUGlja2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Db2xvclBpY2tlcjtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fRE9NU1ZHRmFjdG9yeSA9IF9fd2VicGFja19leHBvcnRzX18uRE9NU1ZHRmFjdG9yeTtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHJhd0xheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EcmF3TGF5ZXI7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZlYXR1cmVUZXN0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GZWF0dXJlVGVzdDtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2xvYmFsV29ya2VyT3B0aW9ucyA9IF9fd2VicGFja19leHBvcnRzX18uR2xvYmFsV29ya2VyT3B0aW9ucztcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VLaW5kID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JbWFnZUtpbmQ7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ludmFsaWRQREZFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkludmFsaWRQREZFeGNlcHRpb247XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX01pc3NpbmdQREZFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1pc3NpbmdQREZFeGNlcHRpb247XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX09QUyA9IF9fd2VicGFja19leHBvcnRzX18uT1BTO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19PdXRsaW5lciA9IF9fd2VicGFja19leHBvcnRzX18uT3V0bGluZXI7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGFSYW5nZVRyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX18uUERGRGF0YVJhbmdlVHJhbnNwb3J0O1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19QREZEYXRlU3RyaW5nID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QREZEYXRlU3RyaW5nO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19QREZXb3JrZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBERldvcmtlcjtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFzc3dvcmRSZXNwb25zZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBhc3N3b3JkUmVzcG9uc2VzO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19QZXJtaXNzaW9uRmxhZyA9IF9fd2VicGFja19leHBvcnRzX18uUGVybWlzc2lvbkZsYWc7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BpeGVsc1BlckluY2ggPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBpeGVsc1BlckluY2g7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Byb21pc2VDYXBhYmlsaXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Qcm9taXNlQ2FwYWJpbGl0eTtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX1VuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19VdGlsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5VdGlsO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19WZXJib3NpdHlMZXZlbCA9IF9fd2VicGFja19leHBvcnRzX18uVmVyYm9zaXR5TGV2ZWw7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX1hmYUxheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5YZmFMYXllcjtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmJ1aWxkO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19jcmVhdGVWYWxpZEFic29sdXRlVXJsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmZldGNoRGF0YTtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldERvY3VtZW50O1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19nZXRGaWxlbmFtZUZyb21VcmwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldEZpbGVuYW1lRnJvbVVybDtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0UGRmRmlsZW5hbWVGcm9tVXJsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXRQZGZGaWxlbmFtZUZyb21Vcmw7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldFhmYVBhZ2VWaWV3cG9ydCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0WGZhUGFnZVZpZXdwb3J0O1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19pc0RhdGFTY2hlbWUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmlzRGF0YVNjaGVtZTtcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNQZGZGaWxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pc1BkZkZpbGU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX25vQ29udGV4dE1lbnUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5vQ29udGV4dE1lbnU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5vcm1hbGl6ZVVuaWNvZGU7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX3JlbmRlclRleHRMYXllciA9IF9fd2VicGFja19leHBvcnRzX18ucmVuZGVyVGV4dExheWVyO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNldExheWVyRGltZW5zaW9ucztcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zaGFkb3c7XG4vKioqKioqLyB2YXIgX193ZWJwYWNrX2V4cG9ydHNfX3VwZGF0ZVRleHRMYXllciA9IF9fd2VicGFja19leHBvcnRzX18udXBkYXRlVGV4dExheWVyO1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZXJzaW9uO1xuLyoqKioqKi8gZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uIGFzIEFib3J0RXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIGFzIEFubm90YXRpb25FZGl0b3JMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIGFzIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclR5cGUgYXMgQW5ub3RhdGlvbkVkaXRvclR5cGUsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIGFzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTGF5ZXIgYXMgQW5ub3RhdGlvbkxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbk1vZGUgYXMgQW5ub3RhdGlvbk1vZGUsIF9fd2VicGFja19leHBvcnRzX19DTWFwQ29tcHJlc3Npb25UeXBlIGFzIENNYXBDb21wcmVzc2lvblR5cGUsIF9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciBhcyBDb2xvclBpY2tlciwgX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkgYXMgRE9NU1ZHRmFjdG9yeSwgX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciBhcyBEcmF3TGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCBhcyBGZWF0dXJlVGVzdCwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMgYXMgR2xvYmFsV29ya2VyT3B0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIF9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uIGFzIEludmFsaWRQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uIGFzIE1pc3NpbmdQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19PUFMgYXMgT1BTLCBfX3dlYnBhY2tfZXhwb3J0c19fT3V0bGluZXIgYXMgT3V0bGluZXIsIF9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQgYXMgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyBhcyBQREZEYXRlU3RyaW5nLCBfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIGFzIFBERldvcmtlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIGFzIFBhc3N3b3JkUmVzcG9uc2VzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWcgYXMgUGVybWlzc2lvbkZsYWcsIF9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoIGFzIFBpeGVsc1BlckluY2gsIF9fd2VicGFja19leHBvcnRzX19Qcm9taXNlQ2FwYWJpbGl0eSBhcyBQcm9taXNlQ2FwYWJpbGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBhcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gYXMgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCBhcyBVdGlsLCBfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwgYXMgVmVyYm9zaXR5TGV2ZWwsIF9fd2VicGFja19leHBvcnRzX19YZmFMYXllciBhcyBYZmFMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX2J1aWxkIGFzIGJ1aWxkLCBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCBhcyBjcmVhdGVWYWxpZEFic29sdXRlVXJsLCBfX3dlYnBhY2tfZXhwb3J0c19fZmV0Y2hEYXRhIGFzIGZldGNoRGF0YSwgX193ZWJwYWNrX2V4cG9ydHNfX2dldERvY3VtZW50IGFzIGdldERvY3VtZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsIGFzIGdldEZpbGVuYW1lRnJvbVVybCwgX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCBhcyBnZXRQZGZGaWxlbmFtZUZyb21VcmwsIF9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQgYXMgZ2V0WGZhUGFnZVZpZXdwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lIGFzIGlzRGF0YVNjaGVtZSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSBhcyBpc1BkZkZpbGUsIF9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51IGFzIG5vQ29udGV4dE1lbnUsIF9fd2VicGFja19leHBvcnRzX19ub3JtYWxpemVVbmljb2RlIGFzIG5vcm1hbGl6ZVVuaWNvZGUsIF9fd2VicGFja19leHBvcnRzX19yZW5kZXJUZXh0TGF5ZXIgYXMgcmVuZGVyVGV4dExheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fc2V0TGF5ZXJEaW1lbnNpb25zIGFzIHNldExheWVyRGltZW5zaW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX3NoYWRvdyBhcyBzaGFkb3csIF9fd2VicGFja19leHBvcnRzX191cGRhdGVUZXh0TGF5ZXIgYXMgdXBkYXRlVGV4dExheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fdmVyc2lvbiBhcyB2ZXJzaW9uIH07XG4vKioqKioqLyBcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLm1qcy5tYXAiXSwibmFtZXMiOlsiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJkIiwiQW5ub3RhdGlvbkxheWVyIiwiRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCIsIklua0Fubm90YXRpb25FbGVtZW50IiwiU3RhbXBBbm5vdGF0aW9uRWxlbWVudCIsInV0aWwiLCJkaXNwbGF5X3V0aWxzIiwiYW5ub3RhdGlvbl9zdG9yYWdlIiwibWFrZUNvbG9yQ29tcCIsIm4iLCJNYXRoIiwiZmxvb3IiLCJtYXgiLCJtaW4iLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic2NhbGVBbmRDbGFtcCIsIngiLCJDb2xvckNvbnZlcnRlcnMiLCJDTVlLX0ciLCJjIiwieSIsIm0iLCJrIiwiR19DTVlLIiwiZyIsIkdfUkdCIiwiR19yZ2IiLCJHX0hUTUwiLCJHIiwiUkdCX0ciLCJyIiwiYiIsIlJHQl9yZ2IiLCJjb2xvciIsIm1hcCIsIlJHQl9IVE1MIiwiam9pbiIsIlRfSFRNTCIsIlRfcmdiIiwiQ01ZS19SR0IiLCJDTVlLX3JnYiIsIkNNWUtfSFRNTCIsImNvbXBvbmVudHMiLCJyZ2IiLCJzbGljZSIsIlJHQl9DTVlLIiwieGZhX2xheWVyIiwiREVGQVVMVF9UQUJfSU5ERVgiLCJERUZBVUxUX0ZPTlRfU0laRSIsIkdldEVsZW1lbnRzQnlOYW1lU2V0IiwiV2Vha1NldCIsImdldFJlY3REaW1zIiwicmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IiwiY3JlYXRlIiwicGFyYW1ldGVycyIsInN1YnR5cGUiLCJkYXRhIiwiYW5ub3RhdGlvblR5cGUiLCJBbm5vdGF0aW9uVHlwZSIsIkxJTksiLCJMaW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJURVhUIiwiVGV4dEFubm90YXRpb25FbGVtZW50IiwiV0lER0VUIiwiZmllbGRUeXBlIiwiVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IiwicmFkaW9CdXR0b24iLCJSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiY2hlY2tCb3giLCJDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IiwiUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIldpZGdldEFubm90YXRpb25FbGVtZW50IiwiUE9QVVAiLCJQb3B1cEFubm90YXRpb25FbGVtZW50IiwiRlJFRVRFWFQiLCJMSU5FIiwiTGluZUFubm90YXRpb25FbGVtZW50IiwiU1FVQVJFIiwiU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQiLCJDSVJDTEUiLCJDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCIsIlBPTFlMSU5FIiwiUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIkNBUkVUIiwiQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCIsIklOSyIsIlBPTFlHT04iLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJISUdITElHSFQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVOREVSTElORSIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU1FVSUdHTFkiLCJTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IiwiU1RSSUtFT1VUIiwiU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTVEFNUCIsIkZJTEVBVFRBQ0hNRU5UIiwiRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCIsIkFubm90YXRpb25FbGVtZW50IiwiaGFzQm9yZGVyIiwiY29uc3RydWN0b3IiLCJpc1JlbmRlcmFibGUiLCJpZ25vcmVCb3JkZXIiLCJjcmVhdGVRdWFkcmlsYXRlcmFscyIsImxheWVyIiwibGlua1NlcnZpY2UiLCJkb3dubG9hZE1hbmFnZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJyZW5kZXJGb3JtcyIsInN2Z0ZhY3RvcnkiLCJhbm5vdGF0aW9uU3RvcmFnZSIsImVuYWJsZVNjcmlwdGluZyIsImhhc0pTQWN0aW9ucyIsIl9maWVsZE9iamVjdHMiLCJmaWVsZE9iamVjdHMiLCJwYXJlbnQiLCJjb250YWluZXIiLCJfY3JlYXRlQ29udGFpbmVyIiwiX2NyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiX2hhc1BvcHVwRGF0YSIsInRpdGxlT2JqIiwiY29udGVudHNPYmoiLCJyaWNoVGV4dCIsInN0ciIsImhhc1BvcHVwRGF0YSIsInBhZ2UiLCJ2aWV3cG9ydCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImlkIiwidGFiSW5kZXgiLCJzdHlsZSIsInpJbmRleCIsInBvcHVwUmVmIiwibm9Sb3RhdGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJwYWdlV2lkdGgiLCJwYWdlSGVpZ2h0IiwicGFnZVgiLCJwYWdlWSIsInJhd0RpbXMiLCJyb3RhdGlvbiIsImhhc093bkNhbnZhcyIsInNldFJvdGF0aW9uIiwiVXRpbCIsIm5vcm1hbGl6ZVJlY3QiLCJ2aWV3IiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsIkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUiLCJTT0xJRCIsIkRBU0hFRCIsIkJFVkVMRUQiLCJ3YXJuIiwiSU5TRVQiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckNvbG9yIiwibWFrZUhleENvbG9yIiwibGVmdCIsInRvcCIsImFuZ2xlIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsIl9jb21tb25BY3Rpb25zIiwic2V0Q29sb3IiLCJqc05hbWUiLCJzdHlsZU5hbWUiLCJldmVudCIsImRldGFpbCIsImNvbG9yVHlwZSIsImNvbG9yQXJyYXkiLCJ0YXJnZXQiLCJzZXRWYWx1ZSIsInNoYWRvdyIsImRpc3BsYXkiLCJoaWRkZW4iLCJ2aXNpYmlsaXR5Iiwibm9WaWV3Iiwibm9QcmludCIsInByaW50IiwiZm9jdXMiLCJzZXRUaW1lb3V0IiwicHJldmVudFNjcm9sbCIsInVzZXJOYW1lIiwidGl0bGUiLCJyZWFkb25seSIsImRpc2FibGVkIiwicmVxdWlyZWQiLCJfc2V0UmVxdWlyZWQiLCJiZ0NvbG9yIiwiZmlsbENvbG9yIiwiZmdDb2xvciIsInRleHRDb2xvciIsInN0cm9rZUNvbG9yIiwiX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCIsImFjdGlvbnMiLCJqc0V2ZW50IiwiY29tbW9uQWN0aW9ucyIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwiYWN0aW9uIiwiX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTIiwiZWxlbWVudCIsInN0b3JlZERhdGEiLCJnZXRSYXdWYWx1ZSIsImFjdGlvbk5hbWUiLCJlbnRyaWVzIiwiZXZlbnRQcm94eSIsInF1YWRQb2ludHMiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwibGVuZ3RoIiwidHJYIiwidHJZIiwiYmxYIiwiYmxZIiwic3ZnQnVmZmVyIiwic3ZnIiwiZGVmcyIsImFwcGVuZCIsImNsaXBQYXRoIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsInB1c2giLCJiYWNrZ3JvdW5kSW1hZ2UiLCJfY3JlYXRlUG9wdXAiLCJwb3B1cCIsIm1vZGlmaWNhdGlvbkRhdGUiLCJwYXJlbnRSZWN0IiwiZWxlbWVudHMiLCJkaXYiLCJyZW5kZXIiLCJ1bnJlYWNoYWJsZSIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImhhcyIsImdldEVsZW1lbnRzQnlOYW1lIiwiZ2V0QXR0cmlidXRlIiwic2hvdyIsIm1heWJlU2hvdyIsImhpZGUiLCJmb3JjZUhpZGUiLCJnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwIiwiYWRkSGlnaGxpZ2h0QXJlYSIsInRyaWdnZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiX2lzRWRpdGFibGUiLCJfZWRpdE9uRG91YmxlQ2xpY2siLCJhbm5vdGF0aW9uRWRpdG9yVHlwZSIsIm1vZGUiLCJlZGl0SWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRCdXMiLCJkaXNwYXRjaCIsInNvdXJjZSIsIm9wdGlvbnMiLCJpc1Rvb2x0aXBPbmx5IiwibGluayIsImlzQm91bmQiLCJ1cmwiLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsIl9iaW5kTmFtZWRBY3Rpb24iLCJhdHRhY2htZW50IiwiYmluZEF0dGFjaG1lbnQiLCJhdHRhY2htZW50RGVzdCIsInNldE9DR1N0YXRlIiwiYmluZFNldE9DR1N0YXRlIiwiZGVzdCIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiaHJlZiIsImdldERlc3RpbmF0aW9uSGFzaCIsIm9uY2xpY2siLCJnb1RvRGVzdGluYXRpb24iLCJnZXRBbmNob3JVcmwiLCJleGVjdXRlTmFtZWRBY3Rpb24iLCJvcGVuT3JEb3dubG9hZERhdGEiLCJjb250ZW50IiwiZmlsZW5hbWUiLCJleGVjdXRlU2V0T0NHU3RhdGUiLCJNYXAiLCJnZXQiLCJvdGhlckNsaWNrQWN0aW9uIiwicmVzZXRGb3JtRmllbGRzIiwicmVmcyIsInJlc2V0Rm9ybVJlZnMiLCJpbmNsdWRlIiwiYWxsRmllbGRzIiwiZmllbGRJZHMiLCJTZXQiLCJmaWVsZE5hbWUiLCJ2YWx1ZXMiLCJmaWVsZCIsInN0b3JhZ2UiLCJhbGxJZHMiLCJ0eXBlIiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpZHMiLCJpbWFnZSIsInNyYyIsInRvTG93ZXJDYXNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImFsdGVybmF0aXZlVGV4dCIsInNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyIsInByZXZpb3VzU2libGluZyIsIm5vZGVOYW1lIiwiX2dldEtleU1vZGlmaWVyIiwiRmVhdHVyZVRlc3QiLCJwbGF0Zm9ybSIsImlzTWFjIiwibWV0YUtleSIsImN0cmxLZXkiLCJfc2V0RXZlbnRMaXN0ZW5lciIsImVsZW1lbnREYXRhIiwiYmFzZU5hbWUiLCJldmVudE5hbWUiLCJ2YWx1ZUdldHRlciIsImluY2x1ZGVzIiwic2hpZnQiLCJzaGlmdEtleSIsIm1vZGlmaWVyIiwiZm9jdXNlZCIsInJlbGF0ZWRUYXJnZXQiLCJfc2V0RXZlbnRMaXN0ZW5lcnMiLCJuYW1lcyIsImdldHRlciIsIkJsdXIiLCJGb2N1cyIsIl9zZXRCYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJfc2V0VGV4dFN0eWxlIiwiVEVYVF9BTElHTk1FTlQiLCJmb250Q29sb3IiLCJkZWZhdWx0QXBwZWFyYW5jZURhdGEiLCJmb250U2l6ZSIsImNvbXB1dGVkRm9udFNpemUiLCJCT1JERVJfU0laRSIsInJvdW5kVG9PbmVEZWNpbWFsIiwicm91bmQiLCJtdWx0aUxpbmUiLCJhYnMiLCJudW1iZXJPZkxpbmVzIiwiTElORV9GQUNUT1IiLCJsaW5lSGVpZ2h0IiwidGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsImlzUmVxdWlyZWQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJoYXNBcHBlYXJhbmNlIiwiZmllbGRWYWx1ZSIsInNldFByb3BlcnR5T25TaWJsaW5ncyIsImJhc2UiLCJrZXkiLCJrZXlJblN0b3JhZ2UiLCJnZXRWYWx1ZSIsInRleHRDb250ZW50IiwibWF4TGVuIiwiY2hhckxpbWl0IiwiZmllbGRGb3JtYXR0ZWRWYWx1ZXMiLCJmb3JtYXR0ZWRWYWx1ZSIsImNvbWIiLCJyZXBsYWNlQWxsIiwidXNlclZhbHVlIiwibGFzdENvbW1pdHRlZFZhbHVlIiwiY29tbWl0S2V5IiwiZG9Ob3RTY3JvbGwiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWFkT25seSIsIm1heExlbmd0aCIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwidW5kZWZpbmVkIiwic2Nyb2xsTGVmdCIsImFjdGl2ZUVsZW1lbnQiLCJzZWxSYW5nZSIsInNldFNlbGVjdGlvblJhbmdlIiwid2lsbENvbW1pdCIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJfYmx1ckxpc3RlbmVyIiwiS2V5c3Ryb2tlIiwiaW5wdXRUeXBlIiwibWF0Y2giLCJzdWJzdHJpbmciLCJwcmV2ZW50RGVmYXVsdCIsImNoYW5nZSIsImZpZWxkV2lkdGgiLCJjb21iV2lkdGgiLCJsZXR0ZXJTcGFjaW5nIiwidmVydGljYWxBbGlnbiIsImNoZWNrZWQiLCJjaGVja2JveCIsImN1ckNoZWNrZWQiLCJidXR0b25WYWx1ZSIsInJhZGlvIiwicGRmQnV0dG9uVmFsdWUiLCJsaW5rRWxlbWVudCIsImxhc3RDaGlsZCIsInNlbGVjdEVsZW1lbnQiLCJhZGRBbkVtcHR5RW50cnkiLCJjb21ibyIsInNpemUiLCJtdWx0aVNlbGVjdCIsIm11bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwicHJlcGVuZCIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpc0V4cG9ydCIsInNlbGVjdGVkSW5kZXgiLCJwcm90b3R5cGUiLCJmaWx0ZXIiLCJjYWxsIiwic2VsZWN0ZWRWYWx1ZXMiLCJnZXRJdGVtcyIsIm11bHRpcGxlU2VsZWN0aW9uIiwiaW5kZXgiLCJpIiwiZmluZEluZGV4IiwiaXRlbXMiLCJjbGVhciIsImluc2VydCIsInNlbGVjdENoaWxkIiwiY2hpbGRyZW4iLCJiZWZvcmUiLCJpdGVtIiwiaW5kaWNlcyIsImVkaXRhYmxlIiwiY2hhbmdlRXgiLCJrZXlEb3duIiwiUG9wdXBFbGVtZW50Iiwib3BlbiIsImVsZW1lbnRJZHMiLCJBbm5vdGF0aW9uUHJlZml4IiwiYm91bmRLZXlEb3duIiwiYm91bmRIaWRlIiwiYm91bmRTaG93IiwiYm91bmRUb2dnbGUiLCJkYXRlT2JqIiwicGlubmVkIiwid2FzVmlzaWJsZSIsImJpbmQiLCJ0b2dnbGUiLCJQREZEYXRlU3RyaW5nIiwidG9EYXRlT2JqZWN0IiwidHJpZ2dlciIsImZsYXRNYXAiLCJlIiwiY2xhc3NOYW1lIiwiYmFzZUNvbG9yIiwib3V0bGluZUNvbG9yIiwiQ1NTIiwic3VwcG9ydHMiLCJCQUNLR1JPVU5EX0VOTElHSFQiLCJoZWFkZXIiLCJkaXIiLCJkYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwidGltZSIsInRvTG9jYWxlVGltZVN0cmluZyIsIlhmYUxheWVyIiwieGZhSHRtbCIsImh0bWwiLCJpbnRlbnQiLCJjb250ZW50cyIsIl9mb3JtYXRDb250ZW50cyIsInVzZVBhcmVudFJlY3QiLCJpbnRlcnNlY3QiLCJub3JtYWxpemVkUmVjdCIsIkhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiIsInBhcmVudFdpZHRoIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJwIiwibGluZXMiLCJzcGxpdCIsImlpIiwibGluZSIsImNyZWF0ZVRleHROb2RlIiwiYWx0S2V5IiwiaXNWaXNpYmxlIiwicGFyc2VJbnQiLCJ0ZXh0UG9zaXRpb24iLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsInBvaW50cyIsImNvb3JkaW5hdGUiLCJ2ZXJ0aWNlcyIsInBvbHlsaW5lcyIsImlua0xpc3QiLCJpbmtMaXN0cyIsImZpbGUiLCJnZXRGaWxlbmFtZUZyb21VcmwiLCJmaWxsQWxwaGEiLCJ0ZXN0IiwiZG93bmxvYWQiLCJldnQiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsImFubm90YXRpb25DYW52YXNNYXAiLCJlZGl0YWJsZUFubm90YXRpb25zIiwiYXBwZW5kRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwiZmlyc3RDaGlsZCIsIm1vdmVFbGVtZW50SW5ET00iLCJwYXJhbXMiLCJhbm5vdGF0aW9ucyIsInNldExheWVyRGltZW5zaW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJET01TVkdGYWN0b3J5IiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInNldCIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsInVwZGF0ZSIsImNhbnZhcyIsInJlcGxhY2VXaXRoIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImZyb20iLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJQcmludEFubm90YXRpb25TdG9yYWdlIiwiU2VyaWFsaXphYmxlRW1wdHkiLCJfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9lZGl0b3JfZWRpdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJfc2hhcmVkX211cm11cmhhc2gzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJmcmVlemUiLCJoYXNoIiwidHJhbnNmZXIiLCJtb2RpZmllZCIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJhc3NpZ24iLCJkZWxldGUiLCJyZXNldE1vZGlmaWVkIiwiQW5ub3RhdGlvbkVkaXRvciIsIm9iaiIsImVudHJ5IiwidmFsIiwic2V0TW9kaWZpZWQiLCJfdHlwZSIsImdldEFsbCIsIm9iamVjdEZyb21NYXAiLCJzZXRBbGwiLCJzZXJpYWxpemFibGUiLCJNdXJtdXJIYXNoM182NCIsImNvbnRleHQiLCJoYXNCaXRtYXAiLCJzZXJpYWxpemVkIiwic2VyaWFsaXplIiwiYml0bWFwIiwiaGV4ZGlnZXN0IiwiY2xvbmUiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJfX3dlYnBhY2tfbW9kdWxlX18iLCJhIiwiX193ZWJwYWNrX2hhbmRsZV9hc3luY19kZXBlbmRlbmNpZXNfXyIsIl9fd2VicGFja19hc3luY19yZXN1bHRfXyIsIlBERkRhdGFSYW5nZVRyYW5zcG9ydCIsIlBERldvcmtlciIsImJ1aWxkIiwiZ2V0RG9jdW1lbnQiLCJ2ZXJzaW9uIiwiX2Fubm90YXRpb25fc3RvcmFnZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl9mb250X2xvYWRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiZGlzcGxheV9ub2RlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJfY2FudmFzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJfd29ya2VyX29wdGlvbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsIl9zaGFyZWRfbWVzc2FnZV9oYW5kbGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJfbWV0YWRhdGFfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyIsIl9vcHRpb25hbF9jb250ZW50X2NvbmZpZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fIiwiX3RyYW5zcG9ydF9zdHJlYW1fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18iLCJkaXNwbGF5X2ZldGNoX3N0cmVhbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyIsImRpc3BsYXlfbmV0d29ya19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyIsImRpc3BsYXlfbm9kZV9zdHJlYW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18iLCJfeGZhX3RleHRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18iLCJfX3dlYnBhY2tfYXN5bmNfZGVwZW5kZW5jaWVzX18iLCJ0aGVuIiwiREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFIiwiUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUIiwiREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQiLCJEZWZhdWx0Q2FudmFzRmFjdG9yeSIsImlzTm9kZUpTIiwiTm9kZUNhbnZhc0ZhY3RvcnkiLCJET01DYW52YXNGYWN0b3J5IiwiRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5IiwiTm9kZUNNYXBSZWFkZXJGYWN0b3J5IiwiRE9NQ01hcFJlYWRlckZhY3RvcnkiLCJEZWZhdWx0RmlsdGVyRmFjdG9yeSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiRE9NRmlsdGVyRmFjdG9yeSIsIkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiVVJMIiwiaXNBcnJheUJ1ZmZlciIsIkVycm9yIiwicmFuZ2UiLCJ0YXNrIiwiUERGRG9jdW1lbnRMb2FkaW5nVGFzayIsImRvY0lkIiwiZ2V0VXJsUHJvcCIsImdldERhdGFQcm9wIiwiaHR0cEhlYWRlcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwicmFuZ2VDaHVua1NpemUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ3b3JrZXIiLCJ2ZXJib3NpdHkiLCJkb2NCYXNlVXJsIiwiaXNEYXRhU2NoZW1lIiwiY01hcFVybCIsImNNYXBQYWNrZWQiLCJDTWFwUmVhZGVyRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsImlnbm9yZUVycm9ycyIsInN0b3BBdEVycm9ycyIsIm1heEltYWdlU2l6ZSIsImlzRXZhbFN1cHBvcnRlZCIsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJkaXNhYmxlRm9udEZhY2UiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiZW5hYmxlWGZhIiwib3duZXJEb2N1bWVudCIsImdsb2JhbFRoaXMiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwiZGlzYWJsZUF1dG9GZXRjaCIsInBkZkJ1ZyIsIk5hTiIsInVzZVN5c3RlbUZvbnRzIiwidXNlV29ya2VyRmV0Y2giLCJpc1ZhbGlkRmV0Y2hVcmwiLCJiYXNlVVJJIiwiY2FudmFzRmFjdG9yeSIsImZpbHRlckZhY3RvcnkiLCJzdHlsZUVsZW1lbnQiLCJzZXRWZXJib3NpdHlMZXZlbCIsInRyYW5zcG9ydEZhY3RvcnkiLCJjTWFwUmVhZGVyRmFjdG9yeSIsImJhc2VVcmwiLCJpc0NvbXByZXNzZWQiLCJzdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIndvcmtlclBhcmFtcyIsInBvcnQiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwid29ya2VyUG9ydCIsImZyb21Qb3J0IiwiX3dvcmtlciIsImZldGNoRG9jUGFyYW1zIiwiYXBpVmVyc2lvbiIsImV2YWx1YXRvck9wdGlvbnMiLCJ0cmFuc3BvcnRQYXJhbXMiLCJwcm9taXNlIiwiZGVzdHJveWVkIiwid29ya2VySWRQcm9taXNlIiwiX2ZldGNoRG9jdW1lbnQiLCJuZXR3b3JrU3RyZWFtUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwibmV0d29ya1N0cmVhbSIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0iLCJpbml0aWFsRGF0YSIsInByb2dyZXNzaXZlRG9uZSIsImNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiY3JlYXRlUERGTmV0d29ya1N0cmVhbSIsIlBERk5vZGVTdHJlYW0iLCJQREZGZXRjaFN0cmVhbSIsIlBERk5ldHdvcmtTdHJlYW0iLCJhbGwiLCJ3b3JrZXJJZCIsIm1lc3NhZ2VIYW5kbGVyIiwiTWVzc2FnZUhhbmRsZXIiLCJ0cmFuc3BvcnQiLCJXb3JrZXJUcmFuc3BvcnQiLCJfdHJhbnNwb3J0Iiwic2VuZCIsImNhdGNoIiwiX2NhcGFiaWxpdHkiLCJyZWplY3QiLCJzZW5kV2l0aFByb21pc2UiLCJidWZmZXIiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIkJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwic3RyaW5nVG9CeXRlcyIsImlzTmFOIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJvblBhc3N3b3JkIiwib25Qcm9ncmVzcyIsImRlc3Ryb3kiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJleCIsIl9yYW5nZUxpc3RlbmVycyIsIl9wcm9ncmVzc0xpc3RlbmVycyIsIl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwiX3JlYWR5Q2FwYWJpbGl0eSIsImFkZFJhbmdlTGlzdGVuZXIiLCJsaXN0ZW5lciIsImFkZFByb2dyZXNzTGlzdGVuZXIiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwib25EYXRhUmFuZ2UiLCJiZWdpbiIsImNodW5rIiwib25EYXRhUHJvZ3Jlc3MiLCJsb2FkZWQiLCJ0b3RhbCIsIm9uRGF0YVByb2dyZXNzaXZlUmVhZCIsIm9uRGF0YVByb2dyZXNzaXZlRG9uZSIsInRyYW5zcG9ydFJlYWR5IiwicmVxdWVzdERhdGFSYW5nZSIsImVuZCIsImFib3J0IiwiUERGRG9jdW1lbnRQcm94eSIsInBkZkluZm8iLCJfcGRmSW5mbyIsIm51bVBhZ2VzIiwiZmluZ2VycHJpbnRzIiwiaXNQdXJlWGZhIiwiX2h0bWxGb3JYZmEiLCJhbGxYZmFIdG1sIiwiZ2V0UGFnZSIsInBhZ2VOdW1iZXIiLCJnZXRQYWdlSW5kZXgiLCJyZWYiLCJnZXREZXN0aW5hdGlvbnMiLCJnZXREZXN0aW5hdGlvbiIsImdldFBhZ2VMYWJlbHMiLCJnZXRQYWdlTGF5b3V0IiwiZ2V0UGFnZU1vZGUiLCJnZXRWaWV3ZXJQcmVmZXJlbmNlcyIsImdldE9wZW5BY3Rpb24iLCJnZXRBdHRhY2htZW50cyIsImdldEpTQWN0aW9ucyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJnZXREYXRhIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImNsZWFudXAiLCJrZWVwTG9hZGVkRm9udHMiLCJzdGFydENsZWFudXAiLCJsb2FkaW5nVGFzayIsImxvYWRpbmdQYXJhbXMiLCJnZXRGaWVsZE9iamVjdHMiLCJnZXRDYWxjdWxhdGlvbk9yZGVySWRzIiwiUERGUGFnZVByb3h5IiwiZGVsYXllZENsZWFudXBUaW1lb3V0IiwicGVuZGluZ0NsZWFudXAiLCJwYWdlSW5kZXgiLCJwYWdlSW5mbyIsIl9wYWdlSW5kZXgiLCJfcGFnZUluZm8iLCJfc3RhdHMiLCJTdGF0VGltZXIiLCJfcGRmQnVnIiwiY29tbW9uT2JqcyIsIm9ianMiLCJQREZPYmplY3RzIiwiX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIiwiX2ludGVudFN0YXRlcyIsInJvdGF0ZSIsInVzZXJVbml0IiwiZ2V0Vmlld3BvcnQiLCJzY2FsZSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZG9udEZsaXAiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94IiwiZ2V0QW5ub3RhdGlvbnMiLCJpbnRlbnRBcmdzIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwicmVuZGVyaW5nSW50ZW50IiwiZ2V0UGFnZUpTQWN0aW9ucyIsImdldFhmYSIsImNhbnZhc0NvbnRleHQiLCJhbm5vdGF0aW9uTW9kZSIsIkFubm90YXRpb25Nb2RlIiwiRU5BQkxFIiwidHJhbnNmb3JtIiwiYmFja2dyb3VuZCIsIm9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UiLCJwYWdlQ29sb3JzIiwicHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsImFib3J0RGVsYXllZENsZWFudXAiLCJpbnRlbnRTdGF0ZSIsImNhY2hlS2V5Iiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImludGVudFByaW50IiwiUmVuZGVyaW5nSW50ZW50RmxhZyIsIlBSSU5UIiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsIm9wZXJhdG9yTGlzdCIsImZuQXJyYXkiLCJhcmdzQXJyYXkiLCJsYXN0Q2h1bmsiLCJzZXBhcmF0ZUFubm90cyIsIl9wdW1wT3BlcmF0b3JMaXN0IiwiY29tcGxldGUiLCJlcnJvciIsInJlbmRlclRhc2tzIiwiaW50ZXJuYWxSZW5kZXJUYXNrIiwidHJ5Q2xlYW51cCIsImNhcGFiaWxpdHkiLCJfYWJvcnRPcGVyYXRvckxpc3QiLCJyZWFzb24iLCJ0aW1lRW5kIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwiY2FsbGJhY2siLCJ1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW5kZXJUYXNrIiwidHJhbnNwYXJlbmN5Iiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwiaW5pdGlhbGl6ZUdyYXBoaWNzIiwib3BlcmF0b3JMaXN0Q2hhbmdlZCIsImdldE9wZXJhdG9yTGlzdCIsIm9wTGlzdFJlYWRDYXBhYmlsaXR5Iiwib3BMaXN0VGFzayIsInN0cmVhbVRleHRDb250ZW50IiwiaW5jbHVkZU1hcmtlZENvbnRlbnQiLCJkaXNhYmxlTm9ybWFsaXphdGlvbiIsIlRFWFRfQ09OVEVOVF9DSFVOS19TSVpFIiwic2VuZFdpdGhTdHJlYW0iLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0VGV4dENvbnRlbnQiLCJ4ZmEiLCJYZmFUZXh0IiwicmVhZGFibGVTdHJlYW0iLCJwdW1wIiwicmVhZGVyIiwicmVhZCIsImRvbmUiLCJzdHlsZXMiLCJnZXRSZWFkZXIiLCJnZXRTdHJ1Y3RUcmVlIiwiX2Rlc3Ryb3kiLCJ3YWl0T24iLCJmb3JjZSIsImNvbXBsZXRlZCIsImNhbmNlbCIsInJlc2V0U3RhdHMiLCJzdWNjZXNzIiwiZGVsYXllZCIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiIsImRlbGF5IiwiZXh0cmFEZWxheSIsIkFib3J0RXhjZXB0aW9uIiwibWVzc2FnZSIsImN1ckNhY2hlS2V5IiwiY3VySW50ZW50U3RhdGUiLCJzdGF0cyIsIkxvb3BiYWNrUG9ydCIsImxpc3RlbmVycyIsImRlZmVycmVkIiwicG9zdE1lc3NhZ2UiLCJ0ZXJtaW5hdGUiLCJQREZXb3JrZXJVdGlsIiwiaXNXb3JrZXJEaXNhYmxlZCIsImZha2VXb3JrZXJJZCIsIndvcmtlclNyYyIsImlzU2FtZU9yaWdpbiIsIm90aGVyVXJsIiwib3JpZ2luIiwib3RoZXIiLCJjcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ3b3JrZXJQb3J0cyIsImdldFZlcmJvc2l0eUxldmVsIiwiX3BvcnQiLCJfd2ViV29ya2VyIiwiX21lc3NhZ2VIYW5kbGVyIiwiV2Vha01hcCIsIl9pbml0aWFsaXplRnJvbVBvcnQiLCJfaW5pdGlhbGl6ZSIsIm9uIiwibWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyIiwiV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJvbldvcmtlckVycm9yIiwiX3NldHVwRmFrZVdvcmtlciIsInNlbmRUZXN0IiwidGVzdE9iaiIsImluZm8iLCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsIiwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJjYWNoZWRQb3J0IiwicGRmanNXb3JrZXIiLCJsb2FkZXIiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZhY3RvcnkiLCJmb250TG9hZGVyIiwiRm9udExvYWRlciIsIl9wYXJhbXMiLCJkZXN0cm95Q2FwYWJpbGl0eSIsIl9uZXR3b3JrU3RyZWFtIiwiX2Z1bGxSZWFkZXIiLCJfbGFzdFByb2dyZXNzIiwic2V0dXBNZXNzYWdlSGFuZGxlciIsImNhY2hlU2ltcGxlTWV0aG9kIiwiY2FjaGVkUHJvbWlzZSIsImlzT3BMaXN0IiwiRElTUExBWSIsIkFOWSIsIkRJU0FCTEUiLCJBTk5PVEFUSU9OU19ESVNBQkxFIiwiRU5BQkxFX0ZPUk1TIiwiQU5OT1RBVElPTlNfRk9STVMiLCJFTkFCTEVfU1RPUkFHRSIsIkFOTk9UQVRJT05TX1NUT1JBR0UiLCJPUExJU1QiLCJoYXNPd25Qcm9wZXJ0eSIsInRlcm1pbmF0ZWQiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsInNpbmsiLCJhc3NlcnQiLCJnZXRGdWxsUmVhZGVyIiwib25QdWxsIiwiY2xvc2UiLCJBcnJheUJ1ZmZlciIsImVucXVldWUiLCJvbkNhbmNlbCIsInJlYWR5IiwicmVhZHlSZWFzb24iLCJoZWFkZXJzQ2FwYWJpbGl0eSIsImZ1bGxSZWFkZXIiLCJoZWFkZXJzUmVhZHkiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJjb250ZW50TGVuZ3RoIiwicmFuZ2VSZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIl9udW1QYWdlcyIsImh0bWxGb3JYZmEiLCJQYXNzd29yZEV4Y2VwdGlvbiIsImNvZGUiLCJJbnZhbGlkUERGRXhjZXB0aW9uIiwiTWlzc2luZ1BERkV4Y2VwdGlvbiIsIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiIsInN0YXR1cyIsIlVua25vd25FcnJvckV4Y2VwdGlvbiIsImRldGFpbHMiLCJleGNlcHRpb24iLCJ1cGRhdGVQYXNzd29yZCIsImV4cG9ydGVkRGF0YSIsImV4cG9ydGVkRXJyb3IiLCJpbnNwZWN0Rm9udCIsIkZvbnRJbnNwZWN0b3IiLCJlbmFibGVkIiwiZm9udCIsImZvbnRBZGRlZCIsIkZvbnRGYWNlT2JqZWN0IiwiZmluYWxseSIsImltYWdlUmVmIiwicGFnZVByb3h5IiwiZGF0YUxlbiIsImltYWdlRGF0YSIsIk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFIiwiZmV0Y2giLCJudW0iLCJnZW4iLCJyZXN1bHRzIiwiT3B0aW9uYWxDb250ZW50Q29uZmlnIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsImNsZWFudXBTdWNjZXNzZnVsIiwiZW5zdXJlT2JqIiwib2JqSWQiLCJzZXR0bGVkIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJSZW5kZXJUYXNrIiwib25Db250aW51ZSIsImZvcm0iLCJjYW52YXNJblVzZSIsIm9wZXJhdG9yTGlzdElkeCIsInJ1bm5pbmciLCJncmFwaGljc1JlYWR5Q2FsbGJhY2siLCJncmFwaGljc1JlYWR5IiwiX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbGxlZCIsIl9jYW5jZWxCb3VuZCIsIl9jb250aW51ZUJvdW5kIiwiX2NvbnRpbnVlIiwiX3NjaGVkdWxlTmV4dEJvdW5kIiwiX3NjaGVkdWxlTmV4dCIsIl9uZXh0Qm91bmQiLCJfbmV4dCIsIl9jYW52YXMiLCJTdGVwcGVyTWFuYWdlciIsInN0ZXBwZXIiLCJpbml0IiwibmV4dEJyZWFrUG9pbnQiLCJnZXROZXh0QnJlYWtQb2ludCIsImdmeCIsIkNhbnZhc0dyYXBoaWNzIiwiYmVnaW5EcmF3aW5nIiwiZW5kRHJhd2luZyIsInVwZGF0ZU9wZXJhdG9yTGlzdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImV4ZWN1dGVPcGVyYXRvckxpc3QiLCJCYXNlQ01hcFJlYWRlckZhY3RvcnkiLCJCYXNlQ2FudmFzRmFjdG9yeSIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiQmFzZVNWR0ZhY3RvcnkiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJhZGRGaWx0ZXIiLCJtYXBzIiwiYWRkSENNRmlsdGVyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJrZWVwSENNIiwiX2NyZWF0ZUNhbnZhcyIsImdldENvbnRleHQiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJjb21wcmVzc2lvblR5cGUiLCJDTWFwQ29tcHJlc3Npb25UeXBlIiwiQklOQVJZIiwiTk9ORSIsIl9mZXRjaERhdGEiLCJza2lwRGltZW5zaW9ucyIsIl9jcmVhdGVTVkciLCJQYXRoVHlwZSIsIkZJTEwiLCJTVFJPS0UiLCJTSEFESU5HIiwiYXBwbHlCb3VuZGluZ0JveCIsImN0eCIsImJib3giLCJyZWdpb24iLCJQYXRoMkQiLCJjbGlwIiwiQmFzZVNoYWRpbmdQYXR0ZXJuIiwiZ2V0UGF0dGVybiIsIlJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4iLCJJUiIsIl9iYm94IiwiX2NvbG9yU3RvcHMiLCJfcDAiLCJfcDEiLCJfcjAiLCJfcjEiLCJtYXRyaXgiLCJfY3JlYXRlR3JhZGllbnQiLCJncmFkIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImNvbG9yU3RvcCIsImFkZENvbG9yU3RvcCIsIm93bmVyIiwiaW52ZXJzZSIsInBhdGhUeXBlIiwicGF0dGVybiIsIm93bmVyQkJveCIsImN1cnJlbnQiLCJnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94IiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImNlaWwiLCJ0bXBDYW52YXMiLCJjYWNoZWRDYW52YXNlcyIsImdldENhbnZhcyIsInRtcEN0eCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsInRyYW5zbGF0ZSIsImJhc2VUcmFuc2Zvcm0iLCJmaWxsU3R5bGUiLCJmaWxsIiwiY3JlYXRlUGF0dGVybiIsImRvbU1hdHJpeCIsIkRPTU1hdHJpeCIsInNldFRyYW5zZm9ybSIsImRyYXdUcmlhbmdsZSIsInAxIiwicDIiLCJwMyIsImMxIiwiYzIiLCJjMyIsImNvb3JkcyIsImNvbG9ycyIsImJ5dGVzIiwicm93U2l6ZSIsInRtcCIsIngxIiwic2NhbGVYIiwieTEiLCJzY2FsZVkiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImMxciIsImMxZyIsImMxYiIsImMyciIsImMyZyIsImMyYiIsImMzciIsImMzZyIsImMzYiIsIm1pblkiLCJtYXhZIiwieGEiLCJjYXIiLCJjYWciLCJjYWIiLCJ4YiIsImNiciIsImNiZyIsImNiYiIsIngxXyIsIngyXyIsImoiLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9jb2xvcnMiLCJfZmlndXJlcyIsIl9ib3VuZHMiLCJfYmFja2dyb3VuZCIsIl9jcmVhdGVNZXNoQ2FudmFzIiwiY29tYmluZWRTY2FsZSIsIkVYUEVDVEVEX1NDQUxFIiwiTUFYX1BBVFRFUk5fU0laRSIsImJvdW5kc1dpZHRoIiwiYm91bmRzSGVpZ2h0IiwicGFkZGVkV2lkdGgiLCJwYWRkZWRIZWlnaHQiLCJjcmVhdGVJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSIsIm1hdHJpeFNjYWxlIiwidGVtcG9yYXJ5UGF0dGVybkNhbnZhcyIsIkR1bW15U2hhZGluZ1BhdHRlcm4iLCJnZXRTaGFkaW5nUGF0dGVybiIsIlBhaW50VHlwZSIsIkNPTE9SRUQiLCJVTkNPTE9SRUQiLCJUaWxpbmdQYXR0ZXJuIiwiY2FudmFzR3JhcGhpY3NGYWN0b3J5IiwieHN0ZXAiLCJ5c3RlcCIsInBhaW50VHlwZSIsInRpbGluZ1R5cGUiLCJjcmVhdGVQYXR0ZXJuQ2FudmFzIiwieDAiLCJ5MCIsImN1ck1hdHJpeFNjYWxlIiwiZGlteCIsImdldFNpemVBbmRTY2FsZSIsImRpbXkiLCJncmFwaGljcyIsImNyZWF0ZUNhbnZhc0dyYXBoaWNzIiwiZ3JvdXBMZXZlbCIsInNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dCIsImFkanVzdGVkWDAiLCJhZGp1c3RlZFkwIiwiYWRqdXN0ZWRYMSIsImFkanVzdGVkWTEiLCJzYXZlIiwiY2xpcEJib3giLCJzdGVwIiwicmVhbE91dHB1dFNpemUiLCJtYXhTaXplIiwiYmJveFdpZHRoIiwiYmJveEhlaWdodCIsInVwZGF0ZVJlY3RNaW5NYXgiLCJlbmRQYXRoIiwic3Ryb2tlU3R5bGUiLCJjc3NDb2xvciIsIkZvcm1hdEVycm9yIiwiY29udmVydFRvUkdCQSIsImtpbmQiLCJJbWFnZUtpbmQiLCJHUkFZU0NBTEVfMUJQUCIsImNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBIiwiUkdCXzI0QlBQIiwiY29udmVydFJHQlRvUkdCQSIsInNyY1BvcyIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiYmxhY2siLCJpc0xpdHRsZUVuZGlhbiIsInplcm9NYXBwaW5nIiwib25lTWFwcGluZyIsIndpZHRoSW5Tb3VyY2UiLCJ3aWR0aFJlbWFpbmRlciIsInNyY0xlbmd0aCIsIlVpbnQzMkFycmF5IiwiZGVzdFBvcyIsImVsZW0iLCJsZW4zMiIsInNyYzMyIiwiczEiLCJzMiIsInMzIiwiamoiLCJncmF5VG9SR0JBIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJNQVhfR1JPVVBfU0laRSIsIkVYRUNVVElPTl9USU1FIiwiRVhFQ1VUSU9OX1NURVBTIiwiTUFYX1NJWkVfVE9fQ09NUElMRSIsIkZVTExfQ0hVTktfSEVJR0hUIiwibWlycm9yQ29udGV4dE9wZXJhdGlvbnMiLCJkZXN0Q3R4IiwiX3JlbW92ZU1pcnJvcmluZyIsIl9fb3JpZ2luYWxTYXZlIiwiX19vcmlnaW5hbFJlc3RvcmUiLCJyZXN0b3JlIiwiX19vcmlnaW5hbFJvdGF0ZSIsIl9fb3JpZ2luYWxTY2FsZSIsIl9fb3JpZ2luYWxUcmFuc2xhdGUiLCJfX29yaWdpbmFsVHJhbnNmb3JtIiwiX19vcmlnaW5hbFNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSIsInJlc2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbENsaXAiLCJfX29yaWdpbmFsTW92ZVRvIiwibW92ZVRvIiwiX19vcmlnaW5hbExpbmVUbyIsImxpbmVUbyIsIl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvIiwiYmV6aWVyQ3VydmVUbyIsIl9fb3JpZ2luYWxSZWN0IiwiX19vcmlnaW5hbENsb3NlUGF0aCIsImNsb3NlUGF0aCIsIl9fb3JpZ2luYWxCZWdpblBhdGgiLCJjdHhTYXZlIiwiY3R4UmVzdG9yZSIsImN0eFRyYW5zbGF0ZSIsImN0eFNjYWxlIiwiY3R4VHJhbnNmb3JtIiwiZiIsImN0eFNldFRyYW5zZm9ybSIsImN0eFJlc2V0VHJhbnNmb3JtIiwiY3R4Um90YXRlIiwicnVsZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhY2hlIiwiY2FudmFzRW50cnkiLCJkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMiLCJzcmNJbWciLCJzcmNYIiwic3JjWSIsInNyY1ciLCJzcmNIIiwiZGVzdFgiLCJkZXN0WSIsImRlc3RXIiwiZGVzdEgiLCJ0eCIsInR5IiwidGxYIiwiclRsWCIsInRsWSIsInJUbFkiLCJiclgiLCJyV2lkdGgiLCJiclkiLCJySGVpZ2h0Iiwic2lnbiIsImRyYXdJbWFnZSIsImh5cG90IiwiY29tcGlsZVR5cGUzR2x5cGgiLCJpbWdEYXRhIiwiUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCIsIlBPSU5UX1RZUEVTIiwid2lkdGgxIiwiajAiLCJsaW5lU2l6ZSIsInBvcyIsIm1hc2siLCJjb3VudCIsInN1bSIsInN0ZXBzIiwiSW50MzJBcnJheSIsInBhdGgiLCJwMCIsInBwIiwiZHJhd091dGxpbmUiLCJDYW52YXNFeHRyYVN0YXRlIiwiYWxwaGFJc1NoYXBlIiwiZm9udFNpemVTY2FsZSIsInRleHRNYXRyaXgiLCJJREVOVElUWV9NQVRSSVgiLCJ0ZXh0TWF0cml4U2NhbGUiLCJmb250TWF0cml4IiwiRk9OVF9JREVOVElUWV9NQVRSSVgiLCJsZWFkaW5nIiwibGluZVgiLCJsaW5lWSIsImNoYXJTcGFjaW5nIiwid29yZFNwYWNpbmciLCJ0ZXh0SFNjYWxlIiwidGV4dFJlbmRlcmluZ01vZGUiLCJUZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwicGF0dGVybkZpbGwiLCJzdHJva2VBbHBoYSIsImxpbmVXaWR0aCIsImFjdGl2ZVNNYXNrIiwidHJhbnNmZXJNYXBzIiwic3RhcnROZXdQYXRoQW5kQ2xpcEJveCIsImNsaXBCb3giLCJzZXRDdXJyZW50UG9pbnQiLCJ1cGRhdGVQYXRoTWluTWF4IiwiYXBwbHlUcmFuc2Zvcm0iLCJtaW5YIiwibWF4WCIsInA0IiwidXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgiLCJtaW5NYXgiLCJzY2FsZU1pbk1heCIsInVwZGF0ZUN1cnZlUGF0aE1pbk1heCIsImJveCIsImJlemllckJvdW5kaW5nQm94IiwiZ2V0UGF0aEJvdW5kaW5nQm94IiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJpc0VtcHR5Q2xpcCIsIkluZmluaXR5IiwicHV0QmluYXJ5SW1hZ2VEYXRhIiwiSW1hZ2VEYXRhIiwicGFydGlhbENodW5rSGVpZ2h0IiwiZnVsbENodW5rcyIsInRvdGFsQ2h1bmtzIiwiY2h1bmtJbWdEYXRhIiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImRlc3QzMiIsImRlc3QzMkRhdGFMZW5ndGgiLCJmdWxsU3JjRGlmZiIsIndoaXRlIiwic3JjRGlmZiIsImtFbmQiLCJrRW5kVW5yb2xsZWQiLCJzcmNCeXRlIiwiUkdCQV8zMkJQUCIsInN1YmFycmF5IiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInByb3BlcnR5Iiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJmaWxsUnVsZSIsImdsb2JhbEFscGhhIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImNvbXBvc2VTTWFza0JhY2tkcm9wIiwicjAiLCJnMCIsImIwIiwiYWxwaGEiLCJhbHBoYV8iLCJjb21wb3NlU01hc2tBbHBoYSIsIm1hc2tEYXRhIiwibGF5ZXJEYXRhIiwidHJhbnNmZXJNYXAiLCJjb21wb3NlU01hc2tMdW1pbm9zaXR5IiwiZ2VuZXJpY0NvbXBvc2VTTWFzayIsIm1hc2tDdHgiLCJsYXllckN0eCIsImJhY2tkcm9wIiwibGF5ZXJPZmZzZXRYIiwibGF5ZXJPZmZzZXRZIiwibWFza09mZnNldFgiLCJtYXNrT2Zmc2V0WSIsImhhc0JhY2tkcm9wIiwiY29tcG9zZUZuIiwiUElYRUxTX1RPX1BST0NFU1MiLCJjaHVua1NpemUiLCJyb3ciLCJjaHVua0hlaWdodCIsImdldEltYWdlRGF0YSIsImNvbXBvc2VTTWFzayIsInNtYXNrIiwibGF5ZXJCb3giLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImZyb3VuZCIsImFjdHVhbFNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIlBpeGVsc1BlckluY2giLCJQREZfVE9fQ1NTX1VOSVRTIiwiTElORV9DQVBfU1RZTEVTIiwiTElORV9KT0lOX1NUWUxFUyIsIk5PUk1BTF9DTElQIiwiRU9fQ0xJUCIsImNhbnZhc0N0eCIsIm1hcmtlZENvbnRlbnRTdGFjayIsInN0YXRlU3RhY2siLCJwZW5kaW5nQ2xpcCIsInBlbmRpbmdFT0ZpbGwiLCJyZXMiLCJ4b2JqcyIsImdyb3VwU3RhY2siLCJwcm9jZXNzaW5nVHlwZTMiLCJiYXNlVHJhbnNmb3JtU3RhY2siLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRQYXR0ZXJucyIsInZpZXdwb3J0U2NhbGUiLCJvdXRwdXRTY2FsZVgiLCJvdXRwdXRTY2FsZVkiLCJfY2FjaGVkU2NhbGVGb3JTdHJva2luZyIsIl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoIiwiX2NhY2hlZEJpdG1hcHNNYXAiLCJnZXRPYmplY3QiLCJmYWxsYmFjayIsInN0YXJ0c1dpdGgiLCJzYXZlZEZpbGxTdHlsZSIsImZpbGxSZWN0IiwidHJhbnNwYXJlbnRDYW52YXMiLCJjb21wb3NpdGVDdHgiLCJleGVjdXRpb25TdGFydElkeCIsImNvbnRpbnVlQ2FsbGJhY2siLCJhcmdzQXJyYXlMZW4iLCJjaHVua09wZXJhdGlvbnMiLCJlbmRUaW1lIiwiRGF0ZSIsIm5vdyIsImZuSWQiLCJicmVha0l0IiwiT1BTIiwiZGVwZW5kZW5jeSIsImFwcGx5IiwiZGVwT2JqSWQiLCJvYmpzUG9vbCIsInJlc3RvcmVJbml0aWFsU3RhdGUiLCJpblNNYXNrTW9kZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZHJhd0ZpbHRlciIsImhjbUZpbHRlcklkIiwiZm9yZWdyb3VuZCIsInNhdmVkRmlsdGVyIiwiX3NjYWxlSW1hZ2UiLCJpbWciLCJpbnZlcnNlVHJhbnNmb3JtIiwid2lkdGhTY2FsZSIsImhlaWdodFNjYWxlIiwicGFpbnRXaWR0aCIsInBhaW50SGVpZ2h0IiwidG1wQ2FudmFzSWQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsIl9jcmVhdGVNYXNrQ2FudmFzIiwiaXNQYXR0ZXJuRmlsbCIsImN1cnJlbnRUcmFuc2Zvcm0iLCJzY2FsZWQiLCJtYXNrQ2FudmFzIiwibWFpbktleSIsImNhY2hlZEltYWdlIiwibWFza1RvQ2FudmFzIiwiZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3giLCJkcmF3bldpZHRoIiwiZHJhd25IZWlnaHQiLCJmaWxsQ2FudmFzIiwiZmlsbEN0eCIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsImxpbWl0Iiwic2V0RGFzaCIsImRhc2hBcnJheSIsImRhc2hQaGFzZSIsInNldFJlbmRlcmluZ0ludGVudCIsInNldEZsYXRuZXNzIiwiZmxhdG5lc3MiLCJzZXRHU3RhdGUiLCJzdGF0ZXMiLCJzZXRGb250IiwiY2hlY2tTTWFza1N0YXRlIiwiYmVnaW5TTWFza01vZGUiLCJlbmRTTWFza01vZGUiLCJjYWNoZUlkIiwic2NyYXRjaENhbnZhcyIsImNvbXBvc2UiLCJkaXJ0eUJveCIsIm9sZCIsInBvcCIsImNvbnN0cnVjdFBhdGgiLCJvcHMiLCJhcmdzIiwic3RhcnRYIiwic3RhcnRZIiwiaXNTY2FsaW5nTWF0cml4IiwibWluTWF4Rm9yQmV6aWVyIiwicmVjdGFuZ2xlIiwieHciLCJ5aCIsImN1cnZlVG8iLCJjdXJ2ZVRvMiIsImN1cnZlVG8zIiwic3Ryb2tlIiwiY29uc3VtZVBhdGgiLCJyZXNjYWxlQW5kU3Ryb2tlIiwiY2xvc2VTdHJva2UiLCJuZWVkUmVzdG9yZSIsImVvRmlsbCIsImZpbGxTdHJva2UiLCJlb0ZpbGxTdHJva2UiLCJjbG9zZUZpbGxTdHJva2UiLCJjbG9zZUVPRmlsbFN0cm9rZSIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJwYXRocyIsInBlbmRpbmdUZXh0UGF0aHMiLCJhZGRUb1BhdGgiLCJzZXRDaGFyU3BhY2luZyIsInNwYWNpbmciLCJzZXRXb3JkU3BhY2luZyIsInNldEhTY2FsZSIsInNldExlYWRpbmciLCJmb250UmVmTmFtZSIsImZvbnRPYmoiLCJmb250RGlyZWN0aW9uIiwiaXNUeXBlM0ZvbnQiLCJsb2FkZWROYW1lIiwidHlwZWZhY2UiLCJzeXN0ZW1Gb250SW5mbyIsImNzcyIsImZhbGxiYWNrTmFtZSIsImJvbGQiLCJpdGFsaWMiLCJicm93c2VyRm9udFNpemUiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwicmlzZSIsIm1vdmVUZXh0Iiwic2V0TGVhZGluZ01vdmVUZXh0Iiwic2V0VGV4dE1hdHJpeCIsIm5leHRMaW5lIiwicGFpbnRDaGFyIiwiY2hhcmFjdGVyIiwicGF0dGVyblRyYW5zZm9ybSIsImZpbGxTdHJva2VNb2RlIiwiRklMTF9TVFJPS0VfTUFTSyIsImlzQWRkVG9QYXRoU2V0IiwiQUREX1RPX1BBVEhfRkxBRyIsIm1pc3NpbmdGaWxlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIkZJTExfU1RST0tFIiwiZmlsbFRleHQiLCJzdHJva2VUZXh0IiwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWQiLCJzaG93VGV4dCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImlzSW52YWxpZFBERmpzRm9udCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwicmVzdG9yZU5lZWRlZCIsImlzU3BhY2UiLCJmb250Q2hhciIsImFjY2VudCIsInNjYWxlZFgiLCJzY2FsZWRZIiwidm1ldHJpYyIsInZ4IiwidnkiLCJyZW1lYXN1cmUiLCJtZWFzdXJlZFdpZHRoIiwibWVhc3VyZVRleHQiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJvZmZzZXQiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwiSU5WSVNJQkxFIiwic3BhY2luZ0xlbmd0aCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0Iiwib3BlcmF0b3JMaXN0SWQiLCJ0cmFuc2Zvcm1lZCIsInNldENoYXJXaWR0aCIsInhXaWR0aCIsInlXaWR0aCIsInNldENoYXJXaWR0aEFuZEJvdW5kcyIsImxseCIsImxseSIsInVyeCIsInVyeSIsImdldENvbG9yTl9QYXR0ZXJuIiwiX2dldFBhdHRlcm4iLCJzZXRTdHJva2VDb2xvck4iLCJhcmd1bWVudHMiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzaGFkaW5nRmlsbCIsImludiIsImJlZ2luSW5saW5lSW1hZ2UiLCJiZWdpbkltYWdlRGF0YSIsInBhaW50Rm9ybVhPYmplY3RCZWdpbiIsInBhaW50Rm9ybVhPYmplY3RFbmQiLCJiZWdpbkdyb3VwIiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImJvdW5kcyIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiZW5kR3JvdXAiLCJjdXJyZW50TXR4IiwiYmVnaW5Bbm5vdGF0aW9uIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJhbm5vdGF0aW9uQ2FudmFzIiwic2F2ZWRDdHgiLCJlbmRBbm5vdGF0aW9uIiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0IiwiY29tcGlsZWQiLCJwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQiLCJza2V3WCIsInNrZXdZIiwicG9zaXRpb25zIiwidHJhbnMiLCJwYWludEltYWdlTWFza1hPYmplY3RHcm91cCIsImltYWdlcyIsInBhaW50SW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3QiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInciLCJoIiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cCIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwicGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrIiwibWFya1BvaW50IiwidGFnIiwibWFya1BvaW50UHJvcHMiLCJiZWdpbk1hcmtlZENvbnRlbnQiLCJ2aXNpYmxlIiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJpc0NvbnRlbnRWaXNpYmxlIiwiZW5kTWFya2VkQ29udGVudCIsImJlZ2luQ29tcGF0IiwiZW5kQ29tcGF0IiwiaXNFbXB0eSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwiZ2V0VHJhbnNmb3JtIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwib3AiLCJmZXRjaERhdGEiLCJnZXRDb2xvclZhbHVlcyIsImdldFBkZkZpbGVuYW1lRnJvbVVybCIsImdldFJHQiIsImdldFhmYVBhZ2VWaWV3cG9ydCIsImlzUGRmRmlsZSIsIm5vQ29udGV4dE1lbnUiLCJfYmFzZV9mYWN0b3J5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJfc2hhcmVkX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIlNWR19OUyIsIlBERiIsIl9jYWNoZSIsIl9kZWZzIiwiaGNtRmlsdGVyIiwiaGNtS2V5IiwiaGNtVXJsIiwiaGNtSGlnaGxpZ2h0RmlsdGVyIiwiaGNtSGlnaGxpZ2h0S2V5IiwiaGNtSGlnaGxpZ2h0VXJsIiwiY29udGFpbiIsInBvc2l0aW9uIiwiY3JlYXRlRWxlbWVudE5TIiwiYm9keSIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsIm1hcFIiLCJtYXBHIiwibWFwQiIsImJ1ZmZlclIiLCJidWZmZXJHIiwiYnVmZmVyQiIsImNyZWF0ZUZpbHRlciIsImFkZFRyYW5zZmVyTWFwQ29udmVyc2lvbiIsImZnUkdCIiwiYmdSR0IiLCJ0YWJsZSIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJzdGFydCIsImFyciIsImZnR3JheSIsImJnR3JheSIsIm5ld0ZnUkdCIiwibmV3QmdSR0IiLCJmZyIsImJnIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsInBhcmVudE5vZGUiLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZ1bmMiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl9kb2N1bWVudCIsInJlc3BvbnNlIiwib2siLCJzdGF0dXNUZXh0IiwiYXJyYXlCdWZmZXIiLCJibG9iIiwianNvbiIsInRleHQiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInJlc3BvbnNlVGV4dCIsImNNYXBEYXRhIiwiY2VudGVyWCIsImNlbnRlclkiLCJyb3RhdGVBIiwicm90YXRlQiIsInJvdGF0ZUMiLCJyb3RhdGVEIiwib2Zmc2V0Q2FudmFzWCIsIm9mZnNldENhbnZhc1kiLCJjb252ZXJ0VG9WaWV3cG9ydFBvaW50IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJjb252ZXJ0VG9QZGZQb2ludCIsImFwcGx5SW52ZXJzZVRyYW5zZm9ybSIsIkJhc2VFeGNlcHRpb24iLCJtc2ciLCJ0cmltIiwib25seVN0cmlwUGF0aCIsImxhc3RJbmRleE9mIiwiZGVmYXVsdEZpbGVuYW1lIiwicmVVUkkiLCJyZUZpbGVuYW1lIiwic3BsaXRVUkkiLCJleGVjIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdGFydGVkIiwidGltZXMiLCJvdXRCdWYiLCJsb25nZXN0IiwicGFkRW5kIiwicHJvdG9jb2wiLCJkZXByZWNhdGVkIiwiY29uc29sZSIsImxvZyIsInBkZkRhdGVTdHJpbmdSZWdleCIsImlucHV0IiwiUmVnRXhwIiwibWF0Y2hlcyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ1bml2ZXJzYWxUaW1lUmVsYXRpb24iLCJvZmZzZXRIb3VyIiwib2Zmc2V0TWludXRlIiwiVVRDIiwieGZhUGFnZSIsImF0dHJpYnV0ZXMiLCJjb2xvclJHQiIsInNwYW4iLCJjb21wdXRlZENvbG9yIiwiaW52ZXJ0U2VsZiIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwiaXNDU1NSb3VuZFN1cHBvcnRlZCIsIndpZHRoU3RyIiwiaGVpZ2h0U3RyIiwiRHJhd0xheWVyIiwiX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIm1hcHBpbmciLCJzZXRQYXJlbnQiLCJyb290IiwiX3N2Z0ZhY3RvcnkiLCJzZXRCb3giLCJjcmVhdGVTVkciLCJoaWdobGlnaHQiLCJvdXRsaW5lcyIsIm9wYWNpdHkiLCJwYXRoSWQiLCJleHRyYWN0UGF0aEZyb21IaWdobGlnaHRPdXRsaW5lcyIsImNsaXBQYXRoSWQiLCJjbGlwUGF0aFVzZSIsInVzZSIsImhpZ2hsaWdodE91dGxpbmUiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsInBvbHlnb25zIiwicG9seWdvbiIsInByZXZYIiwicHJldlkiLCJ1cGRhdGVCb3giLCJjaGFuZ2VDb2xvciIsImNoYW5nZU9wYWNpdHkiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiZWRpdG9yX2VkaXRvciIsInRvb2xzIiwiYW5ub3RhdGlvbl9sYXllciIsIkZyZWVUZXh0RWRpdG9yIiwiYm91bmRFZGl0b3JEaXZCbHVyIiwiYm91bmRFZGl0b3JEaXZGb2N1cyIsImJvdW5kRWRpdG9yRGl2SW5wdXQiLCJib3VuZEVkaXRvckRpdktleWRvd24iLCJlZGl0b3JEaXZJZCIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX2tleWJvYXJkTWFuYWdlciIsInByb3RvIiwiYXJyb3dDaGVja2VyIiwic2VsZiIsInNtYWxsIiwiQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIlRSQU5TTEFURV9TTUFMTCIsImJpZyIsIlRSQU5TTEFURV9CSUciLCJLZXlib2FyZE1hbmFnZXIiLCJjb21taXRPclJlbW92ZSIsImJ1YmJsZXMiLCJfdHJhbnNsYXRlRW1wdHkiLCJjaGVja2VyIiwiX2VkaXRvclR5cGUiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZJbnB1dCIsImVkaXRvckRpdktleWRvd24iLCJfZGVmYXVsdExpbmVDb2xvciIsImluaXRpYWxpemUiLCJsMTBuIiwic3RyaW5ncyIsImRvY3VtZW50RWxlbWVudCIsInBhcnNlRmxvYXQiLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUiLCJGUkVFVEVYVF9TSVpFIiwiRlJFRVRFWFRfQ09MT1IiLCJ1cGRhdGVQYXJhbXMiLCJ1cGRhdGVGb250U2l6ZSIsInVwZGF0ZUNvbG9yIiwiZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSIsInByb3BlcnRpZXNUb1VwZGF0ZSIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2IiwicGFyZW50U2NhbGUiLCJzZXRFZGl0b3JEaW1lbnNpb25zIiwic2F2ZWRGb250c2l6ZSIsImFkZENvbW1hbmRzIiwiY21kIiwidW5kbyIsIm11c3RFeGVjIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwic2F2ZWRDb2xvciIsIl91aU1hbmFnZXIiLCJ0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJyZWJ1aWxkIiwiaXNBdHRhY2hlZFRvRE9NIiwiZW5hYmxlRWRpdE1vZGUiLCJpc0luRWRpdE1vZGUiLCJzZXRFZGl0aW5nU3RhdGUiLCJ1cGRhdGVUb29sYmFyIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsIl9pc0RyYWdnYWJsZSIsImRpc2FibGVFZGl0TW9kZSIsImlzRWRpdGluZyIsImZvY3VzaW4iLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwib25jZUFkZGVkIiwiY2hlYXRJbml0aWFsUmVjdCIsIl9pbml0aWFsT3B0aW9ucyIsImlzQ2VudGVyZWQiLCJjZW50ZXIiLCJpbm5lclRleHQiLCJleHRyYWN0VGV4dCIsImRpdnMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInJlcGxhY2UiLCJwYXJlbnRIZWlnaHQiLCJwYXJlbnREaW1lbnNpb25zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY3VycmVudExheWVyIiwic2F2ZWREaXNwbGF5IiwicGFyZW50Um90YXRpb24iLCJmaXhBbmRTZXRQb3NpdGlvbiIsImNvbW1pdCIsInNhdmVkVGV4dCIsIm5ld1RleHQiLCJ0cmltRW5kIiwic2V0VGV4dCIsInNldENvbnRlbnQiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsImVudGVySW5FZGl0TW9kZSIsImRibGNsaWNrIiwia2V5ZG93biIsImRpc2FibGVFZGl0aW5nIiwiZW5hYmxlRWRpdGluZyIsImJhc2VYIiwiYmFzZVkiLCJfbDEwblByb21pc2UiLCJiaW5kRXZlbnRzIiwiYW5ub3RhdGlvbkVsZW1lbnRJZCIsInBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuIiwicGFnZURpbWVuc2lvbnMiLCJwYWdlVHJhbnNsYXRpb24iLCJwb3NYIiwicG9zWSIsInNldEF0IiwicmVwbGFjZUNoaWxkcmVuIiwiY29udGVudERpdiIsImRlc2VyaWFsaXplIiwidWlNYW5hZ2VyIiwiZGVsZXRlZCIsImVkaXRvciIsImlzRm9yQ29weWluZyIsInBhZGRpbmciLCJnZXRSZWN0IiwiX2NvbG9yTWFuYWdlciIsImNvbnZlcnQiLCJzdHJ1Y3RUcmVlUGFyZW50SWQiLCJfc3RydWN0VHJlZVBhcmVudElkIiwiaGFzRWxlbWVudENoYW5nZWQiLCJzb21lIiwiY29sb3JfcGlja2VyIiwiZWRpdG9yX291dGxpbmVyIiwiSGlnaGxpZ2h0RWRpdG9yIiwiYm94ZXMiLCJjb2xvclBpY2tlciIsImZvY3VzT3V0bGluZXMiLCJoaWdobGlnaHREaXYiLCJoaWdobGlnaHRPdXRsaW5lcyIsImxhc3RQb2ludCIsIm91dGxpbmVJZCIsIl9kZWZhdWx0T3BhY2l0eSIsImhpZ2hsaWdodENvbG9ycyIsIm5leHQiLCJjcmVhdGVPdXRsaW5lcyIsImFkZFRvRHJhd0xheWVyIiwib3V0bGluZXIiLCJPdXRsaW5lciIsImdldE91dGxpbmVzIiwib3V0bGluZXJGb3JPdXRsaW5lIiwiZGlyZWN0aW9uIiwiSElHSExJR0hUX0RFRkFVTFRfQ09MT1IiLCJ0b29sYmFyUG9zaXRpb24iLCJISUdITElHSFRfQ09MT1IiLCJkcmF3TGF5ZXIiLCJhZGRFZGl0VG9vbGJhciIsInRvb2xiYXIiLCJDb2xvclBpY2tlciIsImFkZENvbG9yUGlja2VyIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjbGVhbkRyYXdMYXllciIsIm11c3RCZVNlbGVjdGVkIiwiY29udGFpbnMiLCJzZWxlY3QiLCJyb3RhdGVCYm94Iiwic2V0RGltcyIsInBvaW50ZXJvdmVyIiwicG9pbnRlcmxlYXZlIiwidW5zZWxlY3QiLCJzZXJpYWxpemVCb3hlcyIsInN4Iiwic3kiLCJzZXJpYWxpemVPdXRsaW5lcyIsIm91dGxpbmUiLCJjYW5DcmVhdGVOZXdFbXB0eUVkaXRvciIsIklua0VkaXRvciIsImJhc2VIZWlnaHQiLCJiYXNlV2lkdGgiLCJib3VuZENhbnZhc1BvaW50ZXJtb3ZlIiwiYm91bmRDYW52YXNQb2ludGVybGVhdmUiLCJib3VuZENhbnZhc1BvaW50ZXJ1cCIsImJvdW5kQ2FudmFzUG9pbnRlcmRvd24iLCJjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCIsImN1cnJlbnRQYXRoMkQiLCJoYXNTb21ldGhpbmdUb0RyYXciLCJpc0NhbnZhc0luaXRpYWxpemVkIiwib2JzZXJ2ZXIiLCJyZWFsV2lkdGgiLCJyZWFsSGVpZ2h0IiwicmVxdWVzdEZyYW1lQ2FsbGJhY2siLCJfZGVmYXVsdFRoaWNrbmVzcyIsImNhbnZhc1BvaW50ZXJtb3ZlIiwiY2FudmFzUG9pbnRlcmxlYXZlIiwiY2FudmFzUG9pbnRlcnVwIiwiY2FudmFzUG9pbnRlcmRvd24iLCJ0aGlja25lc3MiLCJiZXppZXJQYXRoMkQiLCJhbGxSYXdQYXRocyIsImN1cnJlbnRQYXRoIiwic2NhbGVGYWN0b3IiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJfd2lsbEtlZXBBc3BlY3RSYXRpbyIsIklOS19USElDS05FU1MiLCJJTktfQ09MT1IiLCJJTktfT1BBQ0lUWSIsInVwZGF0ZVRoaWNrbmVzcyIsInVwZGF0ZU9wYWNpdHkiLCJzYXZlZFRoaWNrbmVzcyIsImZpdFRvQ29udGVudCIsInJlZHJhdyIsInNhdmVkT3BhY2l0eSIsImNyZWF0ZUNhbnZhcyIsImNyZWF0ZU9ic2VydmVyIiwic2V0Q2FudmFzRGltcyIsImRpc2Nvbm5lY3QiLCJyZW1vdmVTaG91bGRSZXNjYWxlIiwiYWRkU2hvdWxkUmVzY2FsZSIsIm9uU2NhbGVDaGFuZ2luZyIsInNldERpbWVuc2lvbnMiLCJnZXRJbml0aWFsQkJveCIsInNldFN0cm9rZSIsIm9wYWNpdHlUb0hleCIsInN0YXJ0RHJhd2luZyIsImRyYXdQb2ludHMiLCJkcmF3IiwibGFzdFgiLCJsYXN0WSIsImF0IiwicGF0aDJEIiwibWFrZUJlemllckN1cnZlIiwic3RvcERyYXdpbmciLCJiZXppZXIiLCJnZW5lcmF0ZUJlemllclBvaW50cyIsInh5IiwibGFzdFBvaW50cyIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJiZXppZXJQb2ludHMiLCJjb250cm9sMSIsImNvbnRyb2wyIiwidXBkYXRlVHJhbnNmb3JtIiwic2V0SW5Gb3JlZ3JvdW5kIiwiYWRkSW5rRWRpdG9ySWZOZWVkZWQiLCJtb3ZlSW5ET00iLCJidXR0b24iLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwic2V0SW5CYWNrZ3JvdW5kIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJpc1Jlc2l6YWJsZSIsInNldEFzcGVjdFJhdGlvIiwicm91bmRlZFdpZHRoIiwicm91bmRlZEhlaWdodCIsInNldFNjYWxlRmFjdG9yIiwiZml4RGltcyIsImdldFBhZGRpbmciLCJzY2FsZUZhY3RvclciLCJzY2FsZUZhY3RvckgiLCJidWlsZFBhdGgyRCIsImZpcnN0IiwidG9QREZDb29yZGluYXRlcyIsImZyb21QREZDb29yZGluYXRlcyIsInNlcmlhbGl6ZVBhdGhzIiwicyIsInNoaWZ0WCIsInNoaWZ0WSIsInAxMCIsInAxMSIsInAyMCIsInAyMSIsInAzMCIsInAzMSIsInA0MCIsInA0MSIsImdldEJib3giLCJmaXJzdFRpbWUiLCJNSU5fU0laRSIsInByZXZUcmFuc2xhdGlvblgiLCJwcmV2VHJhbnNsYXRpb25ZIiwidW5zY2FsZWRQYWRkaW5nIiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJyZXNpemVUaW1lb3V0SWQiLCJpc1N2ZyIsImhhc0JlZW5BZGRlZEluVW5kb1N0YWNrIiwic3VwcG9ydGVkVHlwZXMiLCJ0eXBlcyIsInN1cHBvcnRlZFR5cGVzU3RyIiwiaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nIiwibWltZSIsInBhc3RlIiwicGFzdGVFZGl0b3IiLCJnZXRBc0ZpbGUiLCJnZXRCaXRtYXBGZXRjaGVkIiwiZnJvbUlkIiwiZ2V0Qml0bWFwRG9uZSIsImVuYWJsZVdhaXRpbmciLCJnZXRCaXRtYXAiLCJpbWFnZU1hbmFnZXIiLCJnZXRGcm9tSWQiLCJnZXRGcm9tVXJsIiwiZ2V0RnJvbUZpbGUiLCJhY2NlcHQiLCJmaWxlcyIsImNsaWNrIiwiZGVsZXRlSWQiLCJNQVhfUkFUSU8iLCJmYWN0b3IiLCJkcmF3Qml0bWFwIiwiX2V2ZW50QnVzIiwiZWRpdG9yVHlwZSIsImFkZEFsdFRleHRCdXR0b24iLCJUSU1FX1RPX1dBSVQiLCJzY2FsZUJpdG1hcCIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0IiwicHJldldpZHRoIiwicHJldkhlaWdodCIsIm9mZnNjcmVlbiIsIk9mZnNjcmVlbkNhbnZhcyIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsImdldEltYWdlRm9yQWx0VGV4dCIsInNlcmlhbGl6ZUJpdG1hcCIsInRvVXJsIiwiZ2V0U3ZnVXJsIiwidG9EYXRhVVJMIiwiYWNjZXNzaWJpbGl0eURhdGEiLCJpc1ZhbGlkSWQiLCJhbHRUZXh0RGF0YSIsImRlY29yYXRpdmUiLCJhbHRUZXh0IiwiYWx0Iiwic3RhbXBzIiwiYXJlYSIsInByZXZEYXRhIiwiYWxsb3dDbGljayIsImFubm90YXRpb25MYXllciIsImJvdW5kUG9pbnRlcnVwIiwiYm91bmRQb2ludGVyVXBBZnRlclNlbGVjdGlvbiIsImJvdW5kUG9pbnRlcmRvd24iLCJlZGl0b3JGb2N1c1RpbWVvdXRJZCIsImJvdW5kU2VsZWN0aW9uU3RhcnQiLCJlZGl0b3JzIiwiaGFkUG9pbnRlckRvd24iLCJpc0NsZWFuaW5nVXAiLCJpc0Rpc2FibGluZyIsInRleHRMYXllciIsIl9pbml0aWFsaXplZCIsImVkaXRvclR5cGVzIiwicG9pbnRlcnVwIiwicG9pbnRlclVwQWZ0ZXJTZWxlY3Rpb24iLCJwb2ludGVyZG93biIsInJlZ2lzdGVyRWRpdG9yVHlwZXMiLCJhZGRMYXllciIsInVwZGF0ZU1vZGUiLCJnZXRNb2RlIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJ0b2dnbGVQb2ludGVyRXZlbnRzIiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsImVuYWJsZUNsaWNrIiwiaXNDb21taXR0aW5nIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwiZW5hYmxlIiwiYW5ub3RhdGlvbkVsZW1lbnRJZHMiLCJlZGl0YWJsZXMiLCJpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsImFkZE9yUmVidWlsZCIsImRpc2FibGUiLCJoaWRkZW5Bbm5vdGF0aW9uSWRzIiwic2V0QWN0aXZlRWRpdG9yIiwiY3VycmVudEFjdGl2ZSIsImdldEFjdGl2ZSIsImF0dGFjaCIsInJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsImRldGFjaCIsInJlbW92ZVBvaW50ZXJJblRleHRMYXllciIsImFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZUVkaXRvciIsImNoYW5nZVBhcmVudCIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiYWRkRWRpdG9yIiwibW92ZUVkaXRvckluRE9NIiwib25jZSIsIm5lZWRzVG9CZVJlYnVpbHQiLCJnZXROZXh0SWQiLCJnZXRJZCIsImN1cnJlbnRFZGl0b3JUeXBlIiwiY3JlYXRlTmV3RWRpdG9yIiwiZ2V0Q2VudGVyUG9pbnQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJhZGROZXdFZGl0b3IiLCJzZXRTZWxlY3RlZCIsInRvZ2dsZVNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsIl9ldmVudCIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiY29sbGFwc2VkIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJsYXllclgiLCJsYXllclkiLCJiYm94ZXMiLCJnZXRDbGllbnRSZWN0cyIsInJvdGF0b3IiLCJlbXB0eSIsInVuc2VsZWN0QWxsIiwiZmluZE5ld1BhcmVudCIsImZpbmRQYXJlbnQiLCJyZW1vdmVMYXllciIsImdldEVkaXRvcnMiLCJvbGRSb3RhdGlvbiIsIl90b29sc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiYnV0dG9uU3dhdGNoIiwiZGVmYXVsdENvbG9yIiwiZHJvcGRvd24iLCJkcm9wZG93bldhc0Zyb21LZXlib2FyZCIsImlzTWFpbkNvbG9yUGlja2VyIiwiX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCIsIl9jb2xvclNlbGVjdEZyb21LZXlib2FyZCIsIl9tb3ZlVG9OZXh0IiwiX21vdmVUb1ByZXZpb3VzIiwiX21vdmVUb0JlZ2lubmluZyIsIl9tb3ZlVG9FbmQiLCJyZW5kZXJCdXR0b24iLCJvcGVuRHJvcGRvd24iLCJzd2F0Y2giLCJyZW5kZXJNYWluRHJvcGRvd24iLCJnZXREcm9wZG93blJvb3QiLCJwYXJhbVR5cGUiLCJyb2xlIiwiY29sb3JTZWxlY3QiLCJzdG9wUHJvcGFnYXRpb24iLCJuZXh0U2libGluZyIsImhpZGVEcm9wZG93biIsImZvY3VzVmlzaWJsZSIsImNoaWxkIiwiQWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0IiwiYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCIsImwxMG5Qcm9taXNlIiwib25DbGljayIsImVkaXRBbHRUZXh0IiwiY2FwdHVyZSIsInNldFN0YXRlIiwiZmluaXNoIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsIkVkaXRvclRvb2xiYXIiLCJidXR0b25zIiwiZWRpdFRvb2xiYXIiLCJwb2ludGVyRG93biIsImluc2V0SW5saW5lRW5kIiwiYWRkRGVsZXRlQnV0dG9uIiwiZm9jdXNJbiIsImZvY3VzT3V0IiwiYWRkTGlzdGVuZXJzVG9FbGVtZW50IiwiZGl2aWRlciIsImFsbFJlc2l6ZXJEaXZzIiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJzYXZlZERpbWVuc2lvbnMiLCJib3VuZEZvY3VzaW4iLCJib3VuZEZvY3Vzb3V0IiwiZm9jdXNlZFJlc2l6ZXJOYW1lIiwiaGFzQmVlbkNsaWNrZWQiLCJpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQiLCJtb3ZlSW5ET01UaW1lb3V0IiwiaXNEcmFnZ2FibGUiLCJfYm9yZGVyTGluZVdpZHRoIiwiQ29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyIiwicmVzaXplIiwiX3Jlc2l6ZVdpdGhLZXlib2FyZCIsIl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQiLCJmb2N1c291dCIsInBhZ2VSb3RhdGlvbiIsInZpZXdQYXJhbWV0ZXJzIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRIZXhDb2RlIiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJfdmFsdWUiLCJpc0VudGVySGFuZGxlZCIsInN0b3BSZXNpemluZyIsImNsb3Nlc3QiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwic2NyZWVuVG9QYWdlVHJhbnNsYXRpb24iLCJ0cmFuc2xhdGVJblBhZ2UiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZHJhZyIsImJ4IiwiYnkiLCJnZXRCYXNlVHJhbnNsYXRpb24iLCJ0b0ZpeGVkIiwicm90YXRlUG9pbnQiLCJnZXRSb3RhdGlvbk1hdHJpeCIsInJlYWxTY2FsZSIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwid2lkdGhQZXJjZW50IiwiZW5kc1dpdGgiLCJoZWlnaHRQZXJjZW50IiwiY3JlYXRlUmVzaXplcnMiLCJjbGFzc2VzIiwicmVzaXplclBvaW50ZXJkb3duIiwiYm91bmRSZXNpemVyUG9pbnRlcm1vdmUiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZERyYWdnYWJsZSIsInBvaW50ZXJNb3ZlT3B0aW9ucyIsInBhc3NpdmUiLCJzYXZlZFgiLCJzYXZlZFkiLCJzYXZlZFdpZHRoIiwic2F2ZWRIZWlnaHQiLCJzYXZlZFBhcmVudEN1cnNvciIsImN1cnNvciIsInNhdmVkQ3Vyc29yIiwicG9pbnRlclVwQ2FsbGJhY2siLCJhZGRSZXNpemVUb1VuZG9TdGFjayIsIm5ld1giLCJuZXdZIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJwb2ludCIsIm9wcG9zaXRlUG9pbnQiLCJ0cmFuc2ZPcHBvc2l0ZVBvaW50Iiwib3Bwb3NpdGVYIiwib3Bwb3NpdGVZIiwicmF0aW9YIiwicmF0aW9ZIiwiZGVsdGFYIiwiZGVsdGFZIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwib2xkRGlhZyIsImFsdFRleHRGaW5pc2giLCJyZW1vdmVFZGl0VG9vbGJhciIsImdldENsaWVudERpbWVuc2lvbnMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInNldFVwRHJhZ1Nlc3Npb24iLCJzZWxlY3RPblBvaW50ZXJFdmVudCIsInBvaW50ZXJNb3ZlQ2FsbGJhY2siLCJkcmFnU2VsZWN0ZWRFZGl0b3JzIiwiZW5kRHJhZ1Nlc3Npb24iLCJfc2V0UGFyZW50QW5kUG9zaXRpb24iLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwiX2FuZ2xlIiwibWFrZVJlc2l6YWJsZSIsImJvdW5kUmVzaXplcktleWRvd24iLCJyZXNpemVyS2V5ZG93biIsImJvdW5kUmVzaXplckJsdXIiLCJyZXNpemVyQmx1ciIsInJlc2l6ZXJGb2N1cyIsImZpcnN0UG9zaXRpb24iLCJuZXh0Rmlyc3RQb3NpdGlvbiIsInNldFJlc2l6ZXJUYWJJbmRleCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImFzcGVjdFJhdGlvIiwidmVydGljYWxFZGdlcyIsImludGVydmFscyIsImlubmVyTWFyZ2luIiwiaXNMVFIiLCJOVU1CRVJfT0ZfRElHSVRTIiwiRVBTSUxPTiIsInJpZ2h0Iiwic2hpZnRlZE1pblgiLCJzaGlmdGVkTWluWSIsImxhc3RFZGdlIiwiZWRnZSIsInNvcnQiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwibGFzdFBvaW50WCIsImxhc3RQb2ludFkiLCJiaW5hcnlTZWFyY2giLCJhcnJheSIsIm1pZGRsZSIsInNwbGljZSIsInk0IiwiX2Rpc3BsYXlfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIklkTWFuYWdlciIsIkFubm90YXRpb25FZGl0b3JQcmVmaXgiLCJJbWFnZU1hbmFnZXIiLCJiYXNlSWQiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwiSW1hZ2UiLCJkZWNvZGUiLCJyYXdEYXRhIiwicmVmQ291bnRlciIsIm11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsImltYWdlRWxlbWVudCIsImltYWdlUHJvbWlzZSIsIm9ubG9hZCIsInN2Z1VybCIsInJlc3VsdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJsYXN0TW9kaWZpZWQiLCJnZXRVdWlkIiwiQ29tbWFuZE1hbmFnZXIiLCJjb21tYW5kcyIsImxvY2tlZCIsInJlZG8iLCJoYXNTb21ldGhpbmdUb1VuZG8iLCJoYXNTb21ldGhpbmdUb1JlZG8iLCJjYWxsYmFja3MiLCJhbGxLZXlzIiwiaXNNYWNLZXkiLCJfY29sb3JzTWFwcGluZyIsIm1hdGNoTWVkaWEiLCJSR0IiLCJldmVyeSIsImFjdGl2ZUVkaXRvciIsImFsbEVkaXRvcnMiLCJhbGxMYXllcnMiLCJhbHRUZXh0TWFuYWdlciIsImNvbW1hbmRNYW5hZ2VyIiwiY3VycmVudFBhZ2VJbmRleCIsImRlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMiLCJkcmFnZ2luZ0VkaXRvcnMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNXYWl0aW5nIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJzZWxlY3RlZEVkaXRvcnMiLCJib3VuZEJsdXIiLCJib3VuZEZvY3VzIiwiYm91bmRDb3B5IiwiYm91bmRDdXQiLCJib3VuZFBhc3RlIiwiYm91bmRLZXlkb3duIiwiYm91bmRPbkVkaXRpbmdBY3Rpb24iLCJib3VuZE9uUGFnZUNoYW5naW5nIiwiYm91bmRPblNjYWxlQ2hhbmdpbmciLCJib3VuZE9uUm90YXRpb25DaGFuZ2luZyIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsInZpZXdlciIsInRhZ05hbWUiLCJoYXNTb21ldGhpbmdUb0NvbnRyb2wiLCJ0ZXh0SW5wdXRDaGVja2VyIiwiX3NlbGYiLCJlbCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJzZWxlY3RBbGwiLCJhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQiLCJIVE1MQnV0dG9uRWxlbWVudCIsInBkZkRvY3VtZW50IiwiYmx1ciIsImNvcHkiLCJjdXQiLCJvbkVkaXRpbmdBY3Rpb24iLCJvblBhZ2VDaGFuZ2luZyIsIm9uUm90YXRpb25DaGFuZ2luZyIsImhhc1NlbGVjdGVkRWRpdG9yIiwiX29uIiwicmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyIiwicmVtb3ZlRm9jdXNNYW5hZ2VyIiwiX29mZiIsInBhaXIiLCJzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJmb2N1c01haW5Db250YWluZXIiLCJkaXNhYmxlVXNlclNlbGVjdCIsInBhZ2VzUm90YXRpb24iLCJhZGRGb2N1c01hbmFnZXIiLCJoYXNTZWxlY3Rpb24iLCJsYXN0RWRpdG9yIiwiYWRkS2V5Ym9hcmRNYW5hZ2VyIiwiYWRkQ29weVBhc3RlTGlzdGVuZXJzIiwicmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzIiwiYWRkRWRpdExpc3RlbmVycyIsInJlbW92ZUVkaXRMaXN0ZW5lcnMiLCJjbGlwYm9hcmREYXRhIiwic2V0RGF0YSIsInBhcnNlIiwibmV3RWRpdG9ycyIsImRlc2VyaWFsaXplZEVkaXRvciIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkIiwiZGlzcGF0Y2hVcGRhdGVTdGF0ZXMiLCJoYXNDaGFuZ2VkIiwiZGlzcGF0Y2hVcGRhdGVVSSIsImdldExheWVyIiwiaXNGcm9tS2V5Ym9hcmQiLCJkaXNhYmxlQWxsIiwiZW5hYmxlQWxsIiwiQ1JFQVRFIiwibXVzdFdhaXQiLCJnZXRFZGl0b3IiLCJlZCIsImZpcnN0U2VsZWN0ZWRFZGl0b3IiLCJub0NvbW1pdCIsInRvdGFsWCIsInRvdGFsWSIsInNhdmVkUGFnZUluZGV4IiwibmV3UGFnZUluZGV4IiwibXVzdEJlQWRkZWRJblVuZG9TdGFjayIsIm1vdmUiLCJpc0FjdGl2ZSIsIl9uZXR3b3JrX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjcmVhdGVGZXRjaE9wdGlvbnMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwibWV0aG9kIiwic2lnbmFsIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImNyZWF0ZUhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0QXJyYXlCdWZmZXIiLCJpc0h0dHAiLCJfZnVsbFJlcXVlc3RSZWFkZXIiLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgiLCJfbG9hZGVkIiwiUERGRmV0Y2hTdHJlYW1SZWFkZXIiLCJQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIiwic3RyZWFtIiwiX3N0cmVhbSIsIl9yZWFkZXIiLCJfZmlsZW5hbWUiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2NvbnRlbnRMZW5ndGgiLCJfaGVhZGVyc0NhcGFiaWxpdHkiLCJfZGlzYWJsZVJhbmdlIiwiX3JhbmdlQ2h1bmtTaXplIiwiX2Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIl9pc1N0cmVhbWluZ1N1cHBvcnRlZCIsIl9pc1JhbmdlU3VwcG9ydGVkIiwiX2hlYWRlcnMiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciIsImdldFJlc3BvbnNlSGVhZGVyIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwidmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMiLCJleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyIiwiX3JlYWRDYXBhYmlsaXR5Iiwic3lzdGVtRm9udHMiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJfaW5zcGVjdEZvbnQiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJhdHRhY2hlZCIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsInN1cHBvcnRlZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImNvbXBsZXRlUmVxdWVzdCIsIm90aGVyUmVxdWVzdCIsIl9sb2FkVGVzdEZvbnQiLCJ0ZXN0Rm9udCIsImF0b2IiLCJpbnQzMiIsImNoYXJDb2RlQXQiLCJzcGxpY2VTdHJpbmciLCJjaHVuazEiLCJjaHVuazIiLCJjYWxsZWQiLCJpc0ZvbnRSZWFkeSIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsInN0cmluZzMyIiwiYnRvYSIsImZvbnRGYW1pbHkiLCJ0cmFuc2xhdGVkRGF0YSIsImNvbXBpbGVkR2x5cGhzIiwiY3NzRm9udEluZm8iLCJ3ZWlnaHQiLCJmb250V2VpZ2h0IiwiaXRhbGljQW5nbGUiLCJieXRlc1RvU3RyaW5nIiwibWltZXR5cGUiLCJjbWRzIiwianNCdWYiLCJGdW5jdGlvbiIsIm1ldGFkYXRhTWFwIiwicGFyc2VkRGF0YSIsImdldFJhdyIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwieGhyIiwiTmV0d29ya01hbmFnZXIiLCJjdXJyWGhySWQiLCJwZW5kaW5nUmVxdWVzdHMiLCJyZXF1ZXN0UmFuZ2UiLCJwcm9wIiwicmVxdWVzdEZ1bGwiLCJ4aHJJZCIsInBlbmRpbmdSZXF1ZXN0Iiwic2V0UmVxdWVzdEhlYWRlciIsImV4cGVjdGVkU3RhdHVzIiwib25FcnJvciIsIm9uU3RhdGVDaGFuZ2UiLCJvbnByb2dyZXNzIiwib25IZWFkZXJzUmVjZWl2ZWQiLCJvbkRvbmUiLCJ4aHJTdGF0dXMiLCJva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0IiwicmFuZ2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIl9zb3VyY2UiLCJfbWFuYWdlciIsIl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZCIsImluZGV4T2YiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX29uUHJvZ3Jlc3MiLCJfdXJsIiwiX2Z1bGxSZXF1ZXN0SWQiLCJfaGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSIsIl9jYWNoZWRDaHVua3MiLCJfcmVxdWVzdHMiLCJfZG9uZSIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsInJlcXVlc3RDYXBhYmlsaXR5IiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfcXVldWVkQ2h1bmsiLCJfY2xvc2UiLCJnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIiLCJjb250ZW50RGlzcG9zaXRpb24iLCJuZWVkc0VuY29kaW5nRml4dXAiLCJ0b1BhcmFtUmVnRXhwIiwicmZjMjYxNnVucXVvdGUiLCJ1bmVzY2FwZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJlbmNvZGluZyIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiY29udGVudERpc3Bvc2l0aW9uU3RyIiwiaXRlciIsInF1b3QiLCJwYXJ0IiwicGFydHMiLCJxdW90aW5kZXgiLCJleHR2YWx1ZSIsImVuY29kaW5nZW5kIiwibGFuZ3ZhbHVlIiwiY2hhcnNldCIsImhleCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJldHVyblZhbHVlcyIsImNvbnRlbnRFbmNvZGluZyIsImZzIiwiaHR0cCIsImh0dHBzIiwiZmlsZVVyaVJlZ2V4IiwicGFyc2VVcmwiLCJzb3VyY2VVcmwiLCJwYXJzZWRVcmwiLCJob3N0IiwiaXNGc1VybCIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnVsbFJlYWRlciIsIlBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIiwiUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyIiwiQmFzZUZ1bGxSZWFkZXIiLCJfcmVhZGFibGVTdHJlYW0iLCJfZXJyb3IiLCJfc2V0UmVhZGFibGVTdHJlYW0iLCJCYXNlUmFuZ2VSZWFkZXIiLCJjcmVhdGVSZXF1ZXN0T3B0aW9ucyIsImF1dGgiLCJob3N0bmFtZSIsImhhbmRsZVJlc3BvbnNlIiwic3RhdHVzQ29kZSIsIl9yZXF1ZXN0IiwiX2h0dHBIZWFkZXJzIiwiUmFuZ2UiLCJsc3RhdCIsInN0YXQiLCJjcmVhdGVSZWFkU3RyZWFtIiwicGF0aDJkX3BvbHlmaWxsIiwicmVhZEZpbGUiLCJfc2hhcmVkX211cm11cmhhc2gzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJJTlRFUk5BTCIsIk9wdGlvbmFsQ29udGVudEdyb3VwIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwib3BlcmF0b3IiLCJzdGF0ZSIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJzZXRWaXNpYmlsaXR5IiwiaGFzSW5pdGlhbFZpc2liaWxpdHkiLCJnZXRPcmRlciIsImdldEdyb3VwcyIsImdldEdyb3VwIiwicmVuZGVyVGV4dExheWVyIiwidXBkYXRlVGV4dExheWVyIiwiTUFYX1RFWFRfRElWU19UT19SRU5ERVIiLCJERUZBVUxUX0ZPTlRfQVNDRU5UIiwiYXNjZW50Q2FjaGUiLCJnZXRDdHgiLCJnZXRBc2NlbnQiLCJjYWNoZWRBc2NlbnQiLCJtZXRyaWNzIiwiYXNjZW50IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZGVzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsInBpeGVscyIsImFwcGVuZFRleHQiLCJnZW9tIiwidGV4dERpdiIsInRleHREaXZQcm9wZXJ0aWVzIiwiaGFzVGV4dCIsImhhc0VPTCIsIl90ZXh0RGl2cyIsIl90cmFuc2Zvcm0iLCJhdGFuMiIsImZvbnROYW1lIiwiUEkiLCJfZm9udEluc3BlY3RvckVuYWJsZWQiLCJmb250U3Vic3RpdHV0aW9uIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJfaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiX2NvbnRhaW5lciIsIl9yb290Q29udGFpbmVyIiwiX3BhZ2VXaWR0aCIsIl9wYWdlSGVpZ2h0IiwiZGF0YXNldCIsImZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiX3RleHREaXZQcm9wZXJ0aWVzIiwiX2lzUmVhZGFibGVTdHJlYW0iLCJfbGF5b3V0VGV4dCIsImxheW91dCIsInByZXZGb250U2l6ZSIsInByZXZGb250RmFtaWx5IiwiX2NhbmNlbGVkIiwidGV4dERpdnMiLCJ0ZXh0RGl2c0xlbmd0aCIsIlRleHRMYXllclJlbmRlclRhc2siLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJfdGV4dENvbnRlbnRTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbSIsIl90ZXh0Q29udGVudEl0ZW1zU3RyIiwiX2xheW91dFRleHRQYXJhbXMiLCJfcHJvY2Vzc0l0ZW1zIiwic3R5bGVDYWNoZSIsImJyIiwiX3JlbmRlciIsIm11c3RSZXNjYWxlIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX3F1ZXVlZENodW5rcyIsIl9wcm9ncmVzc2l2ZURvbmUiLCJfY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX3JhbmdlUmVhZGVycyIsIl9vblJlY2VpdmVEYXRhIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwiX2VucXVldWUiLCJmb3VuZCIsIl9iZWdpbiIsIl9yZW1vdmVSYW5nZVJlYWRlciIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIiLCJfaGVhZGVyc1JlYWR5IiwiX2VuZCIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsIl94ZmFfdGV4dF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwic2V0dXBTdG9yYWdlIiwieGZhT24iLCJ4ZmFPZmYiLCJzZXRBdHRyaWJ1dGVzIiwiaXNIVE1MQW5jaG9yRWxlbWVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiZGF0YUlkIiwicm9vdEh0bWwiLCJpc05vdEZvclJpY2hUZXh0Iiwicm9vdERpdiIsIm5vZGUiLCJzaG91bGRCdWlsZFRleHQiLCJzdGFjayIsImNoaWxkSHRtbCIsInhtbG5zIiwicXVlcnlTZWxlY3RvckFsbCIsIm91dHB1dCIsIndhbGsiLCJfZGlzcGxheV9lZGl0b3JfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsIl9kaXNwbGF5X2VkaXRvcl90b29sc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiX2Rpc3BsYXlfYW5ub3RhdGlvbl9sYXllcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiX2Rpc3BsYXlfZWRpdG9yX2NvbG9yX3BpY2tlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiX2Rpc3BsYXlfZGlzcGxheV91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiX2Rpc3BsYXlfZHJhd19sYXllcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fIiwiX2Rpc3BsYXlfd29ya2VyX29wdGlvbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyIsIl9kaXNwbGF5X2VkaXRvcl9vdXRsaW5lcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyIsIl9kaXNwbGF5X2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiUGFzc3dvcmRSZXNwb25zZXMiLCJQZXJtaXNzaW9uRmxhZyIsIlZlcmJvc2l0eUxldmVsIiwiX2Rpc3BsYXlfeGZhX2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJfZGlzcGxheV90ZXh0X2xheWVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJwZGZqc1ZlcnNpb24iLCJwZGZqc0J1aWxkIiwiX3V0aWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIkNhbGxiYWNrS2luZCIsIlVOS05PV04iLCJEQVRBIiwiRVJST1IiLCJTdHJlYW1LaW5kIiwiQ0FOQ0VMIiwiQ0FOQ0VMX0NPTVBMRVRFIiwiQ0xPU0UiLCJFTlFVRVVFIiwiUFVMTCIsIlBVTExfQ09NUExFVEUiLCJTVEFSVF9DT01QTEVURSIsIndyYXBSZWFzb24iLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImNvbU9iaiIsImNhbGxiYWNrSWQiLCJzdHJlYW1JZCIsInN0cmVhbVNpbmtzIiwic3RyZWFtQ29udHJvbGxlcnMiLCJjYWxsYmFja0NhcGFiaWxpdGllcyIsImFjdGlvbkhhbmRsZXIiLCJfb25Db21PYmpPbk1lc3NhZ2UiLCJwcm9jZXNzU3RyZWFtTWVzc2FnZSIsImNiU291cmNlTmFtZSIsImNiVGFyZ2V0TmFtZSIsImNyZWF0ZVN0cmVhbVNpbmsiLCJoYW5kbGVyIiwiYWgiLCJ0cmFuc2ZlcnMiLCJxdWV1ZWluZ1N0cmF0ZWd5IiwiY29udHJvbGxlciIsInN0YXJ0Q2FwYWJpbGl0eSIsInN0YXJ0Q2FsbCIsInB1bGxDYWxsIiwiY2FuY2VsQ2FsbCIsImlzQ2xvc2VkIiwiZGVzaXJlZFNpemUiLCJwdWxsIiwicHVsbENhcGFiaWxpdHkiLCJjYW5jZWxDYXBhYmlsaXR5Iiwic3RyZWFtU2luayIsImlzQ2FuY2VsbGVkIiwibGFzdERlc2lyZWRTaXplIiwic2lua0NhcGFiaWxpdHkiLCJzdHJlYW1Db250cm9sbGVyIiwiZGVsZXRlU3RyZWFtQ29udHJvbGxlciIsImFsbFNldHRsZWQiLCJTRUVEIiwiTUFTS19ISUdIIiwiTUFTS19MT1ciLCJzZWVkIiwiaDEiLCJoMiIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJMSU5FX0RFU0NFTlRfRkFDVE9SIiwiQkFTRUxJTkVfRkFDVE9SIiwiU0FWRSIsIlJFU0laRSIsIkZSRUVURVhUX09QQUNJVFkiLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiU09VTkQiLCJNT1ZJRSIsIlNDUkVFTiIsIlBSSU5URVJNQVJLIiwiVFJBUE5FVCIsIldBVEVSTUFSSyIsIlRIUkVFRCIsIlJFREFDVCIsIkFubm90YXRpb25SZXBseVR5cGUiLCJHUk9VUCIsIlJFUExZIiwiQW5ub3RhdGlvbkZsYWciLCJISURERU4iLCJOT1pPT00iLCJOT1JPVEFURSIsIk5PVklFVyIsIlJFQURPTkxZIiwiTE9DS0VEIiwiVE9HR0xFTk9WSUVXIiwiTE9DS0VEQ09OVEVOVFMiLCJBbm5vdGF0aW9uRmllbGRGbGFnIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiRSIsIlgiLCJEIiwiVSIsIkZvIiwiQmwiLCJQTyIsIlBDIiwiUFYiLCJLIiwiRiIsIlYiLCJDIiwiRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUiLCJXQyIsIldTIiwiRFMiLCJXUCIsIkRQIiwiUGFnZUFjdGlvbkV2ZW50VHlwZSIsIk8iLCJFUlJPUlMiLCJXQVJOSU5HUyIsIklORk9TIiwic2hvd1NwYWNlZFRleHQiLCJuZXh0TGluZVNob3dUZXh0IiwibmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQiLCJzZXRTdHJva2VDb2xvclNwYWNlIiwic2V0RmlsbENvbG9yU3BhY2UiLCJzZXRTdHJva2VDb2xvciIsInNldEZpbGxDb2xvciIsInNldFN0cm9rZUdyYXkiLCJzZXRGaWxsR3JheSIsInNldFN0cm9rZUNNWUtDb2xvciIsInNldEZpbGxDTVlLQ29sb3IiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIk5FRURfUEFTU1dPUkQiLCJJTkNPUlJFQ1RfUEFTU1dPUkQiLCJsZXZlbCIsImNvbmQiLCJfaXNWYWxpZFByb3RvY29sIiwiYWRkRGVmYXVsdFByb3RvY29sIiwiZG90cyIsInRyeUNvbnZlcnRFbmNvZGluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsImFic29sdXRlVXJsIiwibm9uU2VyaWFsaXphYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIk1BWF9BUkdVTUVOVF9DT1VOVCIsInN0ckJ1ZiIsImNodW5rRW5kIiwib2JqZWN0U2l6ZSIsImJ1ZmZlcjgiLCJ2aWV3MzIiLCJoZXhOdW1iZXJzIiwidGVtcCIsIm0xIiwibTIiLCJ4dCIsInl0IiwidHJhbnNwb3NlIiwic3FydCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJ0dmFsdWVzIiwidCIsInQxIiwidDIiLCJiMmFjIiwic3FydGIyYWMiLCJtdCIsImpsZW4iLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsInN0cmluZ1RvUERGU3RyaW5nIiwiZGVjb2RlZCIsImNoYXJDb2RlIiwiY2hhckF0IiwiZXNjYXBlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidiIsImlzQXJyYXlFcXVhbCIsImFycjEiLCJhcnIyIiwiZ2V0TW9kaWZpY2F0aW9uRGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIl8iLCJub3JtYWxpemUiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiYnVmIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJleHBvcnRzIiwibW9kdWxlIiwid2VicGFja1F1ZXVlcyIsIndlYnBhY2tFeHBvcnRzIiwid2VicGFja0Vycm9yIiwicmVzb2x2ZVF1ZXVlIiwicXVldWUiLCJmb3JFYWNoIiwiZm4iLCJ3cmFwRGVwcyIsImRlcHMiLCJkZXAiLCJyZXQiLCJoYXNBd2FpdCIsImRlcFF1ZXVlcyIsImN1cnJlbnREZXBzIiwib3V0ZXJSZXNvbHZlIiwicmVqIiwiZ2V0UmVzdWx0IiwiZm5RdWV1ZSIsImVyciIsImRlZmluaXRpb24iLCJvIiwicGRmanNMaWIiLCJwZGZqc0xpYlByb21pc2UiLCJfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25Nb2RlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0NNYXBDb21wcmVzc2lvblR5cGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JQaWNrZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fRE9NU1ZHRmFjdG9yeSIsIl9fd2VicGFja19leHBvcnRzX19EcmF3TGF5ZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fRmVhdHVyZVRlc3QiLCJfX3dlYnBhY2tfZXhwb3J0c19fR2xvYmFsV29ya2VyT3B0aW9ucyIsIl9fd2VicGFja19leHBvcnRzX19JbWFnZUtpbmQiLCJfX3dlYnBhY2tfZXhwb3J0c19fSW52YWxpZFBERkV4Y2VwdGlvbiIsIl9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX09QUyIsIl9fd2VicGFja19leHBvcnRzX19PdXRsaW5lciIsIl9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyIsIl9fd2VicGFja19leHBvcnRzX19QREZXb3JrZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fUGFzc3dvcmRSZXNwb25zZXMiLCJfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWciLCJfX3dlYnBhY2tfZXhwb3J0c19fUGl4ZWxzUGVySW5jaCIsIl9fd2VicGFja19leHBvcnRzX19Qcm9taXNlQ2FwYWJpbGl0eSIsIl9fd2VicGFja19leHBvcnRzX19SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fWGZhTGF5ZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQiLCJfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsIl9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsIiwiX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCIsIl9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQiLCJfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lIiwiX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSIsIl9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51IiwiX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fcmVuZGVyVGV4dExheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX3NldExheWVyRGltZW5zaW9ucyIsIl9fd2VicGFja19leHBvcnRzX19zaGFkb3ciLCJfX3dlYnBhY2tfZXhwb3J0c19fdXBkYXRlVGV4dExheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX3ZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;